<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OC消息转发]]></title>
      <url>%2F2017%2F03%2F10%2FOC%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
      <content type="text"><![CDATA[在调用方法的时候，系统会首先来查找有没有对应的方法的实现，在没有对应的实现的时候，系统会随后调用一些补救方法，当这些方法也没有实现的时候，才会crash，这是一个方法调用的完整过程。当没有方法的实现的时候，补救方法的调用顺序依次为：（一个是类方法的调用所对应的方法，一个是对象方法）+(BOOL)resolveInstanceMethod:(SEL)sel 或者 +(BOOL)resolveClassMethod:(SEL)sel 当这个方法依然无法提供方法的实现的时候，那么，系统会调用下面的方法： -(id)forwardingTargetForSelector:(SEL)aSelector 而当这个方法也无法提供调用方法的实现，那么，最后一次补救机会就是下面方法： -(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector -(void)forwardInvocation:(NSInvocation *)anInvocation 当这三次补救机会都未能提供方法实现的情况下，那么，就crash 这就是整个的调用顺序。 以下通过代码的来补充说明： 首先是在没有提供调用方法的实现，并且没有采取任何的补救措施的情况下的调用情况： 这个时候调用就直接报错： 方法找不到 方法一： 在Man.m当中，重写+(BOOL)resolveInstanceMethod:(SEL)sel方法 1234567891011121314151617#import &quot;Man.h&quot;#import &lt;objc/runtime.h&gt;@implementation Man+(BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == @selector(cook)) &#123;//把这个方法实现动态的添加进去(现在是在调用到这个方法的时候才添加)//当这个方法的实现被添加进去了之后，下次再调用cook方法就不会再进入到这个方法当中，因为现在已经添加了cook方法的时候，而resolveInstanceMethod只会在没有cook方法的实现的时候，才会被调用class_addMethod([self class], sel, (IMP)cook, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void cook (id self, SEL _cmd)&#123;NSLog(@&quot;man 做饭呢&quot;);&#125;@end 方法二： (没有重新方法一，或者方法一没有解决问题的情况下，就会采取方法二)1.首先是创建一个新的类woman类，这个类有cook方法的实现 12345@implementation Woman-(void)cook&#123;NSLog(@&quot;woman cook&quot;);&#125;@end 在调用man的cook方法的时候，进入到下面方法：12345678-(id)forwardingTargetForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;//这个地方就相当于自己实现不了 ，那么就交给别的对象来提供实现，就是转移return [[Woman alloc] init];&#125;return [super forwardingTargetForSelector:aSelector];&#125; 方法三： 当以上两个方法都无法解决的情况下，那么以下方法就成为了最后的一次补救机会：123456789101112131415-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];&#125;return [super methodSignatureForSelector:aSelector];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;SEL selector = anInvocation.selector;NSString *aSelectorStr = NSStringFromSelector(selector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;[anInvocation invokeWithTarget:[[Woman alloc] init]];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 Runtime 为 UIStackView 添加分割线]]></title>
      <url>%2F2017%2F03%2F10%2F%E7%94%A8-Runtime-%E4%B8%BA-UIStackView-%E6%B7%BB%E5%8A%A0%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[用 Runtime 为 UIStackView 添加分割线 使用方法：导入分类： #import &quot;UIStackView+Separator.h&quot; 使用方式 - (void)viewDidLoad { [super viewDidLoad]; //给UIStackView添加方法，并且不采用继承的方式 self.stackView.separatorColor = [UIColor grayColor]; self.stackView.separatorThickness = 1; self.stackView.separatorLength = 50; } UIStackView+Separator.h： #import &lt;UIKit/UIKit.h&gt; @interface UIStackView (Separator) @property UIColor *separatorColor; @property CGFloat separatorLength; @property CGFloat separatorThickness; @end UIStackView+Separator.m： #import &quot;UIStackView+Separator.h&quot; #import &lt;objc/runtime.h&gt; @interface UIStackViewSeparatorHelper : NSObject @property (nonatomic, strong) UIColor *separatorColor; @property (nonatomic, assign) CGFloat separatorLength; @property (nonatomic, assign) CGFloat separatorThickness; @property (nonatomic, weak) UIStackView *stackView; @property (strong, nonatomic) NSMutableArray&lt;UIView *&gt; *separatorViews; -(void)makeSeparators; @end @implementation UIStackViewSeparatorHelper -(instancetype)init{ if (self = [super init]) { self.separatorThickness = 1; self.separatorViews = [NSMutableArray array]; } return self; } -(void)makeSeparators{ UIStackView * __strong strongStackView = self.stackView; // if (!strongStackView || !self.separatorColor || (self.separatorLength &lt;= 0)) { return; } //从Superview当中移除 [self.separatorViews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { [obj removeFromSuperview]; }]; //移除所有的元素 [self.separatorViews removeAllObjects]; // [strongStackView.arrangedSubviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if (idx == 0) { return; } //idx == 1 取出第0个 遍历出当前的一个的时候，取出上一个 UIView *previousView = strongStackView.arrangedSubviews[idx - 1]; //创建了一个分割线 UIView *separatorView = [[UIView alloc] init]; //设置背景颜色 separatorView.backgroundColor = self.separatorColor; // CGFloat center; //如果排布的方式是水平的时候 if (strongStackView.axis == UILayoutConstraintAxisHorizontal) { // center = (CGRectGetMaxX(previousView.frame) + CGRectGetMinX(obj.frame)) / 2.0; separatorView.frame = CGRectMake(center, (CGRectGetHeight(strongStackView.frame) - self.separatorLength) / 2.0, self.separatorThickness, self.separatorLength); } else { center = (CGRectGetMaxY(previousView.frame) + CGRectGetMinY(obj.frame)) / 2.0; separatorView.frame = CGRectMake((CGRectGetWidth(strongStackView.frame) - self.separatorLength) / 2.0, center, self.separatorLength, self.separatorThickness); } //这里使用addSubview: 而不能使用arrangedSubviews，这样就能够避免系统的布局，而由自己来布局separater [strongStackView addSubview:separatorView]; //将separatorView添加到容器数组当中 [self.separatorViews addObject:separatorView]; }]; } @end @implementation UIStackView (Separator) static const char kHelperKey; +(void)load{ // Method m1 = class_getInstanceMethod([self class], @selector(layoutSubviews)); // Method m2 = class_getInstanceMethod([self class], @selector(tc_layoutSubviews)); // method_exchangeImplementations(m1, m2); // Class cls = [self class]; Method oriMethod = class_getInstanceMethod(cls, @selector(layoutSubviews)); Method newMethod = class_getInstanceMethod(cls, @selector(tc_layoutSubviews)); //v@: method_getTypeEncoding BOOL didAddMethod = class_addMethod([self class], @selector(layoutSubviews), method_getImplementation(newMethod), &quot;v@:&quot;); if (didAddMethod) { class_replaceMethod([self class], @selector(tc_layoutSubviews), method_getImplementation(oriMethod), &quot;v@:&quot;); }else{ method_exchangeImplementations(oriMethod, newMethod); } } #pragma mark --setter and getter /*-------这里的属性因为分类无法存储的缘故，所以采用了转移到其他类，我们只要拥有这个其他类，就能够获取到他的属性-------*/ /*------------当触发set方法的时候，不仅要触发出传入值得存储，同时要创建和布局分割线----------------*/ -(void)setSeparatorColor:(UIColor *)separatorColor{ [self stackViewSeparatorHelper].separatorColor = separatorColor; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorLength:(CGFloat)separatorLength{ [self stackViewSeparatorHelper].separatorLength = separatorLength; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorThickness:(CGFloat)separatorThickness{ [self stackViewSeparatorHelper].separatorThickness = separatorThickness; [[self stackViewSeparatorHelper] makeSeparators]; } -(CGFloat)separatorThickness{ return [self stackViewSeparatorHelper].separatorThickness; } -(UIColor *)separatorColor{ return [self stackViewSeparatorHelper].separatorColor; } -(CGFloat)separatorLength{ return [self stackViewSeparatorHelper].separatorLength; } -(UIStackViewSeparatorHelper *)stackViewSeparatorHelper{ UIStackViewSeparatorHelper *stackViewSeparatorHelper = objc_getAssociatedObject(self, &amp;kHelperKey); //在这个get方法当中，如果没有get到，那么就触发set的操作 if (!stackViewSeparatorHelper) { UIStackViewSeparatorHelper * helper = [[UIStackViewSeparatorHelper alloc] init]; helper.stackView = self; objc_setAssociatedObject(self, &amp;kHelperKey, helper, OBJC_ASSOCIATION_RETAIN_NONATOMIC); stackViewSeparatorHelper = helper; } return stackViewSeparatorHelper; } /** *在布局stackView的时候，这个时候，就需要同时布局分割线，所以，必须要监听到layoutSubViews方法 * 比如说，UIStackView添加了子控件（通过arrangedSubviews添加），那么就会调用这个方法来布局 ，这个时候 ，就需要重新布局separator * UIStackView 只会负责 arrangedSubviews 的布局，也就是说我们利用这个特性来将分割线直接加到 stack view 上而不受其布局，只要我们不使用 addArrangedSubView 即可。 */ -(void)tc_layoutSubviews{ //先让UIStackView的arrangedSubviews完成布局 [self tc_layoutSubviews]; //布局separater [[self stackViewSeparatorHelper] makeSeparators]; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIVisualEffect 模糊动画]]></title>
      <url>%2F2017%2F03%2F09%2FUIVisualEffect-%E6%A8%A1%E7%B3%8A%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[UIVisualEffect 模糊动画Demo @interface ViewController () @property (weak, nonatomic) IBOutlet UIVisualEffectView visualEffect; @property (weak, nonatomic) IBOutlet UILabel label; @property (weak, nonatomic) IBOutlet NSLayoutConstraint *topLayoutConstraint; @end @implementation ViewController - (IBAction)visualEffectViewClick:(id)sender { if (self.label.hidden == YES) { self.label.hidden = NO; self.topLayoutConstraint.constant = 160; UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:(UIBlurEffectStyleDark)]; [UIView animateWithDuration:1 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{ self.visualEffect.effect = blurEffect; self.label.textColor = [UIColor colorWithWhite:1 alpha:1]; [self.view layoutIfNeeded]; } completion:nil]; }else{ self.topLayoutConstraint.constant = 0; [UIView animateWithDuration:0.2 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(0) animations:^{ self.label.textColor = [UIColor colorWithWhite:1 alpha:0.2]; [self.view layoutIfNeeded]; self.visualEffect.effect = nil; } completion:^(BOOL finished) { self.label.hidden = YES; self.topLayoutConstraint.constant = 360; }]; } } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[彩虹渐变的滚动列表]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%BD%A9%E8%99%B9%E6%B8%90%E5%8F%98%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[彩虹渐变的滚动列表原文链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#import &quot;ViewController.h&quot;@interface ViewController()&lt;UITableViewDelegate,UITableViewDataSource&gt;//数组用来存储起始颜色和终点颜色&#123;NSArray *_color;&#125;@property(nonatomic,strong) UITableView *tableView;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];//存储颜色变化的起始值和终值self-&gt;_color = @[[UIColor colorWithRed:0.85 green:0 blue:0.09 alpha:1],[UIColor colorWithRed:0.9 green:0.56 blue:0.11 alpha:1]];self.view.backgroundColor = [UIColor blackColor];self.tableView = [[UITableView alloc] initWithFrame:self.view.bounds];self.tableView.separatorStyle = UITableViewCellSelectionStyleNone;self.tableView.contentInset = UIEdgeInsetsMake(20, 0, 0, 0);self.tableView.delegate =self;self.tableView.dataSource = self;UIVisualEffectView *veView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]];veView.frame = CGRectMake(0, 0, self.view.bounds.size.width, 20);[self.view addSubview:self.tableView];[self.view addSubview:veView];&#125;//创建的UIColor对象无法再获取到其中的颜色组件，将这里的颜色数组作为参数传入，这样通过这个方法可获得在任何颜色设定基础上的对应颜色-(UIColor *)calculateColorWithProgress:(float)progress usingColors:(NSArray&lt;UIColor *&gt;*)colors&#123;UIColor *color1 = [colors firstObject];UIColor *color2 = [colors lastObject];// UIColor -&gt; CGColorconst CGFloat *color1Components = CGColorGetComponents(color1.CGColor);const CGFloat *color2Components = CGColorGetComponents(color2.CGColor);// 这里从终点值到初始值的差值 * progress = 【0 - 差值】float red = color1Components[0] + (color2Components[0] - color1Components[0]) * progress;float green = color1Components[1] + (color2Components[1] - color1Components[1]) * progress;float blue = color1Components[2] + (color2Components[2] - color1Components[2]) * progress;return [UIColor colorWithRed:red green:green blue:blue alpha:1];&#125;-(float)calculateProgressWithView:(UIView *)view&#123;//converRect: toView: 转换坐标系//从相对于tableView的坐标系 转换到view上去CGRect convertedRect = [view convertRect:view.bounds toView:self.view];CGFloat convertedY = convertedRect.origin.y;//[0 - 1]return convertedY / (self.view.bounds.size.height - 60);&#125;-(UITableViewCell *)makeTableViewCell&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;];cell.selectionStyle = UITableViewCellSeparatorStyleNone;cell.textLabel.font = [UIFont boldSystemFontOfSize:16];cell.textLabel.textColor = [UIColor whiteColor];//设置文字的阴影cell.textLabel.shadowColor = [UIColor colorWithWhite:0 alpha:0.4];cell.textLabel.shadowOffset = CGSizeMake(0, 1);//下面的两个 CAShapeLayer 主要是为了实现高光阴影的效果，也就是这个 cell 的上边有一条亮边，下边有层阴影CAShapeLayer *topHighlightLayer = [CAShapeLayer layer];topHighlightLayer.path = CGPathCreateWithRect(CGRectMake(0, 0, self.view.bounds.size.width, 1), nil);topHighlightLayer.fillColor = [UIColor whiteColor].CGColor;topHighlightLayer.opacity = 0.1;[cell.layer addSublayer:topHighlightLayer];CAShapeLayer *bottomShadowLayer = [CAShapeLayer layer];bottomShadowLayer.path = CGPathCreateWithRect(CGRectMake(0, 59, self.view.bounds.size.width, 1), nil);bottomShadowLayer.fillColor = [UIColor blackColor].CGColor;bottomShadowLayer.opacity = 0.2;[cell.layer addSublayer:bottomShadowLayer];return cell;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 30;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *CellIdentifiter = @&quot;Cell&quot;;UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:CellIdentifiter];if (!cell) &#123; cell = [self makeTableViewCell];&#125;cell.textLabel.text = [NSString stringWithFormat:@&quot;This is test item %ld&quot;,indexPath.row];cell.detailTextLabel.text = @&quot;1&quot;;return cell;&#125;//需要注意的是，cell 刚创建完毕后滚动的代理方法是不会触发的//所以我们需要用到tableView:willDisplayCell:forRowAtIndexPath:这个代理方法来对每个新建的 cell 作相应设置。-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;//设置cell的背景色cell.backgroundColor = [self calculateColorWithProgress:[self calculateProgressWithView:cell] usingColors:self -&gt; _color];&#125;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;return 60;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;if ([scrollView isEqual:self.tableView]) &#123; //获取所有可见的cell [self.tableView.visibleCells enumerateObjectsUsingBlock:^(__kindof UITableViewCell * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; float progress = [self calculateProgressWithView:obj]; UIColor *color = [self calculateColorWithProgress:progress usingColors:self -&gt; _color]; obj.backgroundColor = color; &#125;];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巧妙运用对象关联设计alertview]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B7%A7%E5%A6%99%E8%BF%90%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E8%AE%BE%E8%AE%A1alertview%2F</url>
      <content type="text"><![CDATA[UIAlertView事件处理方式一：通过这种方式，存在的缺陷有：控件的创建和事件的处理是分布的，这样的阅读性是较差的，同时，在事件处理方法当中，当面对多个UIAlertView的时候，需要进行if else的判断，代码选得特别冗余 // button1 点击执行的方法 - (IBAction)alertClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 1000; [alertView show]; } // button2 点击执行的方法 - (IBAction)alertClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 2000; [alertView show]; } // alertview 点击执行的delegate方法,前提 需要self实现UIAlertViewDelegate协议 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (alertView.tag == 1000) { NSLog(@&quot;alertView1 执行逻辑操作&quot;); } else if (alertView.tag == 2000) { NSLog(@&quot;alertView2 执行逻辑操作&quot;); } else if (alertView.tag == 3000) { NSLog(@&quot;alertView3 执行逻辑操作&quot;); } // ...等等很多alertview } UIAlertView事件处理方式二： 在UIAlertView的分类当中UIAlertView+tc.h @interface UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void(^)()) block; @end UIAlertView+tc.m typedef void(^block)(); static char const *TCAlertViewKey = “TCAlertViewKey”; #import &quot;UIAlertView+tc.h&quot; #import &lt;objc/message.h&gt; @interface UIAlertView()&lt;UIAlertViewDelegate&gt; @end @implementation UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ objc_setAssociatedObject(self, TCAlertViewKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC); self.delegate = self; } #pragma mark -UIAlertViewDelegate -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex: (NSInteger)buttonIndex{ block block = objc_getAssociatedObject(self, TCAlertViewKey); block(alertView, buttonIndex); } @end 调用的部分： - (IBAction)buttonClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@---- %zd&quot;,alertView, index); }]; } - (IBAction)buttonClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@ +++++ %zd&quot;,alertView, index); }]; } UIAlertView事件处理方式三： typedef void(^block)(); #import &lt;objc/message.h&gt; #import &quot;UIAlertView+tc.h&quot; static char const *TCAlertViewKey = &quot;TCAlertViewKey&quot;; /** * 一个专门的类，用来处理代理事件，包括block的存储以及事件的处理 */ @interface TCAlertViewDelegate : NSObject&lt;UIAlertViewDelegate&gt; { block _block; } -(instancetype)initWithBlock:(block) block; @end @implementation TCAlertViewDelegate -(instancetype)initWithBlock:(block)block{ if (self = [super init]) { objc_setAssociatedObject(self, TCAlertViewKey, self, OBJC_ASSOCIATION_COPY_NONATOMIC); _block = block; } return self; } -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (_block) { _block(alertView, buttonIndex); } } @end @implementation UIAlertView (tc) //delegate -&gt; weak ，如果直接让TCAlertViewDelegate对象成为代理，会马上 挂掉 -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ //添加了一个关联对象，因为这个对象的存储方式是copy，所以这个对象就不会被释放 id delegate = objc_getAssociatedObject( [[TCAlertViewDelegate alloc] initWithBlock:block],TCAlertViewKey); //让这个专门的类成为代理 self.delegate = delegate; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runtime]]></title>
      <url>%2F2017%2F03%2F07%2Fruntime%2F</url>
      <content type="text"><![CDATA[runtime作用 1.发送消息 2.交换方法 3.动态添加方法 4 给分类添加属性 5.字典转模型 一、runtime简介 对于C语言，函数的调用在编译的时候，就决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候，并不能真正的决定调用哪个函数，只有在真正的运行的时候才会根据函数的名称找到对应的函数来调用 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错 在编译阶段，C语言调用未实现的函数就会报错 二、runtime作用 1.发送消息 方法调用的本质，就是让对象发送消息 objc_megSend,只有对象才能发送消息，因此以objc开头 使用消息机制前提，必须导入#import clang -rewrite-objc main.m 查看最终生成代码 123@autoreleasepool &#123;Person *person = [[Person alloc] init];&#125; 123456int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));&#125;return 0;&#125; 或者12Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;init&quot;)); 创建person对象12345678910111213Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 示例12345Person.h@interface Person : NSObject- (void)run:(NSInteger)metre;- (void)eat;@end Person.m123456789101112131415161718192021222324#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;NSLog(@&quot;吃&quot;);&#125;- (void)run:(NSInteger)metre&#123;NSLog(@&quot;跑了%ld&quot;,metre);&#125;@end消息的发送（方法的调用底层实现是对消息的发送）Person *p = objc_msgSend([Person class], @selector(alloc));//Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));p = objc_msgSend(p, @selector(&quot;init&quot;));//调用eat方法[p eat];//或者//msgSend(p, @selector(&quot;eat&quot;));//msgSend(p, sel_registerName(&quot;eat&quot;));//调用run：方法[p run:20];//msgSend(p , @selector(run:), 20);//msgSend(p, sel_register(&quot;run:&quot;), 20); 2.交换方法 开发场景： 系统自动的方法功能不够用，给系统自带的方法扩展一些功能，并且保持原有的功能，使用runtime交换方法需求：在项目当中，我们一直以来通过imageNamed：方法来加载图片，但是我们无法得知图片是否加载成功，现在，提出这样的需求，需要我们在调用这个方法的时候，同时得知图片是否加载成功。分析： 使用继承： 需要我们在所有使用到imageNamd:方法的地方都导入继承类的头文件，并且更改方法的调用者，而且需要告知其他的开发人员，需要调用这个继承的类，所以，使用起来很不方便使用分类：这样会覆盖系统的实现， 就是完全的重新实现这个方法所以，对于这样的开发需求，更好的实现方法是通过runtime的交换方法来实现 通过继承的方式来实现需求：123456789101112#import &quot;TCImage.h&quot;@implementation TCImage+(UIImage *)imageNamed:(NSString *)name&#123;UIImage *image = [super imageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，就会麻烦一些：首先需要导入头文件 #import “TCImage.h”在调用方法的时候，就需要通过一个新的类来调用UIImage *image = [UIImage imageNamed:@””];而运用runtime，通过交换方法的实现：123456789101112131415161718#import &quot;UIImage+Image.h&quot;#import &lt;objc/message.h&gt;@implementation UIImage (Image)+(void)load&#123;Method m1 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(imageNamed:));Method m2 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(tcimageNamed:));method_exchangeImplementations(m1, m2);&#125;+(instancetype)tcimageNamed:(NSString *)name&#123;UIImage *image = [self tcimageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，没有任何的改变，但已经在系统实现的基础上，多了获取是否加载成功的功能 3.动态添加方法开发使用场景： 如果一个类方法非常多，加载到内存的时候也比较耗资源，需要给每个方法生成映射表，可以通过动态给某个类添加方法比如：很多应用都分了会员和非会员，很多方法，在非会员的时候，完全都不会使用到，这个时候把方法加载到内存是比较费资源的，没有必要生成这些不会用到的方法的映射表 这个时候，就可以通过动态添加方法来解决这一问题，当用到这个方法的时候再去添加实现调用一个并没有添加实现的方法，需要用到performSelector12Person *p = [[Person alloc] init];[p performSelector:@selector(run:) withObject:@10]; 在Person.m文件中1234567891011121314void aaa(id self, SEL _cmd, NSNumber *meter) &#123;NSLog(@&quot;跑了%@&quot;, meter);&#125;// 任何方法默认都有两个隐式参数,self,_cmd// 什么时候调用:只要一个对象调用了一个未实现的方法就会调用这个方法,进行处理// 作用:动态添加方法,处理未实现+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == NSSelectorFromString(@&quot;run:&quot;)) &#123;class_addMethod(self, sel, (IMP)aaa, &quot;v@:@&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125; 4 给分类添加属性分析： 给一个类声明属性，本质就是给这个类添加关联对象，而不是直接把这个值的内存添加到类内存当中应用场景： 给一个系统的类添加一个关联对象（新增属性）给系统类NSObject添加一个那么属性 1234@interface NSObject (Property)//在分类当中，这里只会生成get和set方法的声明，并不会生成方法的实现，所以，也就没有必要说明存储机制@property NSString *name;@end .m文件12345678910#import &quot;NSObject+Property.h&quot;#import &lt;objc/message.h&gt;@implementation NSObject (Property)-(NSString *)name&#123;return objc_getAssociatedObject(self, &quot;name&quot;);&#125;-(void)setName:(NSString *)name&#123;objc_setAssociatedObject(self, &quot;name&quot;, name,OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题： 一个一个的添加模型属性是一件乏味没有技术含量耗时的操作 需求：能不能自动根据字典，生成对应的属性 解决： 提供一个分类，专门根据字典生成对应的属性字符串 1234567891011121314151617181920212223242526272829303132@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123;// 拼接属性字符串代码NSMutableString *strM = [NSMutableString string];// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;// 类型经常变，抽出来NSString *type;if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;type = @&quot;NSString&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;type = @&quot;NSArray&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;type = @&quot;int&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;type = @&quot;NSDictionary&quot;;&#125;// 属性字符串NSString *str;if ([type containsString:@&quot;NS&quot;]) &#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];&#125;else&#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];&#125;// 每生成属性字符串，就自动换行。[strM appendFormat:@&quot;\n%@\n&quot;,str];&#125;];// 把拼接好的字符串打印出来，就好了。NSLog(@&quot;%@&quot;,strM);&#125;@end 字典转模型的方式一：KVC 12345678@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123;Status *status = [[self alloc] init];[status setValuesForKeysWithDictionary:dict];return status;&#125;@end 转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 //因为通过key没有找到对应的属性，所以调用setValue:forUndefinedKey:报错，那么，通过通过重新这个方法的实现就避免了报错123- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; &#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 解析Plist文件NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];// 获取字典数组NSArray *dictArr = statusDict[@&quot;statuses&quot;];// 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];_statuses = [NSMutableArray array];// 遍历字典数组for (NSDictionary *dict in dictArr) &#123;Status *status = [Status modelWithDict:dict];[_statuses addObject:status];&#125;// 测试数据NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123;// 思路：遍历模型中所有属性-》使用运行时// 0.创建对应的对象id objc = [[self alloc] init];// 1.利用runtime给对象中的成员属性赋值// class_copyIvarList:获取类中的所有成员属性// Ivar：成员属性的意思// 第一个参数：表示获取哪个类中的成员属性// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。/* 类似下面这种写法Ivar ivar;Ivar ivar1;Ivar ivar2;// 定义一个ivar的数组aIvar a[] = &#123;ivar,ivar1,ivar2&#125;;// 用一个Ivar *指针指向数组第一个元素Ivar *ivarList = a;// 根据指针访问数组第一个元素ivarList[0];*/unsigned int count;// 获取类中的所有成员属性Ivar *ivarList = class_copyIvarList(self, &amp;count);for (int i = 0; i &lt; count; i++) &#123;// 根据角标，从数组取出对应的成员属性Ivar ivar = ivarList[i];// 获取成员属性名NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];// 处理成员属性名-&gt;字典中的key// 从第一个角标开始截取NSString *key = [name substringFromIndex:1];// 根据成员属性名去字典中查找对应的valueid value = dict[key];// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型// 判断下value是否是字典if ([value isKindOfClass:[NSDictionary class]]) &#123;// 字典转模型// 获取模型的类对象，调用modelWithDict// 模型的类名已知，就是成员属性的类型// 获取成员属性类型NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];// 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符// 裁剪类型字符串NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];type = [type substringFromIndex:range.location + range.length];range = [type rangeOfString:@&quot;\&quot;&quot;];// 裁剪到哪个角标，不包括当前角标type = [type substringToIndex:range.location];// 根据字符串类名生成类对象Class modelClass = NSClassFromString(type);if (modelClass) &#123; // 有对应的模型才需要转// 把字典转模型value = [modelClass modelWithDict:value];&#125;&#125;// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.// 判断值是否是数组if ([value isKindOfClass:[NSArray class]]) &#123;// 判断对应类有没有实现字典数组转模型数组的协议if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;// 转换成id类型，就能调用任何对象的方法id idSelf = self;// 获取数组中字典对应的模型NSString *type = [idSelf arrayContainModelClass][key];// 生成模型Class classModel = NSClassFromString(type);NSMutableArray *arrM = [NSMutableArray array];// 遍历字典数组，生成模型数组for (NSDictionary *dict in value) &#123;// 字典转模型id model = [classModel modelWithDict:dict];[arrM addObject:model];&#125;// 把模型数组赋值给valuevalue = arrM;&#125;&#125;if (value) &#123; // 有值，才需要给模型的属性赋值// 利用KVC给模型中的属性赋值[objc setValue:value forKey:key];&#125;&#125;return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView 顶部加入视差图片的效果]]></title>
      <url>%2F2017%2F03%2F07%2FUITableView-%E9%A1%B6%E9%83%A8%E5%8A%A0%E5%85%A5%E8%A7%86%E5%B7%AE%E5%9B%BE%E7%89%87%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[UITableView 顶部加入视差图片的效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#import &quot;ViewController.h&quot;@interface ViewController ()&lt;UITableViewDelegate,UITableViewDataSource&gt;@property(nonatomic,weak) UIImageView *imageView;@property(nonatomic,weak) UITableView *tableView;@end@implementation ViewController-(UITableView *)tableView&#123;if (_tableView == nil) &#123;UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];_tableView = tableView;_tableView.contentInset = UIEdgeInsetsMake(300, 0, 0, 0);_tableView.dataSource = self;_tableView.delegate = self;[self.view addSubview:tableView];&#125;return _tableView;&#125;-(UIImageView *)imageView&#123;if (_imageView == nil) &#123;UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, -150, self.view.bounds.size.width, 300)];imageView.layer.anchorPoint = CGPointMake(0.5, 0);_imageView = imageView;_imageView.image = [UIImage imageNamed:@&quot;IMG_0084&quot;];[self.view addSubview:_imageView];&#125;return _imageView;&#125;-(void)viewWillAppear:(BOOL)animated&#123;[super viewWillAppear:animated];[self.tableView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];[UIView beginAnimations:nil context:nil];[self makeParallaxEffect];[UIView commitAnimations];&#125;-(void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];[self.tableView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];[UIView beginAnimations:nil context:nil];self.navigationController.navigationBar.alpha = 1.0;[UIView commitAnimations];&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;if (object == _tableView) &#123;[self makeParallaxEffect];&#125;&#125;-(void)makeParallaxEffect&#123;CGFloat y = [[self.tableView valueForKey:@&quot;contentOffset&quot;] CGPointValue].y;if (y &lt; - 300.0) &#123;CGFloat scale = fabs(y) / 300;_imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;else if(y &lt; 0)&#123;_imageView.transform = CGAffineTransformMakeTranslation(0, -(300 + y));//y=0 alp=1 y=-300 alp=0self.navigationController.navigationBar.alpha = (y + 300)/300.0;_imageView.alpha = (1 - self.navigationController.navigationBar.alpha);&#125;&#125;-(void)viewDidLoad&#123;//这里自己来计算contentInset，所以，将automaticallyAdjustsScrollViewInsets属性值设置为NOself.automaticallyAdjustsScrollViewInsets = NO;//需要注意的是，这里的_tableView要先于_imageView添加，才能保证_imageView能够显示出来self.tableView.backgroundColor = [UIColor whiteColor];self.imageView.backgroundColor = [UIColor whiteColor];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 200;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];cell.textLabel.text = @&quot;test&quot;;return cell;&#125;-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;[self performSegueWithIdentifier:@&quot;tag&quot; sender:nil];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[innerHTML和creatTextCode区分]]></title>
      <url>%2F2017%2F03%2F05%2FinnerHTML%E5%92%8CcreatTextCode%E5%8C%BA%E5%88%86%2F</url>
      <content type="text"><![CDATA[innerHTML 与 createTextNodeinnerHTML在js是双向功能:获取对象的内容或向对象插入内容1234567891011121314&lt;p id=&quot;pid&quot;&gt;我将被替换&lt;/p&gt;&lt;button onclick=&quot;replaceContentFunction()&quot;&gt;点击替换标签&lt;/button&gt;&lt;p id=&quot;getInnerHTMLID&quot;&gt;我的内容将被获取&lt;/p&gt;&lt;button onclick=&quot;getInnerHTMLFuncation()&quot;&gt;点我获取内容&lt;/button&gt;&lt;script&gt;function replaceContentFunction() &#123;var node = document.getElementById(&quot;pid&quot;);node.innerHTML = &quot;我已经被替换啦😭&quot;;&#125;function getInnerHTMLFuncation() &#123;var node = document.getElementById(&quot;getInnerHTMLID&quot;);alert(node.innerHTML);&#125;&lt;/script&gt; 我将被替换 点击替换标签 我的内容将被获取 点我获取内容 function replaceContentFunction() { var node = document.getElementById("pid"); node.innerHTML = "我已经被替换啦😭"; } function getInnerHTMLFuncation() { var node = document.getElementById("getInnerHTMLID"); alert(node.innerHTML); } innerHTML与createTextNode区别:都可以把一段内容添加到一个节点中,区别在于:如果添加的内容当中有html标签,而这段标签在createTextNode方法中会被当做文本内容来处理,不会被浏览器解析,而在innerHTML中会被当做标签进行解析.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习之Location对象]]></title>
      <url>%2F2017%2F03%2F05%2FHTML%E5%AD%A6%E4%B9%A0%E4%B9%8BLocation%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[Location对象包含有关当前URL的信息,Location对象是window对象的一部分,可通过window.location来访问 Location对象方法 reload()定义和用法reload() 方法用于重新加载当前文档。如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。 如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift健的效果是完全一样。 实例1234&lt;script&gt;function btnClickFunc() &#123; window.location.reload()&#125;&lt;/script&gt;&lt;button onclick=&quot;btnClickFunc()&quot;&gt;点击刷新当前页面&lt;/button&gt; function btnClickFunc() { window.location.reload()} 点击刷新当前页面 assign()定义和用法assign() 方法可加载一个新的文档。语法1location.assign(URL) 实例1234&lt;script&gt;function reloadNewPageBtnClickFunc() &#123;window.location.assign(&quot;https:www.baidu.com&quot;)&#125;&lt;/script&gt;&lt;button onclick=&quot;reloadNewPageBtnClickFunc()&quot;&gt;点击加载一个新的url&lt;/button&gt; function reloadNewPageBtnClickFunc() {window.location.assign(“https:www.baidu.com”)} 点击加载一个新的url Location对象属性 属性描述hostname设置或返回当前 URL 的主机名。href设置或返回完整的 URL。pathname设置或返回当前 URL 的路径部分。protocol设置或返回当前 URL 的协议。search设置或返回从问号 (?) 开始的 URL（查询部分）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL Scheme]]></title>
      <url>%2F2017%2F03%2F04%2FURL-Scheme%2F</url>
      <content type="text"><![CDATA[URL Scheme经常使用的地方有:APP间跳转,服务器通知客户端的跳转以及H5与Naative跳转 scheme三方面的作用: 服务器下发跳转路径,客户端根据服务器发送的跳转路径进行跳转H5页面点击锚点根据锚点具体跳转路径APP端跳转具体的页面APP端收到服务器端下发的PUSH通知栏消息,根据消息的跳转路径,跳转相关页面 URL Scheme 概述客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如车辆详情页、订单详情页、消息通知页、促销广告页等等。也可以执行某些指定动作，如订单支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面。 URL scheme 的格式客户端自定义的 URL 作为从一个应用调用另一个的基础，遵循 RFC 1808 (Relative Uniform Resource Locators) 标准。这跟我们常见的网页内容 URL 格式一样。一个普通的 URL 分为几个部分，scheme、host、relativePath、query。我们用到的NSURL123NSURL *url = [NSURL URLWithString:@&quot;http://www.testurl.com:8080/subpath/subsubpath?uid=123&amp;gid=456&quot;];[url scheme]为http, [url host]为www.testurl.com，[url port]为8080，[url path]为/subpath/subsubpath，[url lastPathComponent]为subsubpath，[url query]为uid=123&amp;gid=456 一个应用中使用的 URL 例子（该 URL 会调起车辆详情页）：12zqprojectmobile://project/carDetail?car_id=123456scheme为zqprojectmobile,host为project,relativePath为/carDetail,query为car_id=123456 项目中定义了专门的类命名为JumpURLHandle，通过类方法parseURL:来处理参数中的url。本文以此为例讲解scheme的定义与解析。首先客户端应用向操作系统注册一个或者多个 URL scheme，例如项目中就定 义了多个分别scheme，分别为： 123zqprojectmobile: 对应普通APP间跳转schemezqprojectwxpay: 对应微信支付完成之后跳转回来的schemezqprojectalipay：对应支付宝支付完成之后跳转回来的scheme 对应的parseURL:方法里解析为：1234567891011121314151617181920212223//一个专门的类用于处理跳转,并且提供了一个方法解析url+ (BOOL)parseURL:(NSURL *)url&#123;//对获取到的url进行解析判断,确定跳转的性质// 支付宝客户端支付后的回调if ([[url scheme] isEqualToString:@&quot;zqprojectalipay&quot;]|| ([[[url scheme] lowercaseString] isEqualToString:kUuyongcheAlipayScheme]))&#123;return 支付宝支付完成后的回调处理方法;&#125;// 微信客户端支付后的回调 协议是zqprojectwxpay并且host是pay,则属于微信支付完成之后的回调else if ([url.scheme isEqualToString:@&quot;zqprojectwxpay&quot;] &amp;&amp; [url.host isEqualToString:@&quot;pay&quot;])&#123;return 微信支付完成后的回调处理方法;&#125;// 本应用 scheme 调用else if (([[url scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[url scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;return [[JumpURLHandle getInstance] parseAppUrl:url];&#125;return NO;&#125; 定义relativePath，并通过relativePath来判断是执行动作还是跳转页面，当执行动作时把relativePath定义为”/action”，在解析时如果url的relativePath是”/action”则跳转到执行动作的处理方法里，否则执行跳转页面的逻辑。例如：12345zqprojectmobile://project/action?name=back，relativePath为/action，执行动作（返回前页）zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，执行跳转页面的逻辑 代码：12345678910111213141516- (BOOL)parseAppUrl:(NSURL *)url&#123;NSString *relativePath = [url relativePath];// scheme 调起执行动作if ([relativePath isEqualToString:@&quot;/action&quot;])&#123;[self jumpActions:url];&#125;// scheme 调起跳转页面else&#123;[self jumpNativeViewControllers:url];&#125;return YES;&#125; 如果是执行动作的逻辑，获取query，字符串处理，获取键值对，获取名称为”name”的key对应的字符串，字符串对比判断执行相应的动作例如：12qprojectmobile://project/action?name=back，relativePath为/action，query为name=back，字符串处理后得到字典@&#123;name:back&#125;, 代码：1234567891011- (void)jumpActions:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *actionName = [dictionaryQuery objectForKey:@&quot;name&quot;];// 返回前面的页面if ([actionName isEqualToString:@&quot;back&quot;])&#123;//返回上一个页面的动作&#125; 如果是执行跳转页面的逻辑，可以直接将要跳转的页面设置为relativePath的值，然后获取relativePath字符串进行对比跳转相应的页面。如果页面跳转需要传值可以放到query里，获取url的query，字符串处理，获取键值对，一一赋值，例如：1234zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，跳转到订单详情页面query为order_id=42347645&amp;type=2，字符串处理获取字典@&#123;order_id:42347645,type:2&#125;,订单详情页面的订单id为order_id对应的值42347645，订单类型为2 代码：123456789101112131415161718- (void)jumpNativeViewControllers:(NSURL *)url&#123;NSString *relativePath = [url relativePath];if ([relativePath isEqualToString:@&quot;/order&quot;])&#123;[self jumpOrder:url];&#125;&#125;- (void)jumpOrder:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *orderId = [dictionaryQuery objectForKey:@&quot;orderId&quot;];NSString *type = [dictionaryQuery objectForKey:@&quot;type&quot;];// 创建新的订单页面并且传值&#125; 通过以上几步就可以定义出一个完整的scheme协议并且在JumpURLHandle类里完成解析 需要用到JumpURLHandle解析scheme的地方APP端收到服务器端下发的PUSH通知栏消息和APP相互跳转时需要在AppDelegate里处理12345678910/ 废弃- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation&#123;return [JumpURLHandle parseURL:url];&#125;或者- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123;return [JumpURLHandle parseURL:url];&#125; 服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面,在一个网络请求成功的回调方法或者block里拿到url，调用[JumpURLHandle parseURL:url]; H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面，在UIWebView的代理方法12- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType 中调用，该回调方法返回YES时webView才继续加载页面，当我们通过scheme解析处理事件时就不需要再继续加载页面返回NO.UIWebViewNavigationType的类型有：UIWebViewNavigationTypeLinkClicked，用户触击了一个链接。UIWebViewNavigationTypeFormSubmitted，用户提交了一个表单。UIWebViewNavigationTypeBackForward，用户触击前进或返回按钮。UIWebViewNavigationTypeReload，用户触击重新加载的按钮。UIWebViewNavigationTypeFormResubmitted，用户重复提交表单UIWebViewNavigationTypeOther，发生其它行为。并且不能所有在webView上发生的动作都靠scheme协议解析解决，只有在webView发生用户点击事件或者其他行为时我们才根据request.url进一步判断是否需要scheme解析，代码如下：12345678910111213141516-(BOOL)webView:(UIWebView *)webViewshouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType&#123;if (navigationType == UIWebViewNavigationTypeLinkClicked|| navigationType == UIWebViewNavigationTypeOther)&#123;if (([[request.URL scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[request.URL scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;[JumpURLHandle parseURL:request.URL];return NO;&#125;&#125;return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWebView认识]]></title>
      <url>%2F2017%2F03%2F04%2FUIWebView%E8%AE%A4%E8%AF%86%2F</url>
      <content type="text"><![CDATA[Objective-C和JavaScript相互调用 通过非框架的方式完成相互的调用OC调用JavaScript语言,通过UIWebView的下面方法来实现1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 该方法向UIWebView传递一段需要执行的JavaScript文件,来获得执行的结果JavaScript调用OC语言,利用UIWebView的特性:在UIWebView内发起的所有网络请求都可以通过delegte函数在原生界面得到通知,我们在UIWebView中发起一个特殊的网络请求,请求加载的网址内容通常不是真实的地址,地址往往类似这样:gap://methodname?argument在delegate的函数中,我们只需要发现是gap://开头地址,就不进行加载转而执行相应的调用逻辑.123456789101112-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;NSURL *url = [request url];if ([[url scheme] isEqualToString:@&quot;gap&quot;])&#123;//在这里做JavaScript调用oc的事情...//做完之后用以下方法调用JavaScript[webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;done&apos;)&quot;];return NO;&#125;return YES;&#125; 在UIWebView发起一个特殊的网络请求也有很多的办法,最合适的方式是一个临时的隐藏的iFrame,在iFrame中加载这个特殊的网络请求12345678910111213141516171819function loadURL(url)&#123;var iFrame;//创建一个临时的元素iframe = document.createElement(&quot;IFRAME&quot;);//设置临时元素的属性和属性值//添加属性,携带urliFrame.setAttribute(&quot;src&quot;,url);//设置style属性,并且隐藏元素iFrame.setAttribute(&quot;style&quot;,&quot;display: none;&quot;);iFrame.setAttribute(&quot;height&quot;,&quot;Opx&quot;);iFrame.setAttribute(&quot;width&quot;,&quot;Opx&quot;);//规定是否显示框架周围的边框。iFrame.setAttribute(&quot;frameborder&quot;,&quot;0&quot;);//添加属性到bodydocument.body.appendChild(iFrame);//发起请求后这个iFrame就没用了,所以需要把它从dom上移除掉iFrame.parentNode.removeChild(iFrame);iFrame = null;&#125; 当点击按钮的时候1&lt;button onclick=&quot;loadURL(&apos;abc&apos;)&quot;&gt;click&lt;/button&gt; ,通过调用这个function,就能够在1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 方法中截取到请求内容,从而判断来自于js的事件 WebViewJavascriptBridge的使用 iOS端如何使用1.开启日志12// 开启日志，方便调试[WebViewJavascriptBridge enableLogging]; 2.给ObjC与JS建立桥梁1234567给哪个webView建立js与objc的沟通桥梁self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];//代理的设置 这个地方,通过调用这个方法,将自己设置为代理,只是没有直接的通过.delegate来设置,而是通过调用WebViewJavascriptBridge的setWebViewDelegate:方法,都是将自己设为代理,不同的是,通过.delegate是直接将自己设置为代理,而通过调用WebViewJavascriptBridge的setWebViewDelegate,实现了在WebViewJavascriptBridge中将WebViewJavascriptBridge自身设置为真正的代理,完成对UIWebVieView的监听,而同时将代理的回调传递出去.这样就是同一对象的两个监听者[self.bridge setWebViewDelegate:self]; 3.注册HandleName，用于给JS端调用iOS端12345678910111213141516171819// JS主动调用OjbC的方法// 这是JS会调用getUserIdFromObjC方法，这是OC注册给JS调用的// JS需要回调，当然JS也可以传参数过来。data就是JS所传的参数，不一定需要传// OC端通过responseCallback回调JS端，JS就可以得到所需要的数据[self.bridge registerHandler:@&quot;getUserIdFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getUserIdFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;userId&quot;: @&quot;123456&quot;&#125;);&#125;&#125;];[self.bridge registerHandler:@&quot;getBlogNameFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getBlogNameFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;blogName&quot;: @&quot;颠倒碎碎念&quot;&#125;);&#125;&#125;]; JS端如何使用1.将下面的代码放在JS中123456789101112/*这段代码是固定的，必须要放到js中*///这段代码是固定的书写内容,将这段代码copy and paste到js当中function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&apos;iframe&apos;);WVJBIframe.style.display = &apos;none&apos;;WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 2.在下面的方法当中写相关的js代码:1234setupWebViewJavascriptBridge(function(bridge) &#123;/* Initialize your app here */所有与iOS交互的JS代码放这里！&#125;) 3.JS调用iOS代码通过bridge.callHandler来调用：123456bridge.callHandler(&apos;getBlogNameFromObjC&apos;,&#123;&apos;blogURL&apos;: &apos;http://www.huangyibiao.com&apos;&#125;,function callback(response) &#123;log(&apos;JS got response&apos;, response)&#125;&#125;) 其中的各个参数说明,getBlogNameFromObjC是iOS端注册的handleName,在iOS端也通过这个hanleName完成注册后JS直接通过这个handleName与iOS交互.比如,当点击按钮的时候就执行上面的操作,这样一来,js就将参数传递给了iOS端,iOS收到传递的参数然后通过回调给js.callback:js函数名,在iOS端收到回调后拿到了参数,然后通过闭包回调反馈给js端. 如何传递参数参数传递最简单的方式是将参数作为URL的一部分放到iFrame的src中.UIWebView通过截取分析URL后面的内容即可获得参数.但是,如果参数是一个很复杂的对象,那么这个URL的编码就会很复杂.对此可采取的方案是: 将参数以JSON的形式传递,但是因为要附加在URL之后,所以我们需要将JSON进行Base64编码,以保证URL中不会出现一些非法字符线程阻塞问题当在Objective-C语言中调用stringByEvaluatingJavaScriptFromString:方法必须在主线程执行,而主线程的执行时间过长会阻塞UI的更新.所以我们应该尽量让stringByEvaluatingJavaScriptFromString:方法执行时间短.像云笔记这样的App在保存笔记的时候,需要调用JavaScript代码来获得笔记的完整HTML内容,这个时候,如果笔记内容很复杂,就会执行很长的一段时间,而因为这个操作必须是主线程执行,所以我们要显示”正在保存”的UIAlertView完全无法正常显示,整个UI界面就完全卡主了,所以,这个时候,就需要更新获取HTML内容的代码,来缩短这个执行时长.使用Safari进行调试苹果支持用Safari浏览器直接连接到模拟器或者真机来进行相关HTML页面,以及JavaScript逻辑的调试. 打开Safari的调试模式,选择 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 勾选 “在菜单栏中显示开发菜单”2.同时需要在iPhone模拟器或真机的设置上把调试模式打开, 设置 -&gt; Safari -&gt; 高级 -&gt; 打开Web检查器3.重启Safari,在Safari的”开发”菜单下,就多出了对应的菜单选项我们可以在Safari中直接修改HTML代码,css效果,以及调试JavaScript.所有的效果都可以立即在UIWebView上看到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5学习第二天]]></title>
      <url>%2F2017%2F03%2F03%2FHTML5%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[盒子模型 属性每个盒子模型都有四个属性 内容(content)填充(内边距,padding)边框(border)边界(margin,外边距)标准盒子模型图内容属性heightmax-heightmin-heightwidthmax-widthmin-width填充属性(内边距,padding)paddingpadding-bottompadding-leftpadding-rightpadding-top举例子:内边距1234padding: 10px 5px 15px 10px; 设置上,左,下,右内边距padding: 10px 5px 15px; 设置上,左右,下边距padding: 10px 5px; 设置上下,左右边距padding: 10px; 设置上下左右边距边框(border):设置4个边框的样式123p&#123;border: 5px solid red;&#125;border简写属性在一个声明设置所有的边框属性可以按顺序设置如下属性:border-widthborder-styleborder-color设置边框设置: border-radius边界(margin,外边距)marginmargin-topmargin-bottommargin-leftmargin-right1234margin: 10px 5px 15px 10px; 设置上,左,下,右外边距margin: 10px 5px 15px; 设置上,左右,外边距margin: 10px 5px; 设置上下,左右外边距margin: 10px; 设置上下左右外边距CSS3新增特性RGBA透明度1&lt;div style=&quot;width: 100px; background-color: rgba(255,0,0,1)&quot;&gt;看我的效果&lt;/div&gt;看我的效果块阴影值说明:h-shadow必需。水平阴影的位置。允许负值。v-shadow必需。垂直阴影的位置。允许负值。blur可选。模糊距离。spread可选。阴影的尺寸。color可选。阴影的颜色。请参阅 CSS 颜色值。inset可选。将外部阴影 (outset) 改为内部阴影。12//设置的顺序以此为: 水平阴影, 垂直阴影, 阴影的模糊距离,以及阴影的颜色&lt;div style=&quot;width: 100px; height: 25px; box-shadow: 5px 5px 10px black;&quot;&gt;我是盒子&lt;/div&gt;我是盒子文字阴影在设置参数上与块阴影是一样的1&lt;p style=&quot;font-size: 20px; color: aqua; text-shadow: 5px 5px 10px black&quot;&gt;我看着你呢&lt;/p&gt;我看着你呢圆角 borderradius我变成了圆圆的了CSS布局默认情况下,所有的网页的布局都在标准流布局中: 从上到下,从左到右脱离标准流的方法有float属性position属性和left right top bottom属性floatfloat 属性的常用取值有left: 脱离标准流,浮动到父标签的最左边right: 脱离标准流,浮动到父标签的最右边 具体有关float CSS浮动 可查看W3School的这篇文章 通过float修改首字母样式12345678910&lt;p&gt;&lt;span style=&quot;float: left; width: 0.7em; font-size: 400%; font-family:algerian,courier; line-height:80%;&quot;&gt;T&lt;/span&gt;his is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.&lt;/p&gt; This is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text. position属性具体有关position 可查看W3School的这篇文章通常positon属性结合left top bottom right属性使用 值描述absolute生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit规定应该从父元素继承 position 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习第一天]]></title>
      <url>%2F2017%2F03%2F02%2FHTML%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[HTML5 基础介绍 2014年制定完HTML5标准 利用HTML5编写的UI能够运行在所有的浏览器的平台 手机APP的开发模式: 原生 纯HTML5 原生 + HTML5 自动更新 Web3.0 : HTML5 + CSS3 HTML5: Canvas HTML5音视频 Web存储 Geolocation Workers多线程处理 CSS3亮点: 设计动画 2D变形 一个完整的网页由三部分组成： HTML CSS JavaScript W3school HTML的常见使用 HTML： 超文本标记语言 浏览器负责将它解析成具体的网页内容，HTML语言是松散的 WebStorm的使用： 注释快捷键：command + / 线条： 1\&lt;hr&gt; 输入 1&lt;input placeholder=&quot;我是占位文字&quot;&gt; 1&lt;input value=&quot;我是默认的文字&quot;&gt; 1&lt;input type=&quot;date&quot;&gt; 1&lt;input type=&quot;file&quot;&gt; 1&lt;input type=&quot;color&quot;&gt; 1&lt;input type=&quot;radio&quot;&gt; 1&lt;input type=&quot;checkbox&quot;&gt; 图片标签 alt: 图片显示失败的时候，显示的文字提示 1&lt;img src=&quot;abc.jpg&quot; alt=&quot;这是一张图片&quot;&gt; 12&lt;!—相对路径--&gt;&lt;img src=&quot;image/IMG_0084.png&quot;&gt; 12&lt;!—绝对路径 固定了宽，高会按比例自动缩放—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;100&quot;&gt; 12&lt;!—绝对路径 设置宽与父元素的比例，这样能更好的适配，相对于设置固定的宽度—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;50%&quot;&gt; 换行标签 1&lt;br&gt; 列表标签 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 无序列表 无序列表 无序列表 无序列表 无序列表 无序列表 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 有序列表 有序列表 有序列表 有序列表 有序列表 超链接 1&lt;a target=&quot;_self&quot; href=&quot;https://www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_blank&quot; href=&quot;https:www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_top&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt; 回到顶部 1&lt;meter value=&quot;30&quot; max=&quot;100&quot; min=&quot;0&quot;&gt;30%&lt;/meter&gt; 30% 1&lt;progress value=&quot;40&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 1&lt;audio src=&quot;../audio/music.m4a&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 视频图片1&lt;video src=&quot;http://player.youku.com/player.php/Type/Folder/Fid//Ob//sid/XMjU1MjMwMDAzNg==/v.swf&quot;&gt;&lt;/video&gt; CSS CSS的使用样式 行内样式 页内样式 外部样式 行内样式1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的行内样式&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;background-color: red;&quot;&gt;//style作为元素的一个属性，将所有样式的样式写在style属性当中 &lt;div style=&quot;color: blue; font-size: 18px; background-color: aqua;&quot;&gt;我是容器标签&lt;/div&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px double purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px solid purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px dashed purple;&quot;&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 页内样式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的页内样式&lt;/title&gt; &lt;link href=&quot;css/index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- css规律: 就近原则 叠加原则 --&gt; //在head标签当中写标签样式，样式写在&lt;style&gt;&lt;/style&gt;当中 &lt;style&gt; div&#123; color: red; font-size: 30px; border: 4px solid yellow; &#125; p&#123; color: blue; font-size: 44px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外部样式1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css外部样式&lt;/title&gt; //链接外部css文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css中的内容1234567891011div&#123; color: olivedrab; font-size: 66px; background-color: green;&#125;p&#123; color: goldenrod; font-size: 2px; border: 2px solid red;&#125; CSS选择器 标签选择器 12345&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;div&#123; color: red; &#125; 类选择器12345678&lt;p class=&quot;high&quot;&gt;第一段文子&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;div class=&quot;high&quot;&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;// . + 类名.high &#123; color: red; &#125; ID选择器123456css: #main &#123; color: gray&#125;html: &lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt; 并列选择器1234567css: 用逗号(,)隔开div , .test1 &#123; color: red;&#125;html: 以下两者都满足&lt;div&gt;我是div&lt;/div&gt;&lt;p class=&quot;test1&quot;&gt;我是段落&lt;/p&gt; 123456css: id值为main，或者class值为test1#main , .test1 &#123;&#125;html: 以下两者都满足&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 复活选择器12345css: div标签并且必须类值为test1div.test1&#123;&#125;html:&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 后代选择器123456css: div中的p标签（包括子类和孙子类）div p &#123;&#125;html: 以下两个都满足&lt;div&gt;&lt;p&gt;我满足条件&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;h2&gt;&lt;p&gt;我也满足&lt;/p&gt;&lt;/h2&gt;&lt;/div&gt; 直接后代选择器12345css: div &gt; a &#123;&#125;html:&lt;div&gt;&lt;a href=&quot;#&quot;&gt;我满足&lt;/a&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;我不满足😌&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 属性选择器123456css:div[name]&#123;&#125;html:&lt;div name=&quot;jack&quot;&gt;我满足&lt;/div&gt;&lt;div name=&quot;rose&quot;&gt;我也满足&lt;/div&gt;&lt;div age=&quot;23&quot;&gt;我不满足&lt;/div&gt; 特定属性值选择器12345css:div[name=&quot;jack&quot;]&#123;&#125;html:&lt;div name=&quot;rose&quot;&gt;我不😌&lt;/div&gt;&lt;div name=&quot;jack&quot;&gt;我满足😄&lt;/div&gt; 伪类1234567891011121314151617css: /*触发某些操作的时候更改一些样式*/input:focus &#123;/*去除外线条*/outline: none;height: 50px;font-size: 20px;&#125;/*当鼠标移动上来*/#main:hover&#123;width: 300px;height: 200px;background-color: aqua;&#125;html:&lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt;&lt;input placeholder=&quot;我是输入框&quot;&gt; 伪元素/伪元素 比如段落的第一个字母变大,可以通过伪元素实现/ 选择器优先级选择器的权值： 通配选择符(*) : 0 标签: 1 类: 10 属性：10 伪类： 10 伪元素: 10 id: 100 important: 1000 原则： 选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 优先级顺序： important &gt; 内联（行内style）&gt;id&gt;类|伪类|伪元素|属性|伪元素&gt;标签&gt;统配选择符 HTML标签的分类和修改 标签的分类 块级标签 独占一行，能够通过css修改高度(div、p、h1、h2、ul、li…) 行内标签（内联标签） 多个行内标签能同时显示在一行，并且无法修改其宽高 宽度和高度取决于内容的尺寸 (span、a、label….) 行内-块级标签 (内联-块级标签) 多个行类块级标签能够显示在一行 :具备了内联标签的特点 能够设置宽度和高度(input, button) : 具备了块级标签的特点修改标签的显示类型通过css中的display属性，能够修改显示的类型 none: 隐藏标签 block: 让标签变成块级标签 inline: 让标签变成内联标签 inline-block: 让标签变成内联-块级标签 其他属性介绍cursor： 🖱鼠标样式text-decoration:规定添加到文本的修饰123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;h1 &#123;text-decoration: overline&#125;h2 &#123;text-decoration: line-through&#125;h3 &#123;text-decoration: underline&#125;h4 &#123;text-decoration: blink&#125;a &#123;text-decoration: none&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是标题 1&lt;/h1&gt;&lt;h2&gt;这是标题 2&lt;/h2&gt;&lt;h3&gt;这是标题 3&lt;/h3&gt;&lt;h4&gt;这是标题 4&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn/index.html&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; line-through: 看我overline:看我underline:看我blink:看我 用text-decoration去掉超链接的下划线 这是一个超链接，但是没有下划线，因为我有值为none的text-decoration呀 text-indent将段落的第一行缩进 50 像素：1234css:p&#123; text-indent:50px;&#125; list-style:把图像设置为列表中的列表项目标记：1234css:ul&#123; list-style:square inside url(&apos;/i/arrow.gif&apos;); &#125; 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;ul &#123;list-style: square inside url(&apos;/i/eg_arrow.gif&apos;)&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 可以按顺序设置如下属性： list-style-type list-style-position list-style-imag overflow: 在宽高固定的情况下，内容超出的时候的显示样式123456div &#123; width:150px; height:150px; overflow:scroll; &#125; 默认值： visible可能的值值 描述visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWindow笔记]]></title>
      <url>%2F2017%2F03%2F02%2FUIWindow%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UIWindow更多的时候只作为UIView的顶层容器存在 UIWindow的主要作用有： 作为UIView的最顶层容器，包含应用所需要的所有的UIView 传递触摸消息和键盘事件给UIView 为UIWindow增加UIView 因为其本身是UIView的子类，所以可以调用addSubView方法 通过设置其特有的rootViewController属性。 通过设置其属性添加view对应的UIViewController，UIWindow自动将其view添加到当前window中。同时负责维护ViewController和view的生命周期。 系统对UIWindow的使用 调用系统的控件时(UIAlertView)，iOS系统为了保证UIAlertView在所有的界面之上，它会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置得更高，让UIAlertView盖在所有的应用界面之上 WindowLevel UIWindow的UIWindowLevel属性，定义了UIWindow的层级 UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal; UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert; UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar 通过代码将这些值输出： NSLog(@&quot;UIWindowLevelAlert - %lf ,UIWindowLevelNormal %lf, UIWindowLevelStatusBar %lf&quot;,UIWindowLevelAlert,UIWindowLevelNormal,UIWindowLevelStatusBar); 输出的结果为： UIWindowLevelAlert - 2000.000000 ,UIWindowLevelNormal 0.000000, UIWindowLevelStatusBar 1000.000000 默认的UIWindow层级为UIWindowLevelNormal，当系统需要在其上面覆盖UIAlerView时，创建一个UIWindowLevelAlert层级的UIWindow 手工创建UIWindow 创建UIWindow和UIView不同的是，一旦被创建，它会自动的被添加到界面上。 @interface ViewController () { UIWindow *_uiwindow; } @end - (IBAction)click:(id)sender { _uiwindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; //设置其层级 _uiwindow.windowLevel = UIWindowLevelNormal; _uiwindow.backgroundColor = [UIColor redColor]; _uiwindow.hidden = NO; UIGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] init]; [gesture addTarget:self action:@selector(hideWindow:)]; [_uiwindow addGestureRecognizer:gesture]; } -(void)hideWindow:(UIGestureRecognizer *)gesture{ _uiwindow.hidden = YES; //移除的方式就是清空 _uiwindow = nil; } 作者(唐巧)在做有道云笔记时，想做一个密码保护功能，当用户从应用的任何界面按Home键退出，过一段时间再从后台换回来时，显示一个密码输入界面。这个密码界面可能从任何应用界面弹出，并且需要盖在所有界面的最上层，它很适合用一个UIWindow来实现 #import &lt;UIKit/UIKit.h&gt; @interface PasswordInputWindow : UIWindow -(void)show; +(instancetype)sharedInstance; @end #import &quot;PasswordInputWindow.h&quot; @implementation PasswordInputWindow{ UITextField *_textField; } +(instancetype)sharedInstance{ //更改其生命周期 static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] initWithFrame:[UIScreen mainScreen].bounds]; }); return sharedInstance; } -(instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 50, 200, 20)]; label.text = @&quot;请输入密码&quot;; [self addSubview:label]; UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 80, 200, 20)]; textField.backgroundColor = [UIColor whiteColor]; //密码输入时单个显示 textField.secureTextEntry = YES; [self addSubview:textField]; UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(10, 110, 200, 44)]; [button setBackgroundColor:[UIColor blueColor]]; button.titleLabel.textColor = [UIColor blackColor]; [button setTitle:@&quot;确定&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(completeButtonPressed) forControlEvents:UIControlEventTouchUpInside]; self.backgroundColor = [UIColor yellowColor]; [self addSubview:button]; _textField = textField; } return self; } -(void)show{ //使其成为主窗口，调用这个方法就让当前窗口成为主窗口 [self makeKeyWindow]; self.hidden = NO; } -(void)completeButtonPressed{ if ([_textField.text isEqualToString:@&quot;abcd&quot;]) { //关闭键盘 [_textField resignFirstResponder]; //辞去主窗口 [self resignKeyWindow]; self.hidden = YES; }else{ [self showErrorAlertView]; } } -(void)showErrorAlertView{ UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:@&quot;密码 错误，正确密码是abcd&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil]; [alertView show]; } @end 只需要在应用进入后台的回调函数中，将该UIWindow创建显示出来即可 - (void)applicationDidEnterBackground:(UIApplication *)application { [[PasswordInputWindow sharedInstance] show]; } 需要注意的是，如果我们创建的window需要处理键盘事件，那就需要合理的将其设置为keyWindow.keyWindow是被系统设计用来接收键盘和其他非触摸事件的UIWindow。通过makeKeyWindow和resignKeyWindow来将自己的window设置为keyWindow，以及辞去keyWindow，]]></content>
    </entry>

    
  
  
</search>
