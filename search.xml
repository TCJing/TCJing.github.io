<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[更完善的自定义绘制]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%9B%B4%E5%AE%8C%E5%96%84%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[1.UIKit和视图绘图周期： 如果要改变视图的大小或显示，画一条线，或者改变一个对象的颜色，这些改变不会立刻显示出来。有时，这会让编写如下不恰当代码的开发人员感动迷惑：123456&#123;progressView.hidden = NO; //这一行什么也不做//在这里做一些耗时的操作[self doSometingTimeConsuming];progressView.hidden = YES;&#125; 第一行（progressView.hidden = NO）实际上根本没有作用，理解这一点很重要。这行代码不会使进度视图在执行耗时操作的时候显示出来。无论这个方法运行多久，都不会看到视图显示出来 下图展示了绘图循环中实际会发生的步骤： 所有的绘制都发生在主线程，只要代码运行在主线程，就没有东西可以绘制。在主线程中执行长时间运行操作，会阻碍事件的处理，也会阻碍绘制更新。 如何开始和停止一个长时间运行操作的活动指示器？采用调度或执行队列来将耗时的任务放入后台，同时创建如下在主线程中进行UIKit调用的代码：12345678910111213141516-(IBAction)doSomething:(UIButton *)sender&#123;//避免执行任务期间反复点击[sender setEnabled:NO];[self.activity startAnimation];//把耗时的操作放在后台线程，让当前方法迅速执行完，而不是因为耗时操作而阻塞在这里，而阻碍绘制更新，阻碍触摸事件dispatch_queue_t bgQueue = dispatch_get_global_queue(0, 0);dispatch_async(bgQueue, ^&#123;//耗时操作[self doSomethingTimeConsuming];//回到主线程绘图dispatch_async(dispatch_get_main_queue(), ^&#123;[self.activity endAnimation];[sender setEnabled:YES];&#125;);&#125;);&#125; 2.视图绘制与视图布局 UIView将子视图的布局(重新排列)从绘图(显示)中独立出来。这对极大程度的优化性能很重要，因为布局的成本通常要比绘制低。布局的成本之所以低，是因为UIView的缓存通过GPU优化的位图进行绘图操作。使用GPU，可以使这些位图的移动，显示，隐藏，旋转，甚至变形和合并的成本非常低。 如果对一个视图调用setNeedsDisplay方法，它被标记为“需要刷新的”，并且会在下一次绘图周期中重新绘制。除非视图的内容真的会发生变化，否则请不要调用它。大部分UIKit视图会在其数据发生变化时自动管理重绘操作，因此除了自定义的视图，一般并不需要调用setNeedsDisplay。 旋转设备或滚动视图后，子视图需要重新排列，这时UIKit会调用setNeedsLayout，也就是对于发生变化的视图逐次调用layoutSubViews方法。覆盖layoutSubviews的话，就可以让应用在设备旋转或视图滚动时更加流畅。不必重绘就能重新排列子视图的位置，还可以根据设备方向显示隐藏视图。如果数据改变后只需要进行布局更新(而非绘制)，则可以调用setNeedsLayout方法。 3.自定义视图绘制 视图可以通过子视图、图层或实现drawRect：方法来表现内容。通常来说，如果实现了drawRect：方法，最好就不要再混用图层与子视图了。2D绘图并不能操作单独的像素，因为像素是依赖目标的。可以从位图上下文中读取它，但无法使用UIKit或Core Graphics函数来直接作用于它。 4.理解坐标系 坐标、点、像素之间的微妙转换也可能降低绘制性能，到执行线条和文字模糊。观察以下代码：123456789//绘制一：CGContextSetLineWidth(context,3.);CGContextMoveLineToPoint(context,10.,100.);CGContextAddLineToPoint(context,200.,100.);CGContextStrokePath(context);//绘制二：CGContextMoveToPoint(context,10.,105.5);CGContextAddLineToPoint(context,200.,105.5);CGContextStrokePath(context); 下图展示的是在非视网膜屏幕上的输出结果，当放大的时候可以看见，两条线条之间的区别：可以看到，绘制一的结果就要模糊很多。原因在于iOS对坐标系的解读方式。构造一个CGPath时，便是使用了几何坐标系，这与数学中使用的坐标系是一样的，以两条网格线的交点来表示零坐标点。你无法绘制出真正的几何点或几何线条，因为它们都是无限小和无限细的。iOS绘制中必须将这些几何对象转换成像素坐标。像素是设备能控制的最小显示区域单位。调用CGContextStrokePath，iOS会让线条沿路径居中。理想情况下，线宽有3像素宽，所以y=98.5到y=101.5，如下图所示：在屏幕上，线条看起来有些模糊。解决这个问题的办法就是将水平或垂直的线条移动到半个点的位置，这样当iOS将线条居中时，边缘刚好就是像素的边界。或者让线条更粗一些。使用非整型宽度的线条，或者坐标系不是整型和半整型时(这个问题也使用于retina屏)，也有可能遇到这个问题。让iOS绘制小数像素时就有可能导致模糊。 填充工具与画笔不一样。画笔的线条是中心对齐路径的，而填充颜色是基于路径的。如果填充从{10,100}到{200,103}的矩形，每个像素都会被正确填充，如图目前的讨论视点与像素相同。而对于retina屏幕，也依然会因为线宽或坐标系不是整数导致显示模糊的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用运行时关联对象使用示例]]></title>
      <url>%2F2017%2F03%2F18%2F%E5%88%A9%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[使用场景模拟： 有多个按钮，当点击其中某个按钮的时候，会弹出警告框，当警告框关闭的时候，需要知道是点击了哪一个按钮。这个时候就可以使用关联引用。当点击警告框的时候，会调用代理方法，只有调用了代理方法而非按钮事件处理方法的时候，才表示用户点击了警告框，所以在代理方法中获取按钮才是正确的时候。通过关联引用可以实现这个业务：123456789101112131415161718192021222324252627#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@implementation ViewControllerstatic const char kRepresentedObject;- (IBAction)doSomething:(id)sender &#123;UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;警告⚠️&quot; message:nildelegate:selfcancelButtonTitle:@&quot;OK&quot;otherButtonTitles:nil];objc_setAssociatedObject(alert, &amp;kRepresentedObject, sender,OBJC_ASSOCIATION_RETAIN_NONATOMIC);[alert show];&#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;UIButton *sender = objc_getAssociatedObject(alertView, &amp;kRepresentedObject);self.buttonLabel.text = [[sender titleLabel] text];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Core Data 学习]]></title>
      <url>%2F2017%2F03%2F17%2FCore-Data-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[通过Core Data 和 iCloud的协作实现跨设备的同步数据 Core Data 可以使用SQLite作为其后台数据存储。这为Core Data提供了一个高性能的查询引擎。相比较于平面数据文件或是plist文件进行搜索和排序，Core Data能提供更高的速度。 在任何时间只读取需要的文件， Core Data API能够节省内存。 使用NSPredicat过滤数据，使用NSSortDescriptor排序数据 Core Data 的关键组件是： 数据存储(data store)、 持久存储协调器(Persistent Store Coordinator)、 托管对象模型(Managed Object Model)、托管对象上下文(Managed Object Context) 数据存储： 保存数据的一个或一组文件。它是当保存数据消息发送到Core Data后实际写入到磁盘的文件。数据存储可以是一个二进制数据文件、一个SQLite数据文件或一个内存中的数据文件开发人员不会直接访问数据存储，持久存储协调器抽象了对数据文件的访问。 持久存储协调器：在托管对象上下文和数据存储之间扮演着中间人的角色。协调器从上下文中获得数据请求并将它们转发给合适的数据存储。协调器将数据存储和托管对象模型关联在一起。持久存储协调器是NSPersistentStoreCoordinator类的实例* NSPersistentStoreCoordinator类不是线程安全的，因此，如果计划跨多线程同步访问一个数据存储，则需要为每个线程创建一个协调器或手动锁定和解锁单个协调器 托管对象模型： NSManagedObjectModel。 模型由一组实体组成，它们定义了应用程序中的数据对象。 托管对象上下文: NSManagedObjectContext. 上下文用于保存所有托管数据对象。托管数据对象是NSManagedObject类的实例或子类。托管对象上下文管理所有的托管对象。可以将该上下文想象成保存所有应用程序数据的沙箱。 Core Data 可以将SQLite用作磁盘上的数据存储以持久化我们的数据。还可以使用一个专有的二进制文件作为数据存储。相对于使用SQLite格式时按需加载部分对象图，二进制格式需要将整个对象图加载到内存中。 iCloud提供三种类型的存储方案： 键-值存储、文档存储、Core Data存储。键-值存储用于存储独立的键-值对，可用于存储少量的数据，如用户首选项、游戏分数和应用程序设置。文档存储用于存储基于文档的内容，如电子表格、文本文档和绘图文件。Core Data存储允许跨多个设备同步Core Data 应用程序。 苹果提供了一个数据保护API用于安全地加密应用程序数据。通常当需要保护数据文件时可通过使用NSFileManager对象的setAttributes：ofItemAtPath:error:方法设置文件的一个特性来进行配置。该API允许将文件保护键设置为不同的值，从而提供一些关于被保护的数据何时处于加密或解密状态的选项。 NSFileProtectinNone: 文件没有加密。应用程序可以在任何时候读写此文件 NSFileProtetionComplete: 在设备锁定或启动时文件处于加密状态。 NSFileProtetionCompleteUnlessOpen: 文件在随着设备的解锁而打开前是加密的，一旦文件打开，应用程序可以在任何时候读写该文件，设置是在设备锁定的时候 NSFileProtetionCompleteUntilFirstUserAuthentication: 文件在设备启动时是加密的，并且一直保持锁定直到用户第一次解锁设备。在用户第一次解锁设备后，应用程序可以读写该文件。 当在Core Data中使用SQLite数据存储时，数据存储在设备上的SQLite数据库中。该数据存储的默认文件保护是NSFileProtectionCompleteUntilFirstUserAuthentication。然而，通过修改在App Delegate中创建数据库文件的代码在首次创建数据存储时可以指定数据保护级别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQLite学习]]></title>
      <url>%2F2017%2F03%2F15%2FSQLite%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[1.CoreData 主要目的是持久化应用程序创建的对象。当预先加载具有大量数据的应用程序时，SQLite的表现更突出，而CoreData擅长管理在设备上创建的数据2.SQLite的大小小于300KB.在使用上，只需要将数据库文件拖放到设备上，然后在iOS项目中包含SQLite库，就完成了准备工作3.如果只需要持久化应用程序使用期间创建的对象，则应该考虑使用Core Data。4.用户界面和数据应该是完全解耦的，并且应该独立的规范化数据。 实体（表） -&gt; 实体的特性(字段)6.使用命令行的优点： 可以使用命令行和脚本接口创建和填充数据库。使用命令行接口导入文件数据到表中，执行和读取包含SQL的文件，以各种格式输出数据库中的数据7.通过在命令行提示符后输入sqlite3 catalog.db，启动命令行工具并创建新的数据库。执行ATTACH DATABASE命令或者附加现有数据库到SQLite工具，或者在制定文件不存在时创建新的数据库。8.可以附加多个数据库到一个命令行工具实例并以数据库名称.表名称的格式使用点符号在每个数据库中引用数据。可以使用这个强大的特性将数据从一个数据库迁移到另一个数据库9.在命令行中输入.help可以显示这些元命令。输入.databases可以看到哪些数据库附加到当前的工具实例。输入.exit或.quit可以退出命令行工具10.在SQLite命令提示符处输入CREATE TABLE语句：1CREATE TABLE &quot;main&quot;.&quot;Product&quot;(&quot;ID&quot; INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, &quot;Name&quot; TEXT, &quot;Manu&quot; INTEGER, &quot;Details&quot; TEXT, &quot;Price&quot; DOUBLE); 创建名为Product的表将ID字段制定为主键并且将其制定为一个AUTOINCREMENT（自动增长）字段。这意味着你不需要提供ID值，数据库引擎将自动产生它们。 11.外键约束允许数据库验证子表中用作外键的值被映射到了存储在父表中的值。12.可以使用下列INSERT语句插入一列到Product表中12INSERT INTO &quot;main&quot;.&quot;Product&quot; (&quot;Name&quot;,&quot;ManufacturerID&quot;,&quot;DETAILS&quot;,&quot;Price&quot;,&quot;QuantityOnHand&quot;,&quot;CountryOfOriginID&quot;,&quot;Image&quot;) VALUES (&apos;WIDGET A&apos;,&apos;1&apos;,&apos;Details of Widget A&apos;,&apos;1.29&apos;,&apos;5&apos;,&apos;1&apos;,&apos;Canvas_1&apos;);sqlite&gt; 13.使用命令行工具可以把文本文件导入到数据库。当从另外一个数据库转存数据时就会被派上用场，另外的那个数据库可以是微软电子表格，或只是一个文本文件。可以为每一个数据库表创建一个文本文件并使用导入功能将数据导入到数据库。14.输入命令.separator “\t”,制定使用制表符\t作为数据文件中字段的分隔符。15.输入.import “products.txt” Product 导入products.txt文件到Product表中16.查询表中的所有内容：1select * from Product; 17.按顺序显示查询：1select name,price from Product order by price; 18.连接表的显示：1select name,country from Product,Country where Product.CountryOfOriginID=Country.CountryID; 19.使用WHERE子句过滤数据：1select name,country from Product,Country where Product.CountryOfOriginID=Country.CountryID and Country.Country=&quot;China&quot;; 20.抽象对数据库的访问是一个好主意，编写一个通用类来执行常用数据库功能。如果想要以后使用不同的数据库引擎，这样做能够提供灵活性。创建一个数据库访问类来和数据库交互。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 使用]]></title>
      <url>%2F2017%2F03%2F14%2FGit-%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[创建版本库版本库又名仓库，英文名repository.你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：12$ mkdir learngit$ cd learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库：1$ git init 现在我们编写一个readme.txt文件，内容如下：12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行)把一个文件放在Git仓库只需要两步:第一步，用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库：12345$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) adedc1b] worte a readme fone1 file changed, 2 insertions(+)create mode 100644 readme.txt git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 时光机穿梭我们已经成功地添加并提交了一个readme.txt文件，现在修改readme.txt文件，改成如下内容：12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果：1$ git status git status命令可以让我们时刻掌握仓库当前的状态虽然Git告诉我们readme.txt被修改了,但是无法看到具体的修改内容,使用git diff来查看1$ git diff 提交修改和提交新文件是一样的两步，第一步是git add：1$ git add readme.txt 在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：1$ git status 提交:1$ git commit -m &quot;add distributed&quot; 版本回退修改readme.txt文件如下：12Git is a distributed version control system.Git is free software distributed under the GPL. 然后提交:12$ git add readme.txt$ git commit -m &quot;append GPL&quot; 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：版本1：wrote a readme file12Git is a version control system.Git is free software. 版本2：add distributed12Git is a distributed version control system.Git is free software. 版本3：append GPL12Git is a distributed version control system.Git is free software distributed under the GPL. 版本控制系统用git log命令查看记录：12345678910111213141516171819$ git logcommit db2a1634505edec7c64ec489729ce25b35d2973bAuthor: Date: Tue Mar 14 21:25:09 2017 +0800append GPLcommit 83a96591227393b5f362df2daed351307b7e87d1Author: Date: Tue Mar 14 21:24:06 2017 +0800add distributedcommit adedc1b15172e80ce54f5997889536b71e89f64dAuthor: Date: Tue Mar 14 20:52:43 2017 +0800worte a readme fone git log命令显示从最近到最远的提交日志如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：12345$ git log --pretty=onelinedb2a1634505edec7c64ec489729ce25b35d2973b append GPL83a96591227393b5f362df2daed351307b7e87d1 add distributedadedc1b15172e80ce54f5997889536b71e89f64d worte a readme fone 准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交的，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：1$ git reset --hard HEAD^ 看看readme.txt的内容是不是版本add distributed：123$ cat readme.txtGit is a distributed version control system.Git is free software OK!这个时候git log一下,123git log --pretty=oneline83a96591227393b5f362df2daed351307b7e87d1 add distributedadedc1b15172e80ce54f5997889536b71e89f64d worte a readme fone 最新的那个版本append GPL已经看不到了，找到那个append GPL的commit id，于是就可以指定回到未来的某个版本：12$ git reset --hard 3628164HEAD is now at db2a1634 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。现在看一下readme.txt的内容123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：改为指向add distributed:然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：1234567$ git reflog83a9659 HEAD@&#123;0&#125;: reset: moving to 83a96591227393bdb2a163 HEAD@&#123;1&#125;: reset: moving to db2a163483a9659 HEAD@&#123;2&#125;: reset: moving to HEAD^db2a163 HEAD@&#123;3&#125;: commit: append GPL83a9659 HEAD@&#123;4&#125;: commit: add distributedadedc1b HEAD@&#123;5&#125;: commit (initial): worte a readme fone 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。工作区和暂存区工作区:就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区：版本库:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库.Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。先用git status查看一下状态：123456789101112131415$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtUntracked files:(use &quot;git add file...&quot; to include in what will be committed)LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：1234567$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)new file: LICENSEmodified: readme.txt 现在，暂存区的状态就变成这样了：所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。12345$ git commit -m &quot;understand how stage works&quot;[master cf3e3ef] understand how stage works2 files changed, 2 insertions(+)create mode 100644 LICENSE 现在版本库变成了这样，暂存区就没有任何内容了： 管理修改为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加：1234567$ git add readme.txt$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)modified: readme.txt 然后，再修改readme.txt：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交：123$ git commit -m &quot;git tracks changes&quot;[master 208dcc4] git tracks changes1 file changed, 1 insertion(+) 提交后，再看看状态：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：123456789101112$ git diff HEAD -- readme.txtdiff --git a/readme.txt b/readme.txtindex db28b2c..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.-Git tracks changes.\ No newline at end of file+Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：1$ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。现在，看看readme.txt的文件内容：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：123456$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)modified: readme.txt Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 还记得如何丢弃工作区的修改吗？1234$ git checkout -- readme.txtjingtingchaodeMacBook-Pro:learngit jingtingchao$ git statusOn branch masternothing to commit, working tree clean 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：12345$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master 94cdc44] add test.txt1 file changed, 1 insertion(+)create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：1$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add/rm file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：123456$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d17efd8] remove test.txt1 file changed, 1 deletion(-)delete mode 100644 test.txt 现在，文件就从版本库中被删除了。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：1$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上：12345678910$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 8 threads.Compressing objects: 100% (13/13), done.Writing objects: 100% (19/19), 1.54 KiB | 0 bytes/s, done.Total 19 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), done.To https://github.com/TCJing/learngit.git* [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：从现在起，只要本地作了提交，就可以通过命令：1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：12345$ git clone https://github.com/TCJing/gitskills.gitCloning into &apos;gitskills&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done. 分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支.截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支.HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：真是太神奇了，你看得出来有些提交是通过分支完成的吗？下面开始实战。首先，我们创建dev分支，然后切换到dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支：123$ git branch* devmaster git branch命令会列出所有分支，当前分支前面会标一个*号。然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：1Creating a new branch is quick. 然后提交：1234$ git add readme.txt$ git commit -m &quot;branch test&quot;[dev fec145a] branch test1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支：12$ git checkout masterSwitched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：现在，我们把dev分支的工作成果合并到master分支上：12345$ git merge devUpdating 14402cd..ddd16d5Fast-forwardREADME.md | 3 ++-1 file changed, 2 insertions(+), 1 deletion(-) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，就可以放心地删除dev分支了：12$ git branch -d devDeleted branch dev (was ddd16d5). 删除后，查看branch，就只剩下master分支了：12$ git branch* master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。小结Git鼓励大量使用分支：查看分支：git branch 创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout -b name合并某分支到当前分支：git merge name删除分支：git branch -d name 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。准备新的feature1分支，继续我们的新分支开发：12$ git checkout -b feature1Switched to a new branch &apos;feature1&apos; 修改readme.txt最后一行，改为：1Creating a new branch is quick AND simple. 在feature1分支上提交：1234$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;AND simple&quot;[feature1 f9128e8] AND simple1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支：1234$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 1 commit.(use &quot;git push&quot; to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。在master分支上把readme.txt文件的最后一行改为：1Creating a new branch is quick &amp; simple. 提交:12345$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$jingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;&amp; simple&quot;[master 20986f2] &amp; simple1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样：这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：1234567891011121314$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits.(use &quot;git push&quot; to publish your local commits)You have unmerged paths.(fix conflicts and run &quot;git commit&quot;)(use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:(use &quot;git add file...&quot; to mark resolution)both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容：1234567$ cat README.md# gitskills&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：1Creating a new branch is quick and simple. 再提交:123$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;conflict fixed&quot;[master 7e86ad6] conflict fixed 现在，master分支和feature1分支变成了下图所示：用带参数的git log也可以看到分支的合并情况：12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 最后，删除feature1分支：12$ git branch -d feature1Deleted branch feature1 (was f9128e8). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; 修改readme.txt文件，并提交一个新的commit：1234$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;add merge&quot;[dev 0a5e364] add merge1 file changed, 1 insertion(+), 1 deletion(-) 现在，我们切换回master：12$ git checkout masterSwitched to branch &apos;master&apos; 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy.readme.txt | 1 +1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史：1234567$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：小结Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：12345678910111213$ git status# On branch dev# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add file...&quot; to update what will be committed)# (use &quot;git checkout -- file...&quot; to discard changes in working directory)## modified: readme.txt# 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos; 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：1234$ git add readme.txt$ git commit -m &quot;fix bug 101&quot;[issue-101 cc17032] fix bug 1011 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：123456789$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy.readme.txt | 2 +-1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！12345$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：1234567891011121314$ git stash pop# On branch dev# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add file...&quot; to update what will be committed)# (use &quot;git checkout -- file...&quot; to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了：1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。于是准备开发：12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 5分钟后，开发完毕：123456789101112$ git add vulcan.py$ git status# On branch feature-vulcan# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: vulcan.py#$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 756d4af] add feature vulcan1 file changed, 2 insertions(+)create mode 100644 vulcan.py 切回dev，准备合并：1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁：123$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。现在我们强行删除：12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 756d4af). 终于删除成功！小结开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D name强行删除。 误删分支恢复方法首先用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复。1.创建分支 abc1$ git branch myDev 2.切换到abc分支，随便修改一下东西后 commit123456789101112$ git checkout myDevSwitched to branch &apos;myDev&apos;$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;修改README.md&quot;[myDev 38e7342] 修改README.md1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 30 commits.(use &quot;git push&quot; to publish your local commits) 3.删除分支abc12$ git branch -D myDevDeleted branch myDev (was 38e7342). 4.查看分支列表，abc分支已不存在123$ git branchdev* master 5.使用git log -g 找回之前提交的commit123456789$ git log -g//这里就是commit_idcommit 38e7342e7ec64624e1c2ea69c228ace103ddea10Reflog: HEAD@&#123;1&#125; (xx@163.com)Reflog message: commit: 修改README.mdAuthor: jtc xx@163.comDate: Wed Mar 15 19:47:41 2017 +0800修改README.md 6.使用git branch [新分支] commit_id命令用这个commit创建一个分支12345678$ git branch myDev 38e7342e7ec646//查看分支$ git branchdev* mastermyDev$ git checkout myDevSwitched to branch &apos;recover_branch_myDev&apos; over! 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote：12$ git remoteorigin 或者，用git remote -v显示更详细的信息：123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1$ git push origin master 如果要推送其他分支，比如dev，就改成：1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：1234567891011$ git commit -m &quot;add /usr/bin/env&quot;[dev 291bea8] add /usr/bin/env1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.gitfc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：123456789101112$ git add hello.py$ git commit -m &quot;add coding: utf-8&quot;[dev bd6ae48] add coding: utf-81 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)hint: before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngitfc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for detailsgit pull remote branchIf you wish to set tracking information for this branch you can do so with:git branch --set-upstream dev origin/branch git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：12$ git branch --set-upstream-to=origin/dev devBranch dev set up to track remote branch dev from origin. 再pull：1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：12345678910$ git commit -m &quot;merge &amp; fix hello.py&quot;[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样：1.首先，可以试图用git push origin branch-name推送自己的修改；2.如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3.如果合并有冲突，则解决冲突，并在本地提交；4.没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to=origin/branch-name branch-name这就是多人协作的工作模式，一旦熟悉了，就非常简单。小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream-to=origin/branch-name branch-name 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？“请把上周一的那个版本打包发布，commit号是6a5819e…”“一串乱七八糟的数字不好找！”如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”“好的，按照tag v1.2查找commit就行！”所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上：12345$ git branch* devmaster$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag name就可以打一个新标签：1$ git tag v1.0 可以用命令git tag查看所有标签：12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了：1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：1$ git tag v0.9 6224937 再用命令git tag查看标签：123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show tagname查看标签信息：1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author:Date: Thu Aug 22 11:22:08 2013 +0800add merge... 可以看到，v0.9确实打在add merge这次提交上。还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用命令git show tagname可以看到说明文字：123456789101112$ git show v0.1tag v0.1Tagger:Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author:Date: Tue Aug 20 15:11:49 2013 +0800append GPL 操作标签如果标签打错了，也可以删除：12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin tagname：1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git* [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签：1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 554 bytes, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git* [new tag] v0.2 -&gt; v0.2* [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下：123$ git push origin :refs/tags/v0.9To git@github.com:michaelliao/learngit.git- [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin tagname可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d tagname可以删除一个本地标签； 命令git push origin :refs/tags/tagname可以删除一个远程标签。 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView+FDTemplateLayoutCell理解笔记]]></title>
      <url>%2F2017%2F03%2F14%2FUITableView-FDTemplateLayoutCell%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UITableView+FDTemplateLayoutCell Demo部分： storyboard部分：①：这里是通过storyboard来添加tableHeadView。 添加的方式就是直接通过在cell的上面直接拖入一个UIView，这个UIView就可以作为tableHeadView。然后可以在这个tableHeadView中添加一个控件和约束。②： 这里是自定义了一个动态cell。 在添加约束的时候，需要注意的是：这里的图片是无法确定高度的，这里约束了图片的宽度&lt;=某个值，保证图片不会超过屏幕，图片的高度根据图片的宽度来确定。所以，在做约束的时候，不能将Username Label的垂直位置相对于图片来设置，username Label的底部相对于contentView来设置，UIImageView的底部相对于username Label来设置。③： 在storyboard当中添加了一个refresh control，通过storyboard来添加refresh control的方式为： 监听refresh control的事件的方式是通过对value change的监听;通过拖线的方式添加事件处理： 我们只需要在请求到数据后调用refresh control的endRefreshing方法并且刷新表格 代码部分：1.枚举的使用：12345typedef NS_ENUM(NSInteger, FDSimulatedCacheMode) &#123;FDSimulatedCacheModeNone = 0,FDSimulatedCacheModeCacheByIndexPath,FDSimulatedCacheModeCacheByKey&#125;; 这里将UISegment Control的index与枚举建立关联：直接将index值赋值给枚举变量。这样的好处是： 1.免去了if else的判断。2.相比较if(0) else if(1)这样的代码if(FDSimulatedCacheModeNone) else if (FDSimulatedCacheModeCacheByIndexPath)..具有更高的可读性 2.开启打印：1self.tableView.fd_debugLogEnabled = YES; 3.block的使用：1234567891011121314151617181920212223242526272829303132333435363738//这里的代码内容主要包括了1.将json转为模型数组，将模型数组作为元素添加到可变数组当中- (void)viewDidLoad &#123;[super viewDidLoad];//这里采用block回调的方式的好处是： 对代码进行了封装，因为这里两个数组之间本身就存在依赖关系，feedEntitySections依赖于prototypeEntitiesFromJSON，所以通过block的方式，避免被调换顺序，而导致错误。block回调就完成了封装。通过当模型数组创建完毕的时候回调的方式来创建feedEntitySections数组[self buildTestDataThen:^&#123;self.feedEntitySections = @[].mutableCopy;[self.feedEntitySections addObject:self.prototypeEntitiesFromJSON.mutableCopy];[self.tableView reloadData];&#125;];&#125;//这里加载文件数据以及json转模型，放在了子线程来执行，避免对主线程可能造成的卡顿和不流畅//相对于使用for in使用enumerateObjectsUsingBlock，效率更高//最后需要回到主线程调用block，而非在子线程直接调用- (void)buildTestDataThen:(void (^)(void))then &#123;// Simulate an async requestdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// Data from `data.json`NSString *dataFilePath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;json&quot;];NSData *data = [NSData dataWithContentsOfFile:dataFilePath];NSDictionary *rootDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil];NSArray *feedDicts = rootDict[@&quot;feed&quot;];// Convert to `FDFeedEntity`NSMutableArray *entities = @[].mutableCopy;[feedDicts enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;[entities addObject:[[FDFeedEntity alloc] initWithDictionary:obj]];&#125;];self.prototypeEntitiesFromJSON = entities;// Callbackdispatch_async(dispatch_get_main_queue(), ^&#123;!then ?: then();&#125;);&#125;);&#125; IMP12345678910111213//根据buttonIndex来调用不同的方法。通过对IMP的使用，免去了if else的使用。- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123;SEL selectors[] = &#123;@selector(insertRow),@selector(insertSection),@selector(deleteSection)&#125;;if (buttonIndex &lt; sizeof(selectors) / sizeof(SEL)) &#123;void(*imp)(id, SEL) = (typeof(imp))[self methodForSelector:selectors[buttonIndex]];imp(self, selectors[buttonIndex]);&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runloop]]></title>
      <url>%2F2017%2F03%2F13%2Frunloop%2F</url>
      <content type="text"><![CDATA[利用RunLoop空闲时间执行任务 空闲RunLoopMode: 当用户正在滑动 UIScrollView 时，RunLoop 将切换到 UITrackingRunLoopMode,接受滑动手势和处理滑动事件（包括减速和弹簧效果）,此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。 当 UI 没在滑动时，默认的 Mode 是 NSDefaultRunLoopMode（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。 用RunLoopObserver找准时机: 注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：1.RunLoop开始2.RunLoop即将处理Timer3.RunLoop即将处理Source4.RunLoop即将进入休眠状态5.RunLoop即将从休眠状态被事件唤醒6.RunLoop退出 空闲时间执行任何应当满足：RunLoop 处于“空闲”状态 Mode当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时1234567CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;// TODO here&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode); 在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer 分解成多个RunLoop Source任务： 假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们分别分解到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务） Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API： 12345- (void)performSelector:(SEL)aSelectoronThread:(NSThread *)thrwithObject:(id)argwaitUntilDone:(BOOL)waitmodes:(NSArray *)array; 这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件 1234567891011121314151617181920static int i = 100000;- (void)viewDidLoad &#123;//获得当前的runloopCFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;//创建一个observer监听这个状态kCFRunLoopBeforeWaitingCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;if (i == 0) &#123;CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);CFRelease(observer);return ;&#125;i = i - 1;[self performSelector:@selector(downLoad) onThread:[NSThread mainThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode);&#125;-(void)downLoad&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS小技巧积累]]></title>
      <url>%2F2017%2F03%2F12%2FiOS%E5%B0%8F%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF%2F</url>
      <content type="text"><![CDATA[1.禁止第三方键盘在要填密码的地方， 为了安全考虑！要么禁用第三方键盘，要么自定义键盘！1234//禁止第三方键盘的使用- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(NSString *)extensionPointIdentifier&#123;return NO;&#125; 2.禁止系统的面板手机默认的输入框右键或者选中文字右键会弹出菜单，但是有时候我们在做对文本严格要求的时候 (比如说不能使文字啊)，就要关闭这个功能， 只需要在自定义的UITextfield或UITextview里面添加下面这一句话：123-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123;return NO;&#125; 3.点击部分文字响应有时候你需要在一行文本中点击某几个特殊的文字，来实现跳转网页或者打电话的功能。比如点击电话号码，拨打电话：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &quot;TCTextView.h&quot;@implementation TCTextView- (instancetype)initWithCoder:(NSCoder *)coder&#123;self = [super initWithCoder:coder];if (self) &#123;&#125;return self;&#125;- (void)setText:(NSString *)text&#123;[super setText:text];//目标文字是你已知的文字，或者取服务器字段知道的NSRange range = [self.text rangeOfString:@&quot;110&quot;];//text -&gt; attributedStringNSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc]initWithString:text];NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc]init];//[paragraphStyle setLineSpacing:10];// 行间距[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, text.length)];//改变电话号码的背景色[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:range];// 下划线[attributedString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:range];[attributedString addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;HelveticaNeue-Light&quot; size:16] range:NSMakeRange(0, text.length)];self.attributedText = attributedString;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;NSSet *allTouches = [event allTouches]; //返回与当前接收者有关的所有的触摸对象UITouch *touch = [allTouches anyObject]; //视图中的所有对象CGPoint point = [touch locationInView:[touch view]];NSRange range = [self.text rangeOfString:@&quot;110&quot;];// self.selectedRange = range;// 不能设置是因为 selectedable[self setSelectedRange:range];//The current selection range of the receiver.NSArray * arr = [self selectionRectsForRange:self.selectedTextRange];//取消选中状态self.selectedRange = NSMakeRange(0, 0);for(UITextSelectionRect * textrect in arr)&#123;if(CGRectContainsPoint(textrect.rect, point))&#123;// 这里就是响应的地方NSLog(@&quot;是我&quot;);&#125;&#125;&#125;@end 4、获取网络图片的尺寸 1234567891011121314151617181920212223242526NSArray * urlArr = @[@&quot;http://upload-images.jianshu.io/upload_images/31282-390513513494ede8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/1931381-12109e9d6666bb0e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/3375207-6adc6a22441681ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/3375207-6adc6a22441681ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/1336788-2ac84707ce22e970.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;];dispatch_group_t grounp = dispatch_group_create();for(NSString * str in urlArr)&#123;// 将当前的下载操作添加到组中dispatch_group_enter(grounp);// 缓存图片[[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:str] options:SDWebImageDownloaderUseNSURLCache progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;&#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;// 把缓存到本地的img添加到数据， 也可以通过image.size取到宽高比例[_arr addObject:image];//完成单张图片下载离开当前组dispatch_group_leave(grounp);&#125;];&#125;dispatch_group_notify(grounp, dispatch_get_main_queue(), ^&#123;// 来到这里所有图片都下载完成// 更新UI, 就好了&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读JZTableViewRowAction理解笔记]]></title>
      <url>%2F2017%2F03%2F12%2F%E8%AF%BBJZTableViewRowAction%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[要点： 1.需要获得系统提供的cell侧滑功能，我们需要实现:1- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath 或者实现：1- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath 当两者都没有实现的时候，就不能获得系统提供的侧滑功能 效果图： 侧滑删除是iOS非常容易实现的一个效果，只需要为你的UITableViewDataSource重新这个方法，系统就会自动添加这种操作： 123//只要实现了这个方法，就能够获得系统提供的侧滑删除功能，当点击删除按钮的时候，就会回调这个方法，可以在这个方法当中完成删除cell以及在模型当中删除对应行的数据完成刷新tableView//- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath 从iOS8开始，苹果开放了这样一个API：1- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath 方法分析： 这个方法的返回值类型为：nullable NSArray *，也就是一个模型数组，只要我们实现了这个方法，并且提供了这个模型数组，系统就会自动的根据数组中模型的个数以及内容完成对应个数的侧滑按钮的创建，不需要我们来创建按钮，只要我们提供了模型就OK。通过这个方法，就能够提供更多的按钮与用户交互。效果图： 所以，对于iOS8以上的系统来说，获得这样的拥有单个或多个的侧滑按钮的侧滑功能是非常容易的。这篇文章的主要内容就是对iOS8以下的系统提供这样的一个侧滑功能。 在数据源当中1234567891011121314151617181920212223242526272829303132//需要主要的是，当我们需要多按钮侧滑功能时，并且需要适配到iOS7或更低版本，那么就一定要实现这个方法。//因为： 在iOS8及以上版本，当我们实现了tableView:editActionsForRowAtIndexPath:，(tableView:commitEditingStyle:forRowAtIndexPath:)实现了也不会调用，所以不实现也没有什么影响。但是，iOS7没有tableView:editActionsForRowAtIndexPath:,如果不实现(tableView:commitEditingStyle:forRowAtIndexPath:),那么就不会有侧滑的功能。所以实现了这个方法保证了iOS7版本下开启侧滑功能- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123;// [self setEditing:NO animated:true];&#125;//这个方法返回的类型是NSString类型，返回的是删除按钮的显示文字，在只有一个删除按钮的时候，可以实现这个方法来自定义删除按钮的内容显示。这里实现的多按钮的侧滑，所以，不需要实现这个功能//-(NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath&#123;//return @&quot;abc&quot;;//&#125;//这个方法的返回值是模型，提供这个模型数组，就能够根据模型内容完成按钮的创建。这个方法出现在iOS8。在这里，我们让更低版本也调用这个方法，实现了版本的适配的同时，也简化了版本的适配，这样在使用的时候，就像是它本身就不存在适配问题一样。其实这里我们将适配问题在其他文件当中进行了实现//需要注意的是这个方法是iOS8才有的方法，而且UITableViewRowAction这个类也是iOS8才有的。现在，我们在像iOS7这样的更低的系统上使用这个UITableViewRowAction，那么，它就一定是我们运用runtime来动态添加的一个类。当我们使用objc_getClass(&quot;UITableViewRowAction&quot;)能够获得这个类的时候，就表示它有，那就不需要做任何事情，如果没有获取到这个类，就需要来动态创建这个类。。。。。- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath &#123;void(^rowActionHandler)(UITableViewRowAction *, NSIndexPath *) = ^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123;NSLog(@&quot;%@&quot;, action);[self setEditing:false animated:true];&#125;;//创建Disclosure类型的button//通过这个按钮能够获得按钮当中的图片UIButton *buttonForImage = [UIButton buttonWithType:UIButtonTypeDetailDisclosure];//这里调用的方法是UITableViewRowAction分类当中提供的方法，增加了一个传入图片的功能UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault image:[buttonForImage imageForState:UIControlStateNormal] handler:rowActionHandler];UITableViewRowAction *action2 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;disenable&quot; handler:rowActionHandler];//并且把第二个按钮的enabled设置为falseaction2.enabled = false;UITableViewRowAction *action3 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;emjoy👍&quot; handler:rowActionHandler];return @[action1,action2,action3];&#125; 现在来看看UITableViewRowAction分类：123456789101112131415161718192021222324252627282930313233//这个类是一个模型类，就是来提供数据的，所以无论是提供的方法还是属性，都只是为了数据的录入和输出。#import &quot;UITableViewRowAction+JZExtension.h&quot;#import &lt;objc/runtime.h&gt;@implementation UITableViewRowAction (JZExtension)//这里新添加了一个创建方法 这个方法帮助我们在原来的只能够在按钮上显示文字的基础上，还能够显示图片 + (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(UIImage *)image handler:(void (^)(UITableViewRowAction * _Nullable, NSIndexPath * _Nullable))handler &#123;//首先调用这个基本构造方法UITableViewRowAction *rowAction = [self rowActionWithStyle:style title:@&quot;holder&quot; handler:handler];//因为这个一个模型对象，所以这里只需要将这个图片存储起来，因为在分类当中无法提供属性，所以采用运行时关联对象的方式保留图片rowAction.image = image;return rowAction;&#125;- (void)setImage:(UIImage *)image &#123;objc_setAssociatedObject(self, @selector(image), image, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (void)setEnabled:(BOOL)enabled &#123;objc_setAssociatedObject(self, @selector(enabled), @(enabled), OBJC_ASSOCIATION_ASSIGN);&#125;- (UIImage *)image &#123;return objc_getAssociatedObject(self, _cmd);&#125;- (BOOL)enabled &#123;id enabled = objc_getAssociatedObject(self, _cmd);//如果没有设置enabled的值，就提供一个默认值：truereturn enabled ? [enabled boolValue] : true;&#125;@end 现在来看看UITableViewRowAction.m 文件：这个文件就是给iOS8以下的系统来使用的。因为iOS8以下的系统没有这样的一个类，于是我们动态来创建这个类。如何更容易的来创建一个跟系统提供的UITableViewRowAction差不多的类呢？注册一个名字相同的类，让这个类继承我们的JZTableViewRowAction，JZTableViewRowAction类当中的属性方法都是直接copy于系统的UITableViewRowAction类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UITableView.h&gt;#import &lt;objc/runtime.h&gt;@interface JZTableViewRowAction : NSObject&lt;NSCopying&gt;&#123;UITableViewRowActionStyle _style;&#125;@property (nonatomic, readonly) UITableViewRowActionStyle style;@property (nonatomic, copy, nullable) NSString *title;@property (nonatomic, copy, nullable) UIColor *backgroundColor; // default background color is dependent on style@property (nonatomic, copy, nullable) UIVisualEffect* backgroundEffect;@property (nonatomic, copy, nullable) void (^handler)(UITableViewRowAction *, NSIndexPath *);@property (nonatomic, strong, nullable) UIImage *image;@property (nonatomic, strong, nonnull) NSIndexPath *indexPath;@property (nonatomic, assign) BOOL enabled;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(nullable NSString *)title handler:(void (^)(UITableViewRowAction *action, NSIndexPath *indexPath))handler;+ (nonnull instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(nullable UIImage *)image handler:(nullable void (^)(UITableViewRowAction * _Nullable action, NSIndexPath * _Nullable indexPath))handler;@end@implementation JZTableViewRowAction+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(NSString *)title handler:(void (^)(UITableViewRowAction *, NSIndexPath *))handler &#123;JZTableViewRowAction *rowAction = [[JZTableViewRowAction alloc] init];rowAction.title = title;rowAction.handler = handler;rowAction-&gt;_style = style;rowAction.enabled = true;return rowAction;&#125;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(UIImage *)image handler:(void (^)(UITableViewRowAction * _Nullable, NSIndexPath * _Nullable))handler &#123;JZTableViewRowAction *rowAction = [self rowActionWithStyle:style title:@&quot;holder&quot; handler:handler];rowAction.image = image;return rowAction;&#125;- (id)copyWithZone:(NSZone *)zone &#123;return [self copy];&#125;//事件触发的时候- (void)actionTriggered:(id)sender &#123;!self.handler ?: self.handler((__kindof UITableViewRowAction *)self, self.indexPath);&#125;@end/*** 动态创建一个类UITableViewRowAction*/__asm(&quot;.section __DATA,__objc_classrefs,regular,no_dead_strip\n&quot;#if TARGET_RT_64_BIT&quot;.align 3\n&quot;&quot;L_OBJC_CLASS_UITableViewRowAction:\n&quot;&quot;.quad _OBJC_CLASS_$_UITableViewRowAction\n&quot;#else&quot;.align 2\n&quot;&quot;_OBJC_CLASS_UITableViewRowAction:\n&quot;&quot;.long _OBJC_CLASS_$_UITableViewRowAction\n&quot;#endif&quot;.weak_reference _OBJC_CLASS_$_UITableViewRowAction\n&quot;);__attribute__((constructor)) static void JZTableViewRowActionPatchEntry(void) &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;@autoreleasepool &#123;if (objc_getClass(&quot;UITableViewRowAction&quot;)) &#123;return;&#125;Class *tableViewRowActionClassLocation = NULL;#if TARGET_CPU_ARM__asm(&quot;movw %0, :lower16:(_OBJC_CLASS_UITableViewRowAction-(LPC0+4))\n&quot;&quot;movt %0, :upper16:(_OBJC_CLASS_UITableViewRowAction-(LPC0+4))\n&quot;&quot;LPC0: add %0, pc&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_ARM64__asm(&quot;adrp %0, L_OBJC_CLASS_UITableViewRowAction@PAGE\n&quot;&quot;add %0, %0, L_OBJC_CLASS_UITableViewRowAction@PAGEOFF&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_X86_64__asm(&quot;leaq L_OBJC_CLASS_UITableViewRowAction(%%rip), %0&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_X86void *pc = NULL;__asm(&quot;calll L0\n&quot;&quot;L0: popl %0\n&quot;&quot;leal _OBJC_CLASS_UITableViewRowAction-L0(%0), %1&quot; : &quot;=r&quot;(pc), &quot;=r&quot;(tableViewRowActionClassLocation));#else#error Unsupported CPU#endifif (tableViewRowActionClassLocation &amp;&amp; !*tableViewRowActionClassLocation) &#123;Class class = objc_allocateClassPair(JZTableViewRowAction.class, &quot;UITableViewRowAction&quot;, 0);if (class) &#123;objc_registerClassPair(class);*tableViewRowActionClassLocation = class;&#125;&#125;&#125;&#125;);&#125; 在来看看UITableViewCell+JZExtension.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#import &lt;UIKit/UIKit.h&gt;#import &lt;objc/runtime.h&gt;#import &quot;UITableViewRowAction+JZExtension.h&quot;@implementation UITableViewCell (JZExtension)+ (void)load &#123;[super load];static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;//交换了willTransitionToState：和 __willTransitionToState的方法实现//willTransitionToState:当用户在某一行刚开始进行侧滑并且侧滑的Button还没有展现出来时调用//与之对应的还有一个方法：- (void)didTransitionToState:(UITableViewCellStateMask)state。 这个方法调用的时候，按钮就已经展示给用户了。而调用willTransitionToState的时候，因为cell的侧滑view是懒加载，还没有创建出来。Method willTransitionToState = class_getInstanceMethod(self, @selector(willTransitionToState:));Method __willTransitionToState = class_getInstanceMethod(self, @selector(__willTransitionToState:));method_exchangeImplementations(willTransitionToState, __willTransitionToState);Method titleForDeleteConfirmationButton = class_getInstanceMethod([UITableView class], NSSelectorFromString(@&quot;_titleForDeleteConfirmationButtonForRowAtIndexPath:&quot;));Method _titleForDeleteConfirmationButton = class_getInstanceMethod([UITableView class], NSSelectorFromString(@&quot;titleForDeleteConfirmationButtonForRowAtIndexPath:&quot;));method_exchangeImplementations(titleForDeleteConfirmationButton, _titleForDeleteConfirmationButton);&#125;);&#125;/*** 开始进行侧滑，并且button还没有出现的时候* 这个方法调用的时候，按钮还没有创建** @param state &lt;#state description#&gt;*///在发生侧滑的时候，这个方法先调用，然后再调用获取模型的方法//当用户在某一行刚开始进行侧滑并且侧滑的Button还没有展现出来时，state的值就为 UITableViewCellStateShowingDeleteConfirmationMask//这个方法无论是实现了tableView:editActionsForRowAtIndexPath:方法，还是实现了tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath，都会被调用，只有在两个方法都没有实现的情况下，才不会被调用- (void)__willTransitionToState:(UITableViewCellStateMask)state &#123;//首先让系统完成自己的事情[self __willTransitionToState:state];if (state == UITableViewCellStateShowingDeleteConfirmationMask) &#123;//在cell当中，通过kvc的方法来获得tableViewUITableView *tableView = [self valueForKey:@&quot;_tableView&quot;];// //为什么要做判断？： 因为单独的删除按钮是也会进入到这个方法的，而对于单独的删除按钮我们不需要再做额外的操作，要排除这种情况。if (![tableView.delegate respondsToSelector:@selector(tableView:editActionsForRowAtIndexPath:)]) &#123;return;&#125;//以下代码针对iOS7的// dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.001 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;//通过kvc获取到创建的_swipeToDeleteConfirmationView，这个是按钮的容器view//通过断点调试，可以发现，这个方法属于懒加载，在调用willTransitionToState： 的方法的时候还没有创建。这里采用了延迟执行代码块的方式，来获取这个containerViewUIView *swipeToDeleteConfirmationView = [self valueForKey:@&quot;_swipeToDeleteConfirmationView&quot;];//当系统版本大于等于8.0的时候if ([[[UIDevice currentDevice] systemVersion] compare:@&quot;8.0&quot; options:NSNumericSearch] != NSOrderedAscending) &#123;//获取容器view当中所有的subViewsfor (UIButton *deleteButton in swipeToDeleteConfirmationView.subviews) &#123;//用kvc，获取到按钮当中UITableViewRowAction模型UITableViewRowAction *rowAction = [deleteButton valueForKey:@&quot;_action&quot;];if (rowAction.backgroundColor) &#123;deleteButton.backgroundColor = rowAction.backgroundColor;&#125;//deleteButton.enabled = rowAction.enabled;//if (rowAction.image) &#123;NSTextAttachment *imageAtt = [[NSTextAttachment alloc] init];imageAtt.image = rowAction.image;//设置富文本title[deleteButton setAttributedTitle:[NSAttributedString attributedStringWithAttachment:imageAtt] forState:UIControlStateNormal];&#125;&#125;return;&#125;//systemVersion &lt; 8.0//在cell当中获得tableView 调用indexPathForCell来获取到NSIndexPathNSIndexPath *indexPath = [tableView indexPathForCell:self];//手动来调用这个方法NSArray *rowActions = [tableView.delegate tableView:tableView editActionsForRowAtIndexPath:indexPath];//利用关联对象进行存储self.rowActions = rowActions;//获取到第一个子控件UIButton *deleteConfirmButton = swipeToDeleteConfirmationView.subviews.firstObject;//背景颜色等于文字颜色deleteConfirmButton.titleLabel.textColor = deleteConfirmButton.backgroundColor;//CGFloat buttonWidth = deleteConfirmButton.bounds.size.width / rowActions.count;//CGFloat buttonHeight = deleteConfirmButton.bounds.size.height;for (NSInteger index = 0; index &lt; rowActions.count; index++) &#123;UITableViewRowAction *rowAction = rowActions[index];[rowAction setValue:indexPath forKey:@&quot;indexPath&quot;];//创建按钮UIButton *rowActionButton = [UIButton buttonWithType:UIButtonTypeCustom];//if (rowAction.backgroundColor) &#123;rowActionButton.backgroundColor = rowAction.backgroundColor;&#125; else &#123;//style==UITableViewRowActionStyleDestructive?//YES: 按钮的背景颜色等于deleteConfirmButton按钮的背景颜色//NO:rowActionButton.backgroundColor = rowAction.style == UITableViewRowActionStyleDestructive ? deleteConfirmButton.backgroundColor : [UIColor colorWithRed:187.0/255.0 green:187.0/255.0 blue:193.0/255.0 alpha:1.0];&#125;//if (rowAction.enabled) &#123;//调用模型，当中的方法[rowActionButton addTarget:rowAction action:NSSelectorFromString(@&quot;actionTriggered:&quot;) forControlEvents:UIControlEventTouchUpInside];&#125;rowActionButton.frame = CGRectMake((rowActions.count - 1 - index) * buttonWidth, 0, buttonWidth, buttonHeight);//rowAction.image ? [rowActionButton setImage:rowAction.image forState:UIControlStateNormal]: [rowActionButton setTitle:rowAction.title forState:UIControlStateNormal];//将子控件添加到deleteConfirmButton上[deleteConfirmButton addSubview:rowActionButton];&#125;// &#125;);&#125;&#125;#pragma mark -set and get/*** 方法当中的key用的SEL作为key，因为key需要是唯一的，所以呢，因为setRowActions使用的是_cmd ,那么setRowActions就不能使用cmd了，否则就不唯一了，就需要通过@selector()来获取setRowActions的_cmd* 分类当中内部使用的属性（关联对象）* UITableViewRowAction 在iOS8的时候才有的* @param rowActions &lt;#rowActions description#&gt; &amp;key*/- (void)setRowActions:(NSArray *)rowActions &#123;objc_setAssociatedObject(self, @selector(rowActions), rowActions, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSArray *)rowActions &#123;return objc_getAssociatedObject(self, _cmd);&#125;@end@implementation UITableView (JZExtension)//这个方法只会在iOS以上，并且没有实现tableView:editActionsForRowAtIndexPath:的时候才会调用//而对于iOS7及其以下会被调用/*** 这个方法的目的是设么？获取显示的字符串，通过字符串来计算按钮的宽度，所以，只要返回一个恰当的字符串，就能够由系统提供给我们一个恰当宽度的按钮。然后在这个按钮上添加子控件** @param indexPath &lt;#indexPath description#&gt;** @return &lt;#return value description#&gt;*/- (id)titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath &#123;// 如果代理没有实现tableView:editActionsForRowAtIndexPath:这个方法，就表示没有多按钮侧滑功能，那就只需要执行系统原有的方法实现，然后直接返回if (![self.delegate respondsToSelector:@selector(tableView:editActionsForRowAtIndexPath:)]) &#123;return [self titleForDeleteConfirmationButtonForRowAtIndexPath:indexPath];&#125;//所以这里这个方法是针对iOS7以下的并且实现了tableView:editActionsForRowAtIndexPath:// System version above iOS7 will not go on.//获取到rowActionsNSArray *rowActions = [self.delegate tableView:self editActionsForRowAtIndexPath:indexPath];NSMutableString *placeholder = [NSMutableString string];//NSString *longestString = @&quot; &quot;; //A placeholder string for the default width.&#123;CGFloat fontSize = 12;for (UITableViewRowAction *action in rowActions) &#123;//CGFloat actionTitleWidth = [action.title sizeWithFont:[UIFont systemFontOfSize:fontSize]].width;//CGFloat currentLongestStringWidth = [longestString sizeWithFont:[UIFont systemFontOfSize:fontSize]].width;//如果action中的标题宽度大于@“ ”//默认值 @“ ”； 宽度&gt;= @&quot; &quot;if (actionTitleWidth &gt; currentLongestStringWidth) &#123;longestString = action.title;&#125;&#125;&#125;for (int index = 0; index &lt; rowActions.count; index++) &#123;[placeholder appendString:longestString];&#125;return placeholder;&#125;@end https://github.com/JazysYu/JZTableViewRowAction原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IMP指针]]></title>
      <url>%2F2017%2F03%2F11%2FIMP%E6%8C%87%E9%92%88%2F</url>
      <content type="text"><![CDATA[Method Swizzling 利用运行时，在程序运行期间，可以动态的给两个方法互换实现，可以利用这个函数实现：1void method_exchangeImplementations(Method m1, Method m2) 使用场景： 当我们理解一个新的项目的时候，通常通过在类创建的时候，把自己的名字打印出来，从而了解程序的调用顺序。那么，就需要我们在每个类的viewDidLoad方法当中，添加一个log方法？显然这样做是非常麻烦的。也许会想到，让所有的类都继承一个基础类，在基础类当中添加log方法，这样就OK啦。如此做法就需要我们更改很多类的继承关系，所以也不是完美的解决办法。 这个时候，交换方法实现的方法就闪亮登场了。只需要给UIViewController添加一个分类，添加几行代码。1234567891011121314#import &quot;UIViewController+Log.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (Log)+(void)load&#123;Method m1 = class_getInstanceMethod([self class], @selector(viewDidLoad));Method m2 = class_getInstanceMethod([self class], @selector(viewDidLoaded));//交换viewDidLoad和viewDidLoaded方法的实现，这样当调用viewDidLoad方法的时候，就相当于被拦截了一样，调用到viewDidLoaded方法，在viewDidLoaded实现中，对自己的调用，被转移到对viewDidLoad方法的调用，然后再添加Log方法method_exchangeImplementations(m1, m2);&#125;-(void)viewDidLoaded&#123;[self viewDidLoaded];NSLog(@&quot;%@&quot;,[self class]);&#125;@end IMP指针IMP： Implementation的缩写。 IMP指针：指向方法实现的指针。 如何调用IMP：1IMP(target,SEL,params...); //与普通C函数的调用方式是相同的 不过如果你的项目没有做其他配置的话这样调用编译器是不会通过的，我们来看一下先它的定义：1234567if !OBJC_OLD_DISPATCH_PROTOTYPES//IMP ： 无参无返回值typedef void (*IMP)(void /* id, SEL, ... */ ); else//有参有返回值typedef id (*IMP)(id, SEL, ...); endif 对IMP指针的使用，需要更改配置文件：除了通过更改配置文件的方式外，还有一种方式就是自己来定义一个和有参的IMP指针相同类型的指针类型123456789101112131415161718192021#import &quot;UIViewController+Log.h&quot;#import &lt;objc/runtime.h&gt;typedef id (*_IMP) (id, SEL, ...);@implementation UIViewController (Log)+(void)load&#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;//获得原始方法Method viewDidLoad = class_getInstanceMethod(self, @selector(viewDidLoad));//获得方法实现IMP viewDIdLoadIMP = method_getImplementation(viewDidLoad);//重现设置方法实现method_setImplementation(viewDidLoad, imp_implementationWithBlock(^(id target, SEL action)&#123;viewDIdLoadIMP(target, @selector(viewDidLoad));NSLog(@&quot;%@ did load&quot;,target);&#125;));&#125;);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Runtime更改pop手势范围]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%88%A9%E7%94%A8Runtime%E6%9B%B4%E6%94%B9pop%E6%89%8B%E5%8A%BF%E8%8C%83%E5%9B%B4%2F</url>
      <content type="text"><![CDATA[思路： 1.导航控制器提供了interactivePopGestureRecognizer属性，这个属性就是控制pop控制器滑动的手势。而系统提供的滑动操作只能是屏幕边缘触发滑动，而有的时候，我们需要提供全屏滑动的效果。所以，开始寻求办法： 2.这个interactivePopGestureRecognizer手势，一定会触发方法来完成转场动画，以及控制转场进度。无论是通过边缘滑动，还是通过全屏幕滑动触发方法的调用，其触发的方法的内部实现原理和产生效果都是一样的，不同的是其手势的作用范围。那么，系统已经提供了手势触发后所调用的方法，我们就可以直接来使用这个方法，我们只是自定义一个手势，来调用这个现成的方法即可。 1.试图寻求在手势对象的内部有没有成员属性类似于target和action。 通过运行时来打印出手势所有的成语属性和属性类型：1234567891011unsigned int count;Ivar *ivars = class_copyIvarList([UIGestureRecognizer class], &amp;count);for (int i = 0; i &lt; count; i ++) &#123;Ivar ivar = ivars[i];const char *nameChar = ivar_getName(ivar);const char *typeChar =ivar_getTypeEncoding(ivar);NSString *typeStr = [NSString stringWithUTF8String:typeChar];NSString *nameStr = [NSString stringWithUTF8String:nameChar];NSLog(@&quot;%@&quot;,nameStr);NSLog(@&quot;%@&quot;,typeStr);&#125; 从打印结果来看，可能有用的就是图中这个：因为这是一个数组，推测一下来看，可能其中的元素就是拥有target和action属性的对象，尝试来打印这个元素获取信息： 因为这个_target是私有属性，所以利用kvc来获取它：123NSMutableArray *targets = [gesture valueForKey:@&quot;_targets&quot;];NSLog(@&quot;%@&quot;,targets);NSLog(@&quot;%@&quot;,targets[0]); 从打印结果来看，我们并没有获取到这个对象，那么应该是系统重新了description方法，使得我们无法直接来获取到这个私有的对象。倒是看见了它的属性_UINavigationInteractiveTransition（action）和handleNavigationTransition(action),而这个属性需要我们通过对象来获取，那么，又尝试通过打断点的方法来查看： 可以看到这个对象就是UIGestureRecognizerTarget现在就能够获取到target和action的值了：12id target = [gestureRecognizerTarget valueForKey:@&quot;_target&quot;];SEL action = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;); 那么，我们把自己创建的手势添加到interactivePopGestureRecognizer的view上，并且调用手势addTarget:action:方法，这里的参数target和action就是我们之前所获取到的 完整的代码：1234567891011121314151617181920212223242526272829UIGestureRecognizer *gesture = self.interactivePopGestureRecognizer;gesture.enabled = NO;//获取到手势作用的viewUIView *gestureView = gesture.view;//创建一个pan手势UIPanGestureRecognizer *popRecognizer = [[UIPanGestureRecognizer alloc] init];//self成为手势的代理popRecognizer.delegate = self;popRecognizer.maximumNumberOfTouches = 1;//重新添加一个手势[gestureView addGestureRecognizer:popRecognizer];/*** 获取系统手势的target数组*/NSMutableArray *_targets = [gesture valueForKey:@&quot;_targets&quot;];/*** 获取它的唯一对象，我们知道它是一个叫UIGestureRecognizerTarget的私有类，它有一个属性叫_target*/id gestureRecognizerTarget = [_targets firstObject];id target = [gestureRecognizerTarget valueForKey:@&quot;_target&quot;];SEL action = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);/*** 创建一个与系统一模一样的手势，我们只把它的类改为UIPanGestureRecognizer*/[popRecognizer addTarget:target action:action];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC消息转发]]></title>
      <url>%2F2017%2F03%2F10%2FOC%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
      <content type="text"><![CDATA[在调用方法的时候，系统会首先来查找有没有对应的方法的实现，在没有对应的实现的时候，系统会随后调用一些补救方法，当这些方法也没有实现的时候，才会crash，这是一个方法调用的完整过程。当没有方法的实现的时候，补救方法的调用顺序依次为：（一个是类方法的调用所对应的方法，一个是对象方法）+(BOOL)resolveInstanceMethod:(SEL)sel 或者 +(BOOL)resolveClassMethod:(SEL)sel 当这个方法依然无法提供方法的实现的时候，那么，系统会调用下面的方法： -(id)forwardingTargetForSelector:(SEL)aSelector 而当这个方法也无法提供调用方法的实现，那么，最后一次补救机会就是下面方法： -(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector -(void)forwardInvocation:(NSInvocation *)anInvocation 当这三次补救机会都未能提供方法实现的情况下，那么，就crash 这就是整个的调用顺序。 以下通过代码的来补充说明： 首先是在没有提供调用方法的实现，并且没有采取任何的补救措施的情况下的调用情况： 这个时候调用就直接报错： 方法找不到 方法一： 在Man.m当中，重写+(BOOL)resolveInstanceMethod:(SEL)sel方法 1234567891011121314151617#import &quot;Man.h&quot;#import &lt;objc/runtime.h&gt;@implementation Man+(BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == @selector(cook)) &#123;//把这个方法实现动态的添加进去(现在是在调用到这个方法的时候才添加)//当这个方法的实现被添加进去了之后，下次再调用cook方法就不会再进入到这个方法当中，因为现在已经添加了cook方法的时候，而resolveInstanceMethod只会在没有cook方法的实现的时候，才会被调用class_addMethod([self class], sel, (IMP)cook, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void cook (id self, SEL _cmd)&#123;NSLog(@&quot;man 做饭呢&quot;);&#125;@end 方法二： (没有重新方法一，或者方法一没有解决问题的情况下，就会采取方法二)1.首先是创建一个新的类woman类，这个类有cook方法的实现 12345@implementation Woman-(void)cook&#123;NSLog(@&quot;woman cook&quot;);&#125;@end 在调用man的cook方法的时候，进入到下面方法：12345678-(id)forwardingTargetForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;//这个地方就相当于自己实现不了 ，那么就交给别的对象来提供实现，就是转移return [[Woman alloc] init];&#125;return [super forwardingTargetForSelector:aSelector];&#125; 方法三： 当以上两个方法都无法解决的情况下，那么以下方法就成为了最后的一次补救机会：123456789101112131415-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];&#125;return [super methodSignatureForSelector:aSelector];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;SEL selector = anInvocation.selector;NSString *aSelectorStr = NSStringFromSelector(selector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;[anInvocation invokeWithTarget:[[Woman alloc] init]];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 Runtime 为 UIStackView 添加分割线]]></title>
      <url>%2F2017%2F03%2F10%2F%E7%94%A8-Runtime-%E4%B8%BA-UIStackView-%E6%B7%BB%E5%8A%A0%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[用 Runtime 为 UIStackView 添加分割线 使用方法：导入分类： #import &quot;UIStackView+Separator.h&quot; 使用方式 - (void)viewDidLoad { [super viewDidLoad]; //给UIStackView添加方法，并且不采用继承的方式 self.stackView.separatorColor = [UIColor grayColor]; self.stackView.separatorThickness = 1; self.stackView.separatorLength = 50; } UIStackView+Separator.h： #import &lt;UIKit/UIKit.h&gt; @interface UIStackView (Separator) @property UIColor *separatorColor; @property CGFloat separatorLength; @property CGFloat separatorThickness; @end UIStackView+Separator.m： #import &quot;UIStackView+Separator.h&quot; #import &lt;objc/runtime.h&gt; @interface UIStackViewSeparatorHelper : NSObject @property (nonatomic, strong) UIColor *separatorColor; @property (nonatomic, assign) CGFloat separatorLength; @property (nonatomic, assign) CGFloat separatorThickness; @property (nonatomic, weak) UIStackView *stackView; @property (strong, nonatomic) NSMutableArray&lt;UIView *&gt; *separatorViews; -(void)makeSeparators; @end @implementation UIStackViewSeparatorHelper -(instancetype)init{ if (self = [super init]) { self.separatorThickness = 1; self.separatorViews = [NSMutableArray array]; } return self; } -(void)makeSeparators{ UIStackView * __strong strongStackView = self.stackView; // if (!strongStackView || !self.separatorColor || (self.separatorLength &lt;= 0)) { return; } //从Superview当中移除 [self.separatorViews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { [obj removeFromSuperview]; }]; //移除所有的元素 [self.separatorViews removeAllObjects]; // [strongStackView.arrangedSubviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if (idx == 0) { return; } //idx == 1 取出第0个 遍历出当前的一个的时候，取出上一个 UIView *previousView = strongStackView.arrangedSubviews[idx - 1]; //创建了一个分割线 UIView *separatorView = [[UIView alloc] init]; //设置背景颜色 separatorView.backgroundColor = self.separatorColor; // CGFloat center; //如果排布的方式是水平的时候 if (strongStackView.axis == UILayoutConstraintAxisHorizontal) { // center = (CGRectGetMaxX(previousView.frame) + CGRectGetMinX(obj.frame)) / 2.0; separatorView.frame = CGRectMake(center, (CGRectGetHeight(strongStackView.frame) - self.separatorLength) / 2.0, self.separatorThickness, self.separatorLength); } else { center = (CGRectGetMaxY(previousView.frame) + CGRectGetMinY(obj.frame)) / 2.0; separatorView.frame = CGRectMake((CGRectGetWidth(strongStackView.frame) - self.separatorLength) / 2.0, center, self.separatorLength, self.separatorThickness); } //这里使用addSubview: 而不能使用arrangedSubviews，这样就能够避免系统的布局，而由自己来布局separater [strongStackView addSubview:separatorView]; //将separatorView添加到容器数组当中 [self.separatorViews addObject:separatorView]; }]; } @end @implementation UIStackView (Separator) static const char kHelperKey; +(void)load{ // Method m1 = class_getInstanceMethod([self class], @selector(layoutSubviews)); // Method m2 = class_getInstanceMethod([self class], @selector(tc_layoutSubviews)); // method_exchangeImplementations(m1, m2); // Class cls = [self class]; Method oriMethod = class_getInstanceMethod(cls, @selector(layoutSubviews)); Method newMethod = class_getInstanceMethod(cls, @selector(tc_layoutSubviews)); //v@: method_getTypeEncoding BOOL didAddMethod = class_addMethod([self class], @selector(layoutSubviews), method_getImplementation(newMethod), &quot;v@:&quot;); if (didAddMethod) { class_replaceMethod([self class], @selector(tc_layoutSubviews), method_getImplementation(oriMethod), &quot;v@:&quot;); }else{ method_exchangeImplementations(oriMethod, newMethod); } } #pragma mark --setter and getter /*-------这里的属性因为分类无法存储的缘故，所以采用了转移到其他类，我们只要拥有这个其他类，就能够获取到他的属性-------*/ /*------------当触发set方法的时候，不仅要触发出传入值得存储，同时要创建和布局分割线----------------*/ -(void)setSeparatorColor:(UIColor *)separatorColor{ [self stackViewSeparatorHelper].separatorColor = separatorColor; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorLength:(CGFloat)separatorLength{ [self stackViewSeparatorHelper].separatorLength = separatorLength; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorThickness:(CGFloat)separatorThickness{ [self stackViewSeparatorHelper].separatorThickness = separatorThickness; [[self stackViewSeparatorHelper] makeSeparators]; } -(CGFloat)separatorThickness{ return [self stackViewSeparatorHelper].separatorThickness; } -(UIColor *)separatorColor{ return [self stackViewSeparatorHelper].separatorColor; } -(CGFloat)separatorLength{ return [self stackViewSeparatorHelper].separatorLength; } -(UIStackViewSeparatorHelper *)stackViewSeparatorHelper{ UIStackViewSeparatorHelper *stackViewSeparatorHelper = objc_getAssociatedObject(self, &amp;kHelperKey); //在这个get方法当中，如果没有get到，那么就触发set的操作 if (!stackViewSeparatorHelper) { UIStackViewSeparatorHelper * helper = [[UIStackViewSeparatorHelper alloc] init]; helper.stackView = self; objc_setAssociatedObject(self, &amp;kHelperKey, helper, OBJC_ASSOCIATION_RETAIN_NONATOMIC); stackViewSeparatorHelper = helper; } return stackViewSeparatorHelper; } /** *在布局stackView的时候，这个时候，就需要同时布局分割线，所以，必须要监听到layoutSubViews方法 * 比如说，UIStackView添加了子控件（通过arrangedSubviews添加），那么就会调用这个方法来布局 ，这个时候 ，就需要重新布局separator * UIStackView 只会负责 arrangedSubviews 的布局，也就是说我们利用这个特性来将分割线直接加到 stack view 上而不受其布局，只要我们不使用 addArrangedSubView 即可。 */ -(void)tc_layoutSubviews{ //先让UIStackView的arrangedSubviews完成布局 [self tc_layoutSubviews]; //布局separater [[self stackViewSeparatorHelper] makeSeparators]; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIVisualEffect 模糊动画]]></title>
      <url>%2F2017%2F03%2F09%2FUIVisualEffect-%E6%A8%A1%E7%B3%8A%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[UIVisualEffect 模糊动画Demo @interface ViewController () @property (weak, nonatomic) IBOutlet UIVisualEffectView visualEffect; @property (weak, nonatomic) IBOutlet UILabel label; @property (weak, nonatomic) IBOutlet NSLayoutConstraint *topLayoutConstraint; @end @implementation ViewController - (IBAction)visualEffectViewClick:(id)sender { if (self.label.hidden == YES) { self.label.hidden = NO; self.topLayoutConstraint.constant = 160; UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:(UIBlurEffectStyleDark)]; [UIView animateWithDuration:1 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{ self.visualEffect.effect = blurEffect; self.label.textColor = [UIColor colorWithWhite:1 alpha:1]; [self.view layoutIfNeeded]; } completion:nil]; }else{ self.topLayoutConstraint.constant = 0; [UIView animateWithDuration:0.2 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(0) animations:^{ self.label.textColor = [UIColor colorWithWhite:1 alpha:0.2]; [self.view layoutIfNeeded]; self.visualEffect.effect = nil; } completion:^(BOOL finished) { self.label.hidden = YES; self.topLayoutConstraint.constant = 360; }]; } } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[彩虹渐变的滚动列表]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%BD%A9%E8%99%B9%E6%B8%90%E5%8F%98%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[彩虹渐变的滚动列表原文链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#import &quot;ViewController.h&quot;@interface ViewController()&lt;UITableViewDelegate,UITableViewDataSource&gt;//数组用来存储起始颜色和终点颜色&#123;NSArray *_color;&#125;@property(nonatomic,strong) UITableView *tableView;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];//存储颜色变化的起始值和终值self-&gt;_color = @[[UIColor colorWithRed:0.85 green:0 blue:0.09 alpha:1],[UIColor colorWithRed:0.9 green:0.56 blue:0.11 alpha:1]];self.view.backgroundColor = [UIColor blackColor];self.tableView = [[UITableView alloc] initWithFrame:self.view.bounds];self.tableView.separatorStyle = UITableViewCellSelectionStyleNone;self.tableView.contentInset = UIEdgeInsetsMake(20, 0, 0, 0);self.tableView.delegate =self;self.tableView.dataSource = self;UIVisualEffectView *veView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]];veView.frame = CGRectMake(0, 0, self.view.bounds.size.width, 20);[self.view addSubview:self.tableView];[self.view addSubview:veView];&#125;//创建的UIColor对象无法再获取到其中的颜色组件，将这里的颜色数组作为参数传入，这样通过这个方法可获得在任何颜色设定基础上的对应颜色-(UIColor *)calculateColorWithProgress:(float)progress usingColors:(NSArray&lt;UIColor *&gt;*)colors&#123;UIColor *color1 = [colors firstObject];UIColor *color2 = [colors lastObject];// UIColor -&gt; CGColorconst CGFloat *color1Components = CGColorGetComponents(color1.CGColor);const CGFloat *color2Components = CGColorGetComponents(color2.CGColor);// 这里从终点值到初始值的差值 * progress = 【0 - 差值】float red = color1Components[0] + (color2Components[0] - color1Components[0]) * progress;float green = color1Components[1] + (color2Components[1] - color1Components[1]) * progress;float blue = color1Components[2] + (color2Components[2] - color1Components[2]) * progress;return [UIColor colorWithRed:red green:green blue:blue alpha:1];&#125;-(float)calculateProgressWithView:(UIView *)view&#123;//converRect: toView: 转换坐标系//从相对于tableView的坐标系 转换到view上去CGRect convertedRect = [view convertRect:view.bounds toView:self.view];CGFloat convertedY = convertedRect.origin.y;//[0 - 1]return convertedY / (self.view.bounds.size.height - 60);&#125;-(UITableViewCell *)makeTableViewCell&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;];cell.selectionStyle = UITableViewCellSeparatorStyleNone;cell.textLabel.font = [UIFont boldSystemFontOfSize:16];cell.textLabel.textColor = [UIColor whiteColor];//设置文字的阴影cell.textLabel.shadowColor = [UIColor colorWithWhite:0 alpha:0.4];cell.textLabel.shadowOffset = CGSizeMake(0, 1);//下面的两个 CAShapeLayer 主要是为了实现高光阴影的效果，也就是这个 cell 的上边有一条亮边，下边有层阴影CAShapeLayer *topHighlightLayer = [CAShapeLayer layer];topHighlightLayer.path = CGPathCreateWithRect(CGRectMake(0, 0, self.view.bounds.size.width, 1), nil);topHighlightLayer.fillColor = [UIColor whiteColor].CGColor;topHighlightLayer.opacity = 0.1;[cell.layer addSublayer:topHighlightLayer];CAShapeLayer *bottomShadowLayer = [CAShapeLayer layer];bottomShadowLayer.path = CGPathCreateWithRect(CGRectMake(0, 59, self.view.bounds.size.width, 1), nil);bottomShadowLayer.fillColor = [UIColor blackColor].CGColor;bottomShadowLayer.opacity = 0.2;[cell.layer addSublayer:bottomShadowLayer];return cell;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 30;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *CellIdentifiter = @&quot;Cell&quot;;UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:CellIdentifiter];if (!cell) &#123; cell = [self makeTableViewCell];&#125;cell.textLabel.text = [NSString stringWithFormat:@&quot;This is test item %ld&quot;,indexPath.row];cell.detailTextLabel.text = @&quot;1&quot;;return cell;&#125;//需要注意的是，cell 刚创建完毕后滚动的代理方法是不会触发的//所以我们需要用到tableView:willDisplayCell:forRowAtIndexPath:这个代理方法来对每个新建的 cell 作相应设置。-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;//设置cell的背景色cell.backgroundColor = [self calculateColorWithProgress:[self calculateProgressWithView:cell] usingColors:self -&gt; _color];&#125;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;return 60;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;if ([scrollView isEqual:self.tableView]) &#123; //获取所有可见的cell [self.tableView.visibleCells enumerateObjectsUsingBlock:^(__kindof UITableViewCell * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; float progress = [self calculateProgressWithView:obj]; UIColor *color = [self calculateColorWithProgress:progress usingColors:self -&gt; _color]; obj.backgroundColor = color; &#125;];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巧妙运用对象关联设计alertview]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B7%A7%E5%A6%99%E8%BF%90%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E8%AE%BE%E8%AE%A1alertview%2F</url>
      <content type="text"><![CDATA[UIAlertView事件处理方式一：通过这种方式，存在的缺陷有：控件的创建和事件的处理是分布的，这样的阅读性是较差的，同时，在事件处理方法当中，当面对多个UIAlertView的时候，需要进行if else的判断，代码选得特别冗余 // button1 点击执行的方法 - (IBAction)alertClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 1000; [alertView show]; } // button2 点击执行的方法 - (IBAction)alertClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 2000; [alertView show]; } // alertview 点击执行的delegate方法,前提 需要self实现UIAlertViewDelegate协议 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (alertView.tag == 1000) { NSLog(@&quot;alertView1 执行逻辑操作&quot;); } else if (alertView.tag == 2000) { NSLog(@&quot;alertView2 执行逻辑操作&quot;); } else if (alertView.tag == 3000) { NSLog(@&quot;alertView3 执行逻辑操作&quot;); } // ...等等很多alertview } UIAlertView事件处理方式二： 在UIAlertView的分类当中UIAlertView+tc.h @interface UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void(^)()) block; @end UIAlertView+tc.m typedef void(^block)(); static char const *TCAlertViewKey = “TCAlertViewKey”; #import &quot;UIAlertView+tc.h&quot; #import &lt;objc/message.h&gt; @interface UIAlertView()&lt;UIAlertViewDelegate&gt; @end @implementation UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ objc_setAssociatedObject(self, TCAlertViewKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC); self.delegate = self; } #pragma mark -UIAlertViewDelegate -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex: (NSInteger)buttonIndex{ block block = objc_getAssociatedObject(self, TCAlertViewKey); block(alertView, buttonIndex); } @end 调用的部分： - (IBAction)buttonClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@---- %zd&quot;,alertView, index); }]; } - (IBAction)buttonClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@ +++++ %zd&quot;,alertView, index); }]; } UIAlertView事件处理方式三： typedef void(^block)(); #import &lt;objc/message.h&gt; #import &quot;UIAlertView+tc.h&quot; static char const *TCAlertViewKey = &quot;TCAlertViewKey&quot;; /** * 一个专门的类，用来处理代理事件，包括block的存储以及事件的处理 */ @interface TCAlertViewDelegate : NSObject&lt;UIAlertViewDelegate&gt; { block _block; } -(instancetype)initWithBlock:(block) block; @end @implementation TCAlertViewDelegate -(instancetype)initWithBlock:(block)block{ if (self = [super init]) { objc_setAssociatedObject(self, TCAlertViewKey, self, OBJC_ASSOCIATION_COPY_NONATOMIC); _block = block; } return self; } -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (_block) { _block(alertView, buttonIndex); } } @end @implementation UIAlertView (tc) //delegate -&gt; weak ，如果直接让TCAlertViewDelegate对象成为代理，会马上 挂掉 -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ //添加了一个关联对象，因为这个对象的存储方式是copy，所以这个对象就不会被释放 id delegate = objc_getAssociatedObject( [[TCAlertViewDelegate alloc] initWithBlock:block],TCAlertViewKey); //让这个专门的类成为代理 self.delegate = delegate; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runtime]]></title>
      <url>%2F2017%2F03%2F07%2Fruntime%2F</url>
      <content type="text"><![CDATA[runtime作用 1.发送消息 2.交换方法 3.动态添加方法 4 给分类添加属性 5.字典转模型 一、runtime简介 对于C语言，函数的调用在编译的时候，就决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候，并不能真正的决定调用哪个函数，只有在真正的运行的时候才会根据函数的名称找到对应的函数来调用 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错 在编译阶段，C语言调用未实现的函数就会报错 二、runtime作用 1.发送消息 方法调用的本质，就是让对象发送消息 objc_megSend,只有对象才能发送消息，因此以objc开头 使用消息机制前提，必须导入#import clang -rewrite-objc main.m 查看最终生成代码 123@autoreleasepool &#123;Person *person = [[Person alloc] init];&#125; 123456int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));&#125;return 0;&#125; 或者12Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;init&quot;)); 创建person对象12345678910111213Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 示例12345Person.h@interface Person : NSObject- (void)run:(NSInteger)metre;- (void)eat;@end Person.m123456789101112131415161718192021222324#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;NSLog(@&quot;吃&quot;);&#125;- (void)run:(NSInteger)metre&#123;NSLog(@&quot;跑了%ld&quot;,metre);&#125;@end消息的发送（方法的调用底层实现是对消息的发送）Person *p = objc_msgSend([Person class], @selector(alloc));//Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));p = objc_msgSend(p, @selector(&quot;init&quot;));//调用eat方法[p eat];//或者//msgSend(p, @selector(&quot;eat&quot;));//msgSend(p, sel_registerName(&quot;eat&quot;));//调用run：方法[p run:20];//msgSend(p , @selector(run:), 20);//msgSend(p, sel_register(&quot;run:&quot;), 20); 2.交换方法 开发场景： 系统自动的方法功能不够用，给系统自带的方法扩展一些功能，并且保持原有的功能，使用runtime交换方法需求：在项目当中，我们一直以来通过imageNamed：方法来加载图片，但是我们无法得知图片是否加载成功，现在，提出这样的需求，需要我们在调用这个方法的时候，同时得知图片是否加载成功。分析： 使用继承： 需要我们在所有使用到imageNamd:方法的地方都导入继承类的头文件，并且更改方法的调用者，而且需要告知其他的开发人员，需要调用这个继承的类，所以，使用起来很不方便使用分类：这样会覆盖系统的实现， 就是完全的重新实现这个方法所以，对于这样的开发需求，更好的实现方法是通过runtime的交换方法来实现 通过继承的方式来实现需求：123456789101112#import &quot;TCImage.h&quot;@implementation TCImage+(UIImage *)imageNamed:(NSString *)name&#123;UIImage *image = [super imageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，就会麻烦一些：首先需要导入头文件 #import “TCImage.h”在调用方法的时候，就需要通过一个新的类来调用UIImage *image = [UIImage imageNamed:@””];而运用runtime，通过交换方法的实现：123456789101112131415161718#import &quot;UIImage+Image.h&quot;#import &lt;objc/message.h&gt;@implementation UIImage (Image)+(void)load&#123;Method m1 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(imageNamed:));Method m2 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(tcimageNamed:));method_exchangeImplementations(m1, m2);&#125;+(instancetype)tcimageNamed:(NSString *)name&#123;UIImage *image = [self tcimageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，没有任何的改变，但已经在系统实现的基础上，多了获取是否加载成功的功能 3.动态添加方法开发使用场景： 如果一个类方法非常多，加载到内存的时候也比较耗资源，需要给每个方法生成映射表，可以通过动态给某个类添加方法比如：很多应用都分了会员和非会员，很多方法，在非会员的时候，完全都不会使用到，这个时候把方法加载到内存是比较费资源的，没有必要生成这些不会用到的方法的映射表 这个时候，就可以通过动态添加方法来解决这一问题，当用到这个方法的时候再去添加实现调用一个并没有添加实现的方法，需要用到performSelector12Person *p = [[Person alloc] init];[p performSelector:@selector(run:) withObject:@10]; 在Person.m文件中1234567891011121314void aaa(id self, SEL _cmd, NSNumber *meter) &#123;NSLog(@&quot;跑了%@&quot;, meter);&#125;// 任何方法默认都有两个隐式参数,self,_cmd// 什么时候调用:只要一个对象调用了一个未实现的方法就会调用这个方法,进行处理// 作用:动态添加方法,处理未实现+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == NSSelectorFromString(@&quot;run:&quot;)) &#123;class_addMethod(self, sel, (IMP)aaa, &quot;v@:@&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125; 4 给分类添加属性分析： 给一个类声明属性，本质就是给这个类添加关联对象，而不是直接把这个值的内存添加到类内存当中应用场景： 给一个系统的类添加一个关联对象（新增属性）给系统类NSObject添加一个那么属性 1234@interface NSObject (Property)//在分类当中，这里只会生成get和set方法的声明，并不会生成方法的实现，所以，也就没有必要说明存储机制@property NSString *name;@end .m文件12345678910#import &quot;NSObject+Property.h&quot;#import &lt;objc/message.h&gt;@implementation NSObject (Property)-(NSString *)name&#123;return objc_getAssociatedObject(self, &quot;name&quot;);&#125;-(void)setName:(NSString *)name&#123;objc_setAssociatedObject(self, &quot;name&quot;, name,OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题： 一个一个的添加模型属性是一件乏味没有技术含量耗时的操作 需求：能不能自动根据字典，生成对应的属性 解决： 提供一个分类，专门根据字典生成对应的属性字符串 1234567891011121314151617181920212223242526272829303132@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123;// 拼接属性字符串代码NSMutableString *strM = [NSMutableString string];// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;// 类型经常变，抽出来NSString *type;if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;type = @&quot;NSString&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;type = @&quot;NSArray&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;type = @&quot;int&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;type = @&quot;NSDictionary&quot;;&#125;// 属性字符串NSString *str;if ([type containsString:@&quot;NS&quot;]) &#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];&#125;else&#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];&#125;// 每生成属性字符串，就自动换行。[strM appendFormat:@&quot;\n%@\n&quot;,str];&#125;];// 把拼接好的字符串打印出来，就好了。NSLog(@&quot;%@&quot;,strM);&#125;@end 字典转模型的方式一：KVC 12345678@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123;Status *status = [[self alloc] init];[status setValuesForKeysWithDictionary:dict];return status;&#125;@end 转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 //因为通过key没有找到对应的属性，所以调用setValue:forUndefinedKey:报错，那么，通过通过重新这个方法的实现就避免了报错123- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; &#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 解析Plist文件NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];// 获取字典数组NSArray *dictArr = statusDict[@&quot;statuses&quot;];// 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];_statuses = [NSMutableArray array];// 遍历字典数组for (NSDictionary *dict in dictArr) &#123;Status *status = [Status modelWithDict:dict];[_statuses addObject:status];&#125;// 测试数据NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123;// 思路：遍历模型中所有属性-》使用运行时// 0.创建对应的对象id objc = [[self alloc] init];// 1.利用runtime给对象中的成员属性赋值// class_copyIvarList:获取类中的所有成员属性// Ivar：成员属性的意思// 第一个参数：表示获取哪个类中的成员属性// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。/* 类似下面这种写法Ivar ivar;Ivar ivar1;Ivar ivar2;// 定义一个ivar的数组aIvar a[] = &#123;ivar,ivar1,ivar2&#125;;// 用一个Ivar *指针指向数组第一个元素Ivar *ivarList = a;// 根据指针访问数组第一个元素ivarList[0];*/unsigned int count;// 获取类中的所有成员属性Ivar *ivarList = class_copyIvarList(self, &amp;count);for (int i = 0; i &lt; count; i++) &#123;// 根据角标，从数组取出对应的成员属性Ivar ivar = ivarList[i];// 获取成员属性名NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];// 处理成员属性名-&gt;字典中的key// 从第一个角标开始截取NSString *key = [name substringFromIndex:1];// 根据成员属性名去字典中查找对应的valueid value = dict[key];// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型// 判断下value是否是字典if ([value isKindOfClass:[NSDictionary class]]) &#123;// 字典转模型// 获取模型的类对象，调用modelWithDict// 模型的类名已知，就是成员属性的类型// 获取成员属性类型NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];// 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符// 裁剪类型字符串NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];type = [type substringFromIndex:range.location + range.length];range = [type rangeOfString:@&quot;\&quot;&quot;];// 裁剪到哪个角标，不包括当前角标type = [type substringToIndex:range.location];// 根据字符串类名生成类对象Class modelClass = NSClassFromString(type);if (modelClass) &#123; // 有对应的模型才需要转// 把字典转模型value = [modelClass modelWithDict:value];&#125;&#125;// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.// 判断值是否是数组if ([value isKindOfClass:[NSArray class]]) &#123;// 判断对应类有没有实现字典数组转模型数组的协议if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;// 转换成id类型，就能调用任何对象的方法id idSelf = self;// 获取数组中字典对应的模型NSString *type = [idSelf arrayContainModelClass][key];// 生成模型Class classModel = NSClassFromString(type);NSMutableArray *arrM = [NSMutableArray array];// 遍历字典数组，生成模型数组for (NSDictionary *dict in value) &#123;// 字典转模型id model = [classModel modelWithDict:dict];[arrM addObject:model];&#125;// 把模型数组赋值给valuevalue = arrM;&#125;&#125;if (value) &#123; // 有值，才需要给模型的属性赋值// 利用KVC给模型中的属性赋值[objc setValue:value forKey:key];&#125;&#125;return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView 顶部加入视差图片的效果]]></title>
      <url>%2F2017%2F03%2F07%2FUITableView-%E9%A1%B6%E9%83%A8%E5%8A%A0%E5%85%A5%E8%A7%86%E5%B7%AE%E5%9B%BE%E7%89%87%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[UITableView 顶部加入视差图片的效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#import &quot;ViewController.h&quot;@interface ViewController ()&lt;UITableViewDelegate,UITableViewDataSource&gt;@property(nonatomic,weak) UIImageView *imageView;@property(nonatomic,weak) UITableView *tableView;@end@implementation ViewController-(UITableView *)tableView&#123;if (_tableView == nil) &#123;UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];_tableView = tableView;_tableView.contentInset = UIEdgeInsetsMake(300, 0, 0, 0);_tableView.dataSource = self;_tableView.delegate = self;[self.view addSubview:tableView];&#125;return _tableView;&#125;-(UIImageView *)imageView&#123;if (_imageView == nil) &#123;UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, -150, self.view.bounds.size.width, 300)];imageView.layer.anchorPoint = CGPointMake(0.5, 0);_imageView = imageView;_imageView.image = [UIImage imageNamed:@&quot;IMG_0084&quot;];[self.view addSubview:_imageView];&#125;return _imageView;&#125;-(void)viewWillAppear:(BOOL)animated&#123;[super viewWillAppear:animated];[self.tableView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];[UIView beginAnimations:nil context:nil];[self makeParallaxEffect];[UIView commitAnimations];&#125;-(void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];[self.tableView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];[UIView beginAnimations:nil context:nil];self.navigationController.navigationBar.alpha = 1.0;[UIView commitAnimations];&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;if (object == _tableView) &#123;[self makeParallaxEffect];&#125;&#125;-(void)makeParallaxEffect&#123;CGFloat y = [[self.tableView valueForKey:@&quot;contentOffset&quot;] CGPointValue].y;if (y &lt; - 300.0) &#123;CGFloat scale = fabs(y) / 300;_imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;else if(y &lt; 0)&#123;_imageView.transform = CGAffineTransformMakeTranslation(0, -(300 + y));//y=0 alp=1 y=-300 alp=0self.navigationController.navigationBar.alpha = (y + 300)/300.0;_imageView.alpha = (1 - self.navigationController.navigationBar.alpha);&#125;&#125;-(void)viewDidLoad&#123;//这里自己来计算contentInset，所以，将automaticallyAdjustsScrollViewInsets属性值设置为NOself.automaticallyAdjustsScrollViewInsets = NO;//需要注意的是，这里的_tableView要先于_imageView添加，才能保证_imageView能够显示出来self.tableView.backgroundColor = [UIColor whiteColor];self.imageView.backgroundColor = [UIColor whiteColor];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 200;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];cell.textLabel.text = @&quot;test&quot;;return cell;&#125;-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;[self performSegueWithIdentifier:@&quot;tag&quot; sender:nil];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[innerHTML和creatTextCode区分]]></title>
      <url>%2F2017%2F03%2F05%2FinnerHTML%E5%92%8CcreatTextCode%E5%8C%BA%E5%88%86%2F</url>
      <content type="text"><![CDATA[innerHTML 与 createTextNodeinnerHTML在js是双向功能:获取对象的内容或向对象插入内容1234567891011121314&lt;p id=&quot;pid&quot;&gt;我将被替换&lt;/p&gt;&lt;button onclick=&quot;replaceContentFunction()&quot;&gt;点击替换标签&lt;/button&gt;&lt;p id=&quot;getInnerHTMLID&quot;&gt;我的内容将被获取&lt;/p&gt;&lt;button onclick=&quot;getInnerHTMLFuncation()&quot;&gt;点我获取内容&lt;/button&gt;&lt;script&gt;function replaceContentFunction() &#123;var node = document.getElementById(&quot;pid&quot;);node.innerHTML = &quot;我已经被替换啦😭&quot;;&#125;function getInnerHTMLFuncation() &#123;var node = document.getElementById(&quot;getInnerHTMLID&quot;);alert(node.innerHTML);&#125;&lt;/script&gt; 我将被替换 点击替换标签 我的内容将被获取 点我获取内容 function replaceContentFunction() { var node = document.getElementById("pid"); node.innerHTML = "我已经被替换啦😭"; } function getInnerHTMLFuncation() { var node = document.getElementById("getInnerHTMLID"); alert(node.innerHTML); } innerHTML与createTextNode区别:都可以把一段内容添加到一个节点中,区别在于:如果添加的内容当中有html标签,而这段标签在createTextNode方法中会被当做文本内容来处理,不会被浏览器解析,而在innerHTML中会被当做标签进行解析.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习之Location对象]]></title>
      <url>%2F2017%2F03%2F05%2FHTML%E5%AD%A6%E4%B9%A0%E4%B9%8BLocation%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[Location对象包含有关当前URL的信息,Location对象是window对象的一部分,可通过window.location来访问 Location对象方法 reload()定义和用法reload() 方法用于重新加载当前文档。如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。 如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift健的效果是完全一样。 实例1234&lt;script&gt;function btnClickFunc() &#123; window.location.reload()&#125;&lt;/script&gt;&lt;button onclick=&quot;btnClickFunc()&quot;&gt;点击刷新当前页面&lt;/button&gt; function btnClickFunc() { window.location.reload()} 点击刷新当前页面 assign()定义和用法assign() 方法可加载一个新的文档。语法1location.assign(URL) 实例1234&lt;script&gt;function reloadNewPageBtnClickFunc() &#123;window.location.assign(&quot;https:www.baidu.com&quot;)&#125;&lt;/script&gt;&lt;button onclick=&quot;reloadNewPageBtnClickFunc()&quot;&gt;点击加载一个新的url&lt;/button&gt; function reloadNewPageBtnClickFunc() {window.location.assign(“https:www.baidu.com”)} 点击加载一个新的url Location对象属性 属性描述hostname设置或返回当前 URL 的主机名。href设置或返回完整的 URL。pathname设置或返回当前 URL 的路径部分。protocol设置或返回当前 URL 的协议。search设置或返回从问号 (?) 开始的 URL（查询部分）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL Scheme]]></title>
      <url>%2F2017%2F03%2F04%2FURL-Scheme%2F</url>
      <content type="text"><![CDATA[URL Scheme经常使用的地方有:APP间跳转,服务器通知客户端的跳转以及H5与Naative跳转 scheme三方面的作用: 服务器下发跳转路径,客户端根据服务器发送的跳转路径进行跳转H5页面点击锚点根据锚点具体跳转路径APP端跳转具体的页面APP端收到服务器端下发的PUSH通知栏消息,根据消息的跳转路径,跳转相关页面 URL Scheme 概述客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如车辆详情页、订单详情页、消息通知页、促销广告页等等。也可以执行某些指定动作，如订单支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面。 URL scheme 的格式客户端自定义的 URL 作为从一个应用调用另一个的基础，遵循 RFC 1808 (Relative Uniform Resource Locators) 标准。这跟我们常见的网页内容 URL 格式一样。一个普通的 URL 分为几个部分，scheme、host、relativePath、query。我们用到的NSURL123NSURL *url = [NSURL URLWithString:@&quot;http://www.testurl.com:8080/subpath/subsubpath?uid=123&amp;gid=456&quot;];[url scheme]为http, [url host]为www.testurl.com，[url port]为8080，[url path]为/subpath/subsubpath，[url lastPathComponent]为subsubpath，[url query]为uid=123&amp;gid=456 一个应用中使用的 URL 例子（该 URL 会调起车辆详情页）：12zqprojectmobile://project/carDetail?car_id=123456scheme为zqprojectmobile,host为project,relativePath为/carDetail,query为car_id=123456 项目中定义了专门的类命名为JumpURLHandle，通过类方法parseURL:来处理参数中的url。本文以此为例讲解scheme的定义与解析。首先客户端应用向操作系统注册一个或者多个 URL scheme，例如项目中就定 义了多个分别scheme，分别为： 123zqprojectmobile: 对应普通APP间跳转schemezqprojectwxpay: 对应微信支付完成之后跳转回来的schemezqprojectalipay：对应支付宝支付完成之后跳转回来的scheme 对应的parseURL:方法里解析为：1234567891011121314151617181920212223//一个专门的类用于处理跳转,并且提供了一个方法解析url+ (BOOL)parseURL:(NSURL *)url&#123;//对获取到的url进行解析判断,确定跳转的性质// 支付宝客户端支付后的回调if ([[url scheme] isEqualToString:@&quot;zqprojectalipay&quot;]|| ([[[url scheme] lowercaseString] isEqualToString:kUuyongcheAlipayScheme]))&#123;return 支付宝支付完成后的回调处理方法;&#125;// 微信客户端支付后的回调 协议是zqprojectwxpay并且host是pay,则属于微信支付完成之后的回调else if ([url.scheme isEqualToString:@&quot;zqprojectwxpay&quot;] &amp;&amp; [url.host isEqualToString:@&quot;pay&quot;])&#123;return 微信支付完成后的回调处理方法;&#125;// 本应用 scheme 调用else if (([[url scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[url scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;return [[JumpURLHandle getInstance] parseAppUrl:url];&#125;return NO;&#125; 定义relativePath，并通过relativePath来判断是执行动作还是跳转页面，当执行动作时把relativePath定义为”/action”，在解析时如果url的relativePath是”/action”则跳转到执行动作的处理方法里，否则执行跳转页面的逻辑。例如：12345zqprojectmobile://project/action?name=back，relativePath为/action，执行动作（返回前页）zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，执行跳转页面的逻辑 代码：12345678910111213141516- (BOOL)parseAppUrl:(NSURL *)url&#123;NSString *relativePath = [url relativePath];// scheme 调起执行动作if ([relativePath isEqualToString:@&quot;/action&quot;])&#123;[self jumpActions:url];&#125;// scheme 调起跳转页面else&#123;[self jumpNativeViewControllers:url];&#125;return YES;&#125; 如果是执行动作的逻辑，获取query，字符串处理，获取键值对，获取名称为”name”的key对应的字符串，字符串对比判断执行相应的动作例如：12qprojectmobile://project/action?name=back，relativePath为/action，query为name=back，字符串处理后得到字典@&#123;name:back&#125;, 代码：1234567891011- (void)jumpActions:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *actionName = [dictionaryQuery objectForKey:@&quot;name&quot;];// 返回前面的页面if ([actionName isEqualToString:@&quot;back&quot;])&#123;//返回上一个页面的动作&#125; 如果是执行跳转页面的逻辑，可以直接将要跳转的页面设置为relativePath的值，然后获取relativePath字符串进行对比跳转相应的页面。如果页面跳转需要传值可以放到query里，获取url的query，字符串处理，获取键值对，一一赋值，例如：1234zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，跳转到订单详情页面query为order_id=42347645&amp;type=2，字符串处理获取字典@&#123;order_id:42347645,type:2&#125;,订单详情页面的订单id为order_id对应的值42347645，订单类型为2 代码：123456789101112131415161718- (void)jumpNativeViewControllers:(NSURL *)url&#123;NSString *relativePath = [url relativePath];if ([relativePath isEqualToString:@&quot;/order&quot;])&#123;[self jumpOrder:url];&#125;&#125;- (void)jumpOrder:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *orderId = [dictionaryQuery objectForKey:@&quot;orderId&quot;];NSString *type = [dictionaryQuery objectForKey:@&quot;type&quot;];// 创建新的订单页面并且传值&#125; 通过以上几步就可以定义出一个完整的scheme协议并且在JumpURLHandle类里完成解析 需要用到JumpURLHandle解析scheme的地方APP端收到服务器端下发的PUSH通知栏消息和APP相互跳转时需要在AppDelegate里处理12345678910/ 废弃- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation&#123;return [JumpURLHandle parseURL:url];&#125;或者- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123;return [JumpURLHandle parseURL:url];&#125; 服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面,在一个网络请求成功的回调方法或者block里拿到url，调用[JumpURLHandle parseURL:url]; H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面，在UIWebView的代理方法12- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType 中调用，该回调方法返回YES时webView才继续加载页面，当我们通过scheme解析处理事件时就不需要再继续加载页面返回NO.UIWebViewNavigationType的类型有：UIWebViewNavigationTypeLinkClicked，用户触击了一个链接。UIWebViewNavigationTypeFormSubmitted，用户提交了一个表单。UIWebViewNavigationTypeBackForward，用户触击前进或返回按钮。UIWebViewNavigationTypeReload，用户触击重新加载的按钮。UIWebViewNavigationTypeFormResubmitted，用户重复提交表单UIWebViewNavigationTypeOther，发生其它行为。并且不能所有在webView上发生的动作都靠scheme协议解析解决，只有在webView发生用户点击事件或者其他行为时我们才根据request.url进一步判断是否需要scheme解析，代码如下：12345678910111213141516-(BOOL)webView:(UIWebView *)webViewshouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType&#123;if (navigationType == UIWebViewNavigationTypeLinkClicked|| navigationType == UIWebViewNavigationTypeOther)&#123;if (([[request.URL scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[request.URL scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;[JumpURLHandle parseURL:request.URL];return NO;&#125;&#125;return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWebView认识]]></title>
      <url>%2F2017%2F03%2F04%2FUIWebView%E8%AE%A4%E8%AF%86%2F</url>
      <content type="text"><![CDATA[Objective-C和JavaScript相互调用 通过非框架的方式完成相互的调用OC调用JavaScript语言,通过UIWebView的下面方法来实现1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 该方法向UIWebView传递一段需要执行的JavaScript文件,来获得执行的结果JavaScript调用OC语言,利用UIWebView的特性:在UIWebView内发起的所有网络请求都可以通过delegte函数在原生界面得到通知,我们在UIWebView中发起一个特殊的网络请求,请求加载的网址内容通常不是真实的地址,地址往往类似这样:gap://methodname?argument在delegate的函数中,我们只需要发现是gap://开头地址,就不进行加载转而执行相应的调用逻辑.123456789101112-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;NSURL *url = [request url];if ([[url scheme] isEqualToString:@&quot;gap&quot;])&#123;//在这里做JavaScript调用oc的事情...//做完之后用以下方法调用JavaScript[webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;done&apos;)&quot;];return NO;&#125;return YES;&#125; 在UIWebView发起一个特殊的网络请求也有很多的办法,最合适的方式是一个临时的隐藏的iFrame,在iFrame中加载这个特殊的网络请求12345678910111213141516171819function loadURL(url)&#123;var iFrame;//创建一个临时的元素iframe = document.createElement(&quot;IFRAME&quot;);//设置临时元素的属性和属性值//添加属性,携带urliFrame.setAttribute(&quot;src&quot;,url);//设置style属性,并且隐藏元素iFrame.setAttribute(&quot;style&quot;,&quot;display: none;&quot;);iFrame.setAttribute(&quot;height&quot;,&quot;Opx&quot;);iFrame.setAttribute(&quot;width&quot;,&quot;Opx&quot;);//规定是否显示框架周围的边框。iFrame.setAttribute(&quot;frameborder&quot;,&quot;0&quot;);//添加属性到bodydocument.body.appendChild(iFrame);//发起请求后这个iFrame就没用了,所以需要把它从dom上移除掉iFrame.parentNode.removeChild(iFrame);iFrame = null;&#125; 当点击按钮的时候1&lt;button onclick=&quot;loadURL(&apos;abc&apos;)&quot;&gt;click&lt;/button&gt; ,通过调用这个function,就能够在1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 方法中截取到请求内容,从而判断来自于js的事件 WebViewJavascriptBridge的使用 iOS端如何使用1.开启日志12// 开启日志，方便调试[WebViewJavascriptBridge enableLogging]; 2.给ObjC与JS建立桥梁1234567给哪个webView建立js与objc的沟通桥梁self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];//代理的设置 这个地方,通过调用这个方法,将自己设置为代理,只是没有直接的通过.delegate来设置,而是通过调用WebViewJavascriptBridge的setWebViewDelegate:方法,都是将自己设为代理,不同的是,通过.delegate是直接将自己设置为代理,而通过调用WebViewJavascriptBridge的setWebViewDelegate,实现了在WebViewJavascriptBridge中将WebViewJavascriptBridge自身设置为真正的代理,完成对UIWebVieView的监听,而同时将代理的回调传递出去.这样就是同一对象的两个监听者[self.bridge setWebViewDelegate:self]; 3.注册HandleName，用于给JS端调用iOS端12345678910111213141516171819// JS主动调用OjbC的方法// 这是JS会调用getUserIdFromObjC方法，这是OC注册给JS调用的// JS需要回调，当然JS也可以传参数过来。data就是JS所传的参数，不一定需要传// OC端通过responseCallback回调JS端，JS就可以得到所需要的数据[self.bridge registerHandler:@&quot;getUserIdFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getUserIdFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;userId&quot;: @&quot;123456&quot;&#125;);&#125;&#125;];[self.bridge registerHandler:@&quot;getBlogNameFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getBlogNameFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;blogName&quot;: @&quot;颠倒碎碎念&quot;&#125;);&#125;&#125;]; JS端如何使用1.将下面的代码放在JS中123456789101112/*这段代码是固定的，必须要放到js中*///这段代码是固定的书写内容,将这段代码copy and paste到js当中function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&apos;iframe&apos;);WVJBIframe.style.display = &apos;none&apos;;WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 2.在下面的方法当中写相关的js代码:1234setupWebViewJavascriptBridge(function(bridge) &#123;/* Initialize your app here */所有与iOS交互的JS代码放这里！&#125;) 3.JS调用iOS代码通过bridge.callHandler来调用：123456bridge.callHandler(&apos;getBlogNameFromObjC&apos;,&#123;&apos;blogURL&apos;: &apos;http://www.huangyibiao.com&apos;&#125;,function callback(response) &#123;log(&apos;JS got response&apos;, response)&#125;&#125;) 其中的各个参数说明,getBlogNameFromObjC是iOS端注册的handleName,在iOS端也通过这个hanleName完成注册后JS直接通过这个handleName与iOS交互.比如,当点击按钮的时候就执行上面的操作,这样一来,js就将参数传递给了iOS端,iOS收到传递的参数然后通过回调给js.callback:js函数名,在iOS端收到回调后拿到了参数,然后通过闭包回调反馈给js端. 如何传递参数参数传递最简单的方式是将参数作为URL的一部分放到iFrame的src中.UIWebView通过截取分析URL后面的内容即可获得参数.但是,如果参数是一个很复杂的对象,那么这个URL的编码就会很复杂.对此可采取的方案是: 将参数以JSON的形式传递,但是因为要附加在URL之后,所以我们需要将JSON进行Base64编码,以保证URL中不会出现一些非法字符线程阻塞问题当在Objective-C语言中调用stringByEvaluatingJavaScriptFromString:方法必须在主线程执行,而主线程的执行时间过长会阻塞UI的更新.所以我们应该尽量让stringByEvaluatingJavaScriptFromString:方法执行时间短.像云笔记这样的App在保存笔记的时候,需要调用JavaScript代码来获得笔记的完整HTML内容,这个时候,如果笔记内容很复杂,就会执行很长的一段时间,而因为这个操作必须是主线程执行,所以我们要显示”正在保存”的UIAlertView完全无法正常显示,整个UI界面就完全卡主了,所以,这个时候,就需要更新获取HTML内容的代码,来缩短这个执行时长.使用Safari进行调试苹果支持用Safari浏览器直接连接到模拟器或者真机来进行相关HTML页面,以及JavaScript逻辑的调试. 打开Safari的调试模式,选择 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 勾选 “在菜单栏中显示开发菜单”2.同时需要在iPhone模拟器或真机的设置上把调试模式打开, 设置 -&gt; Safari -&gt; 高级 -&gt; 打开Web检查器3.重启Safari,在Safari的”开发”菜单下,就多出了对应的菜单选项我们可以在Safari中直接修改HTML代码,css效果,以及调试JavaScript.所有的效果都可以立即在UIWebView上看到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5学习第二天]]></title>
      <url>%2F2017%2F03%2F03%2FHTML5%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[盒子模型 属性每个盒子模型都有四个属性 内容(content)填充(内边距,padding)边框(border)边界(margin,外边距)标准盒子模型图内容属性heightmax-heightmin-heightwidthmax-widthmin-width填充属性(内边距,padding)paddingpadding-bottompadding-leftpadding-rightpadding-top举例子:内边距1234padding: 10px 5px 15px 10px; 设置上,左,下,右内边距padding: 10px 5px 15px; 设置上,左右,下边距padding: 10px 5px; 设置上下,左右边距padding: 10px; 设置上下左右边距边框(border):设置4个边框的样式123p&#123;border: 5px solid red;&#125;border简写属性在一个声明设置所有的边框属性可以按顺序设置如下属性:border-widthborder-styleborder-color设置边框设置: border-radius边界(margin,外边距)marginmargin-topmargin-bottommargin-leftmargin-right1234margin: 10px 5px 15px 10px; 设置上,左,下,右外边距margin: 10px 5px 15px; 设置上,左右,外边距margin: 10px 5px; 设置上下,左右外边距margin: 10px; 设置上下左右外边距CSS3新增特性RGBA透明度1&lt;div style=&quot;width: 100px; background-color: rgba(255,0,0,1)&quot;&gt;看我的效果&lt;/div&gt;看我的效果块阴影值说明:h-shadow必需。水平阴影的位置。允许负值。v-shadow必需。垂直阴影的位置。允许负值。blur可选。模糊距离。spread可选。阴影的尺寸。color可选。阴影的颜色。请参阅 CSS 颜色值。inset可选。将外部阴影 (outset) 改为内部阴影。12//设置的顺序以此为: 水平阴影, 垂直阴影, 阴影的模糊距离,以及阴影的颜色&lt;div style=&quot;width: 100px; height: 25px; box-shadow: 5px 5px 10px black;&quot;&gt;我是盒子&lt;/div&gt;我是盒子文字阴影在设置参数上与块阴影是一样的1&lt;p style=&quot;font-size: 20px; color: aqua; text-shadow: 5px 5px 10px black&quot;&gt;我看着你呢&lt;/p&gt;我看着你呢圆角 borderradius我变成了圆圆的了CSS布局默认情况下,所有的网页的布局都在标准流布局中: 从上到下,从左到右脱离标准流的方法有float属性position属性和left right top bottom属性floatfloat 属性的常用取值有left: 脱离标准流,浮动到父标签的最左边right: 脱离标准流,浮动到父标签的最右边 具体有关float CSS浮动 可查看W3School的这篇文章 通过float修改首字母样式12345678910&lt;p&gt;&lt;span style=&quot;float: left; width: 0.7em; font-size: 400%; font-family:algerian,courier; line-height:80%;&quot;&gt;T&lt;/span&gt;his is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.&lt;/p&gt; This is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text. position属性具体有关position 可查看W3School的这篇文章通常positon属性结合left top bottom right属性使用 值描述absolute生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit规定应该从父元素继承 position 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习第一天]]></title>
      <url>%2F2017%2F03%2F02%2FHTML%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[HTML5 基础介绍 2014年制定完HTML5标准 利用HTML5编写的UI能够运行在所有的浏览器的平台 手机APP的开发模式: 原生 纯HTML5 原生 + HTML5 自动更新 Web3.0 : HTML5 + CSS3 HTML5: Canvas HTML5音视频 Web存储 Geolocation Workers多线程处理 CSS3亮点: 设计动画 2D变形 一个完整的网页由三部分组成： HTML CSS JavaScript W3school HTML的常见使用 HTML： 超文本标记语言 浏览器负责将它解析成具体的网页内容，HTML语言是松散的 WebStorm的使用： 注释快捷键：command + / 线条： 1\&lt;hr&gt; 输入 1&lt;input placeholder=&quot;我是占位文字&quot;&gt; 1&lt;input value=&quot;我是默认的文字&quot;&gt; 1&lt;input type=&quot;date&quot;&gt; 1&lt;input type=&quot;file&quot;&gt; 1&lt;input type=&quot;color&quot;&gt; 1&lt;input type=&quot;radio&quot;&gt; 1&lt;input type=&quot;checkbox&quot;&gt; 图片标签 alt: 图片显示失败的时候，显示的文字提示 1&lt;img src=&quot;abc.jpg&quot; alt=&quot;这是一张图片&quot;&gt; 12&lt;!—相对路径--&gt;&lt;img src=&quot;image/IMG_0084.png&quot;&gt; 12&lt;!—绝对路径 固定了宽，高会按比例自动缩放—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;100&quot;&gt; 12&lt;!—绝对路径 设置宽与父元素的比例，这样能更好的适配，相对于设置固定的宽度—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;50%&quot;&gt; 换行标签 1&lt;br&gt; 列表标签 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 无序列表 无序列表 无序列表 无序列表 无序列表 无序列表 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 有序列表 有序列表 有序列表 有序列表 有序列表 超链接 1&lt;a target=&quot;_self&quot; href=&quot;https://www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_blank&quot; href=&quot;https:www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_top&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt; 回到顶部 1&lt;meter value=&quot;30&quot; max=&quot;100&quot; min=&quot;0&quot;&gt;30%&lt;/meter&gt; 30% 1&lt;progress value=&quot;40&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 1&lt;audio src=&quot;../audio/music.m4a&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 视频图片1&lt;video src=&quot;http://player.youku.com/player.php/Type/Folder/Fid//Ob//sid/XMjU1MjMwMDAzNg==/v.swf&quot;&gt;&lt;/video&gt; CSS CSS的使用样式 行内样式 页内样式 外部样式 行内样式1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的行内样式&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;background-color: red;&quot;&gt;//style作为元素的一个属性，将所有样式的样式写在style属性当中 &lt;div style=&quot;color: blue; font-size: 18px; background-color: aqua;&quot;&gt;我是容器标签&lt;/div&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px double purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px solid purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px dashed purple;&quot;&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 页内样式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的页内样式&lt;/title&gt; &lt;link href=&quot;css/index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- css规律: 就近原则 叠加原则 --&gt; //在head标签当中写标签样式，样式写在&lt;style&gt;&lt;/style&gt;当中 &lt;style&gt; div&#123; color: red; font-size: 30px; border: 4px solid yellow; &#125; p&#123; color: blue; font-size: 44px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外部样式1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css外部样式&lt;/title&gt; //链接外部css文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css中的内容1234567891011div&#123; color: olivedrab; font-size: 66px; background-color: green;&#125;p&#123; color: goldenrod; font-size: 2px; border: 2px solid red;&#125; CSS选择器 标签选择器 12345&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;div&#123; color: red; &#125; 类选择器12345678&lt;p class=&quot;high&quot;&gt;第一段文子&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;div class=&quot;high&quot;&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;// . + 类名.high &#123; color: red; &#125; ID选择器123456css: #main &#123; color: gray&#125;html: &lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt; 并列选择器1234567css: 用逗号(,)隔开div , .test1 &#123; color: red;&#125;html: 以下两者都满足&lt;div&gt;我是div&lt;/div&gt;&lt;p class=&quot;test1&quot;&gt;我是段落&lt;/p&gt; 123456css: id值为main，或者class值为test1#main , .test1 &#123;&#125;html: 以下两者都满足&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 复活选择器12345css: div标签并且必须类值为test1div.test1&#123;&#125;html:&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 后代选择器123456css: div中的p标签（包括子类和孙子类）div p &#123;&#125;html: 以下两个都满足&lt;div&gt;&lt;p&gt;我满足条件&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;h2&gt;&lt;p&gt;我也满足&lt;/p&gt;&lt;/h2&gt;&lt;/div&gt; 直接后代选择器12345css: div &gt; a &#123;&#125;html:&lt;div&gt;&lt;a href=&quot;#&quot;&gt;我满足&lt;/a&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;我不满足😌&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 属性选择器123456css:div[name]&#123;&#125;html:&lt;div name=&quot;jack&quot;&gt;我满足&lt;/div&gt;&lt;div name=&quot;rose&quot;&gt;我也满足&lt;/div&gt;&lt;div age=&quot;23&quot;&gt;我不满足&lt;/div&gt; 特定属性值选择器12345css:div[name=&quot;jack&quot;]&#123;&#125;html:&lt;div name=&quot;rose&quot;&gt;我不😌&lt;/div&gt;&lt;div name=&quot;jack&quot;&gt;我满足😄&lt;/div&gt; 伪类1234567891011121314151617css: /*触发某些操作的时候更改一些样式*/input:focus &#123;/*去除外线条*/outline: none;height: 50px;font-size: 20px;&#125;/*当鼠标移动上来*/#main:hover&#123;width: 300px;height: 200px;background-color: aqua;&#125;html:&lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt;&lt;input placeholder=&quot;我是输入框&quot;&gt; 伪元素/伪元素 比如段落的第一个字母变大,可以通过伪元素实现/ 选择器优先级选择器的权值： 通配选择符(*) : 0 标签: 1 类: 10 属性：10 伪类： 10 伪元素: 10 id: 100 important: 1000 原则： 选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 优先级顺序： important &gt; 内联（行内style）&gt;id&gt;类|伪类|伪元素|属性|伪元素&gt;标签&gt;统配选择符 HTML标签的分类和修改 标签的分类 块级标签 独占一行，能够通过css修改高度(div、p、h1、h2、ul、li…) 行内标签（内联标签） 多个行内标签能同时显示在一行，并且无法修改其宽高 宽度和高度取决于内容的尺寸 (span、a、label….) 行内-块级标签 (内联-块级标签) 多个行类块级标签能够显示在一行 :具备了内联标签的特点 能够设置宽度和高度(input, button) : 具备了块级标签的特点修改标签的显示类型通过css中的display属性，能够修改显示的类型 none: 隐藏标签 block: 让标签变成块级标签 inline: 让标签变成内联标签 inline-block: 让标签变成内联-块级标签 其他属性介绍cursor： 🖱鼠标样式text-decoration:规定添加到文本的修饰123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;h1 &#123;text-decoration: overline&#125;h2 &#123;text-decoration: line-through&#125;h3 &#123;text-decoration: underline&#125;h4 &#123;text-decoration: blink&#125;a &#123;text-decoration: none&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是标题 1&lt;/h1&gt;&lt;h2&gt;这是标题 2&lt;/h2&gt;&lt;h3&gt;这是标题 3&lt;/h3&gt;&lt;h4&gt;这是标题 4&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn/index.html&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; line-through: 看我overline:看我underline:看我blink:看我 用text-decoration去掉超链接的下划线 这是一个超链接，但是没有下划线，因为我有值为none的text-decoration呀 text-indent将段落的第一行缩进 50 像素：1234css:p&#123; text-indent:50px;&#125; list-style:把图像设置为列表中的列表项目标记：1234css:ul&#123; list-style:square inside url(&apos;/i/arrow.gif&apos;); &#125; 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;ul &#123;list-style: square inside url(&apos;/i/eg_arrow.gif&apos;)&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 可以按顺序设置如下属性： list-style-type list-style-position list-style-imag overflow: 在宽高固定的情况下，内容超出的时候的显示样式123456div &#123; width:150px; height:150px; overflow:scroll; &#125; 默认值： visible可能的值值 描述visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWindow笔记]]></title>
      <url>%2F2017%2F03%2F02%2FUIWindow%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UIWindow更多的时候只作为UIView的顶层容器存在 UIWindow的主要作用有： 作为UIView的最顶层容器，包含应用所需要的所有的UIView 传递触摸消息和键盘事件给UIView 为UIWindow增加UIView 因为其本身是UIView的子类，所以可以调用addSubView方法 通过设置其特有的rootViewController属性。 通过设置其属性添加view对应的UIViewController，UIWindow自动将其view添加到当前window中。同时负责维护ViewController和view的生命周期。 系统对UIWindow的使用 调用系统的控件时(UIAlertView)，iOS系统为了保证UIAlertView在所有的界面之上，它会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置得更高，让UIAlertView盖在所有的应用界面之上 WindowLevel UIWindow的UIWindowLevel属性，定义了UIWindow的层级 UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal; UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert; UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar 通过代码将这些值输出： NSLog(@&quot;UIWindowLevelAlert - %lf ,UIWindowLevelNormal %lf, UIWindowLevelStatusBar %lf&quot;,UIWindowLevelAlert,UIWindowLevelNormal,UIWindowLevelStatusBar); 输出的结果为： UIWindowLevelAlert - 2000.000000 ,UIWindowLevelNormal 0.000000, UIWindowLevelStatusBar 1000.000000 默认的UIWindow层级为UIWindowLevelNormal，当系统需要在其上面覆盖UIAlerView时，创建一个UIWindowLevelAlert层级的UIWindow 手工创建UIWindow 创建UIWindow和UIView不同的是，一旦被创建，它会自动的被添加到界面上。 @interface ViewController () { UIWindow *_uiwindow; } @end - (IBAction)click:(id)sender { _uiwindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; //设置其层级 _uiwindow.windowLevel = UIWindowLevelNormal; _uiwindow.backgroundColor = [UIColor redColor]; _uiwindow.hidden = NO; UIGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] init]; [gesture addTarget:self action:@selector(hideWindow:)]; [_uiwindow addGestureRecognizer:gesture]; } -(void)hideWindow:(UIGestureRecognizer *)gesture{ _uiwindow.hidden = YES; //移除的方式就是清空 _uiwindow = nil; } 作者(唐巧)在做有道云笔记时，想做一个密码保护功能，当用户从应用的任何界面按Home键退出，过一段时间再从后台换回来时，显示一个密码输入界面。这个密码界面可能从任何应用界面弹出，并且需要盖在所有界面的最上层，它很适合用一个UIWindow来实现 #import &lt;UIKit/UIKit.h&gt; @interface PasswordInputWindow : UIWindow -(void)show; +(instancetype)sharedInstance; @end #import &quot;PasswordInputWindow.h&quot; @implementation PasswordInputWindow{ UITextField *_textField; } +(instancetype)sharedInstance{ //更改其生命周期 static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] initWithFrame:[UIScreen mainScreen].bounds]; }); return sharedInstance; } -(instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 50, 200, 20)]; label.text = @&quot;请输入密码&quot;; [self addSubview:label]; UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 80, 200, 20)]; textField.backgroundColor = [UIColor whiteColor]; //密码输入时单个显示 textField.secureTextEntry = YES; [self addSubview:textField]; UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(10, 110, 200, 44)]; [button setBackgroundColor:[UIColor blueColor]]; button.titleLabel.textColor = [UIColor blackColor]; [button setTitle:@&quot;确定&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(completeButtonPressed) forControlEvents:UIControlEventTouchUpInside]; self.backgroundColor = [UIColor yellowColor]; [self addSubview:button]; _textField = textField; } return self; } -(void)show{ //使其成为主窗口，调用这个方法就让当前窗口成为主窗口 [self makeKeyWindow]; self.hidden = NO; } -(void)completeButtonPressed{ if ([_textField.text isEqualToString:@&quot;abcd&quot;]) { //关闭键盘 [_textField resignFirstResponder]; //辞去主窗口 [self resignKeyWindow]; self.hidden = YES; }else{ [self showErrorAlertView]; } } -(void)showErrorAlertView{ UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:@&quot;密码 错误，正确密码是abcd&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil]; [alertView show]; } @end 只需要在应用进入后台的回调函数中，将该UIWindow创建显示出来即可 - (void)applicationDidEnterBackground:(UIApplication *)application { [[PasswordInputWindow sharedInstance] show]; } 需要注意的是，如果我们创建的window需要处理键盘事件，那就需要合理的将其设置为keyWindow.keyWindow是被系统设计用来接收键盘和其他非触摸事件的UIWindow。通过makeKeyWindow和resignKeyWindow来将自己的window设置为keyWindow，以及辞去keyWindow，]]></content>
    </entry>

    
  
  
</search>
