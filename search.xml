<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[HTML学习第一天]]></title>
      <url>%2F2017%2F03%2F02%2FHTML%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[2014年制定完HTML5标准利用HTML5编写的UI能够运行在所有的浏览器的平台 手机APP的开发模式： 原生 纯HTML5 原生 + HTML5 自动更新 Web3.0 :HTML5 + CSS3 HTML5: Canvas HTML5音视频 Web存储 Geolocation Workers多线程处理 CSS3亮点: 设计动画 2D变形 一个完整的网页由三部分组成： HTML CSS JavaScript W3school HTML： 超文本标记语言 浏览器负责将它解析成具体的网页内容，HTML语言是松散的WebStorm的使用： 注释快捷键：command + / 线条： 1\&lt;hr&gt; 输入： 123 &lt;input placeholder=&quot;我是占位文字&quot;&gt; ``` &lt;input placeholder=&quot;我是占位文字&quot;&gt; 1234&lt;input value=&quot;我是默认的文字&quot;&gt; ```&lt;input type=&quot;date&quot;&gt; type="file">``` 1234 &lt;input type=&quot;file&quot;&gt; ```&lt;input type=&quot;color&quot;&gt; type="radio">```1234 &lt;input type=&quot;radio&quot;&gt; ```&lt;input type=&quot;checkbox&quot;&gt; 图片标签 alt: 图片显示失败的时候，显示的文字提示 1&lt;img src=&quot;abc.jpg&quot; alt=&quot;这是一张图片&quot;&gt; 12&lt;!—相对路径--&gt;&lt;img src=&quot;image/IMG_0084.png&quot;&gt; 12&lt;!—绝对路径 固定了宽，高会按比例自动缩放—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;100&quot;&gt; 12&lt;!—绝对路径 设置宽与父元素的比例，这样能更好的适配，相对于设置固定的宽度—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;50%&quot;&gt; 换行标签 1234567891011121314151617181920**列表标签**```&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;/ul&gt;``` &lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;/ul&gt; &lt;ol type=&quot;&quot;&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;/ol&gt; 12345678910 &lt;ol type=&quot;&quot;&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;li&gt;有序列表&lt;/li&gt; &lt;/ol&gt; **超链接** &lt;!—超链接标签–&gt;&lt;!—当前的窗口跳转–&gt; 我是超链接 12 &lt;a target=&quot;_self&quot; href=&quot;https:baidu.com&quot;&gt;我是超链接&lt;/a&gt; &lt;!—超链接标签–&gt;&lt;!—当前的窗口跳转–&gt; 我是超链接12&lt;a target=&quot;_blank&quot; href=&quot;https:baidu.com&quot;&gt;我是超链接&lt;/a&gt; &lt;!--回到顶部--&gt; 回到顶部12&lt;a target=&quot;_top&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt; 30%12&lt;meter value=&quot;30&quot; max=&quot;100&quot; min=&quot;0&quot;&gt;30%&lt;/meter&gt; ```]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWindow笔记]]></title>
      <url>%2F2017%2F03%2F02%2FUIWindow%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UIWindow更多的时候只作为UIView的顶层容器存在 UIWindow的主要作用有： 作为UIView的最顶层容器，包含应用所需要的所有的UIView 传递触摸消息和键盘事件给UIView 为UIWindow增加UIView 因为其本身是UIView的子类，所以可以调用addSubView方法 通过设置其特有的rootViewController属性。 通过设置其属性添加view对应的UIViewController，UIWindow自动将其view添加到当前window中。同时负责维护ViewController和view的生命周期。 系统对UIWindow的使用 调用系统的控件时(UIAlertView)，iOS系统为了保证UIAlertView在所有的界面之上，它会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置得更高，让UIAlertView盖在所有的应用界面之上 WindowLevel UIWindow的UIWindowLevel属性，定义了UIWindow的层级 UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal; UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert; UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar 通过代码将这些值输出： NSLog(@&quot;UIWindowLevelAlert - %lf ,UIWindowLevelNormal %lf, UIWindowLevelStatusBar %lf&quot;,UIWindowLevelAlert,UIWindowLevelNormal,UIWindowLevelStatusBar); 输出的结果为： UIWindowLevelAlert - 2000.000000 ,UIWindowLevelNormal 0.000000, UIWindowLevelStatusBar 1000.000000 默认的UIWindow层级为UIWindowLevelNormal，当系统需要在其上面覆盖UIAlerView时，创建一个UIWindowLevelAlert层级的UIWindow 手工创建UIWindow 创建UIWindow和UIView不同的是，一旦被创建，它会自动的被添加到界面上。 @interface ViewController () { UIWindow *_uiwindow; } @end - (IBAction)click:(id)sender { _uiwindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; //设置其层级 _uiwindow.windowLevel = UIWindowLevelNormal; _uiwindow.backgroundColor = [UIColor redColor]; _uiwindow.hidden = NO; UIGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] init]; [gesture addTarget:self action:@selector(hideWindow:)]; [_uiwindow addGestureRecognizer:gesture]; } -(void)hideWindow:(UIGestureRecognizer *)gesture{ _uiwindow.hidden = YES; //移除的方式就是清空 _uiwindow = nil; } 作者(唐巧)在做有道云笔记时，想做一个密码保护功能，当用户从应用的任何界面按Home键退出，过一段时间再从后台换回来时，显示一个密码输入界面。这个密码界面可能从任何应用界面弹出，并且需要盖在所有界面的最上层，它很适合用一个UIWindow来实现 #import &lt;UIKit/UIKit.h&gt; @interface PasswordInputWindow : UIWindow -(void)show; +(instancetype)sharedInstance; @end #import &quot;PasswordInputWindow.h&quot; @implementation PasswordInputWindow{ UITextField *_textField; } +(instancetype)sharedInstance{ //更改其生命周期 static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] initWithFrame:[UIScreen mainScreen].bounds]; }); return sharedInstance; } -(instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 50, 200, 20)]; label.text = @&quot;请输入密码&quot;; [self addSubview:label]; UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 80, 200, 20)]; textField.backgroundColor = [UIColor whiteColor]; //密码输入时单个显示 textField.secureTextEntry = YES; [self addSubview:textField]; UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(10, 110, 200, 44)]; [button setBackgroundColor:[UIColor blueColor]]; button.titleLabel.textColor = [UIColor blackColor]; [button setTitle:@&quot;确定&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(completeButtonPressed) forControlEvents:UIControlEventTouchUpInside]; self.backgroundColor = [UIColor yellowColor]; [self addSubview:button]; _textField = textField; } return self; } -(void)show{ //使其成为主窗口，调用这个方法就让当前窗口成为主窗口 [self makeKeyWindow]; self.hidden = NO; } -(void)completeButtonPressed{ if ([_textField.text isEqualToString:@&quot;abcd&quot;]) { //关闭键盘 [_textField resignFirstResponder]; //辞去主窗口 [self resignKeyWindow]; self.hidden = YES; }else{ [self showErrorAlertView]; } } -(void)showErrorAlertView{ UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:@&quot;密码 错误，正确密码是abcd&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil]; [alertView show]; } @end 只需要在应用进入后台的回调函数中，将该UIWindow创建显示出来即可 - (void)applicationDidEnterBackground:(UIApplication *)application { [[PasswordInputWindow sharedInstance] show]; } 需要注意的是，如果我们创建的window需要处理键盘事件，那就需要合理的将其设置为keyWindow.keyWindow是被系统设计用来接收键盘和其他非触摸事件的UIWindow。通过makeKeyWindow和resignKeyWindow来将自己的window设置为keyWindow，以及辞去keyWindow，]]></content>
    </entry>

    
  
  
</search>
