<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[我的博客]]></title>
      <url>%2F2017%2F11%2F20%2Ftest%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[ps笔记]]></title>
      <url>%2F2017%2F04%2F22%2Fps%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[图层的操作: 1.按住空格键不松，无论选择什么工具，都会切换为抓手工具来移动视图2.按住抓手工具不松，可以出现抓手工具和旋转视图工具3.在选取状态下,shift + 左键，画出正方形的选取。移动选取交点到中心位置，按住option键，按住左键，以中心位置为选取的中心点缩放]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习4.8]]></title>
      <url>%2F2017%2F04%2F08%2FHTML%E5%AD%A6%E4%B9%A04-8%2F</url>
      <content type="text"><![CDATA[1.control + shift + k : 删除一行command + 单击： 集体输入command + / : 注释command + L :快速选中一行 2.1&lt;br /&gt;不会生成空白行 3.1&lt;strong&gt;加粗&lt;/strong&gt; 4.1&lt;em&gt;我是歪的吗&lt;/em&gt; : 倾斜标签 5.1&lt;del&gt;1000.00&lt;/del&gt;: 删除标签 6.1&lt;ins&gt;下划线&lt;/ins&gt; : 下划线 7.12&lt;img src=&quot;Snip20170314_1.png&quot; alt=&quot;我是显示不出来的图片&quot; title=&quot;我的男神&quot;/&gt; : title:鼠标停留在图片上时显示的文字当不写宽高的时候，以图片本身的宽高显示。如果单独的设置宽或者高，那么图片就会等比缩放 8.12345相对路径和绝对路径相对路径：相对于文件自身出发:文件和图片在同一个目录下(文件夹)，直接写文件名图片在文件的上一级目录里，../+图片名字绝对路径： 9.1234567&lt;a href=&quot;常用快捷键.html&quot;&gt;点击我吧？&lt;/a&gt;href: 去往哪里？src: 从哪里来？target:页面打开方式title: 提示文字 鼠标放在链接上显示的文字target=&quot;_self&quot; : 默认值，在自身页面打开target-&quot;_blank&quot; : 在新的页面打开 10.12锚链接&lt;p id=&quot;锚点&quot;&gt;&lt;a href=&quot;#锚点&quot;&gt;&lt;/a&gt;&lt;/p&gt; 11.12空链: #&lt;a href=&quot;#&quot;&gt;空链&lt;/a&gt; 123超链接的优化写法base:&lt;base target=&quot;_blank&quot;&gt; 13.12空格：&amp;nbsp; 14.12小于号： &amp;lt;大于号： &amp;gt; 15. 16.12345678910无序列表&lt;ul&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;/ul&gt;type=&quot;square&quot; 小方块type=&quot;disc&quot; 实心圆type=&quot;circle&quot; 空心圆 肯定不是呀肯定不是呀肯定不是呀肯定不是呀 17.1234567891011有序列表&lt;ol&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;li&gt;肯定不是呀&lt;/li&gt;&lt;/ol&gt;type=&quot;1&quot;type=&quot;a&quot;type=&quot;A&quot;type=&quot;I&quot; 肯定不是呀 肯定不是呀 肯定不是呀 肯定不是呀18.123456自定义列表&lt;dl&gt;&lt;dt&gt;帮助中心&lt;/dt&gt;&lt;dd&gt;账户管理&lt;/dd&gt;&lt;dd&gt;购物指南&lt;/dd&gt;&lt;/dl&gt; 19.12345678910meta:解码方式：charset: 编码关键字：&lt;meta name=&quot;keywords&quot; content=&quot;xxx&quot;&gt;网页描述&lt;meta name=&quot;description&quot; content=&quot;xxx&quot;&gt;网页重定向&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; http://www.baidu.com&quot;&gt; 20.12icon图标&lt;link rel=&quot;icon&quot; href=&quot;xxx.ico&quot;&gt; 21.12345678910111213141516表格&lt;table border=&quot;1&quot; width=&quot;500&quot; height=&quot;300&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10&quot; align=&quot;center&quot; bgcolor=&quot;yellow&quot;&gt; &lt;tr&gt; //行 &lt;td&gt;&lt;/td&gt; //列（单元格） &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;table的属性border: 边框 cellspacing：单元格之间的间距 cellpadding：单元格内容的边距(内边距) align:table的对齐方式 bgcolor: table的背景色如果给tr或者td使用align=&quot;center&quot;: 是使得内容居中 22.123456&lt;table&gt; &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;caption&gt;&lt;/caption&gt; ：表头 23.12合并单元格rowspan colspan 24.123456789101112&lt;table border=&quot;2&quot; bordercolor=&quot;red&quot; width=&quot;200&quot; height=&quot;100&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;战三&lt;/th&gt; &lt;th&gt;20&lt;/th&gt; &lt;th&gt;大前端&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;大前端&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 25.12345678细线表格&lt;table width=&quot;200&quot; height=&quot;100&quot; bgcolor=&quot;green&quot; cellspacing=&quot;1&quot;&gt; &lt;tr bgcolor=&quot;white&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 26.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;table width=&quot;300&quot; height=&quot;200&quot; bgcolor=&quot;green&quot; cellspacing=&quot;1&quot; align=&quot;center&quot;&gt;&lt;caption&gt;课程表&lt;/caption&gt;&lt;tr bgcolor=&quot;white&quot;&gt;&lt;th width=&quot;80&quot; colspan=&quot;2&quot;&gt;&lt;/th&gt;&lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;&lt;th&gt;星期一&lt;/th&gt;&lt;th&gt;星期二&lt;/th&gt;&lt;th&gt;星期三&lt;/th&gt;&lt;th&gt;星期四&lt;/th&gt;&lt;th&gt;星期五&lt;/th&gt;&lt;/tr&gt;&lt;tr bgcolor=&quot;white&quot;&gt;&lt;td rowspan=&quot;2&quot; width=&quot;50&quot;&gt;上午&lt;/td&gt;&lt;td width=&quot;30&quot;&gt;1&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr bgcolor=&quot;white&quot;&gt;&lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;数学&lt;/td&gt;&lt;td&gt;物理&lt;/td&gt;&lt;td&gt;化学&lt;/td&gt;&lt;td&gt;生物&lt;/td&gt;&lt;/tr&gt;&lt;tr bgcolor=&quot;white&quot;&gt;&lt;td rowspan=&quot;2&quot; height=&quot;50&quot;&gt;下午&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;tr bgcolor=&quot;white&quot;&gt;&lt;!-- &lt;td&gt;&lt;/td&gt; --&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 27.12345678910111213&lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt;用户名&lt;input type=&quot;text&quot; maxlength=&quot;6&quot; readonly=&quot;readonly&quot;&gt;密&amp;nbsp;码&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;input属性说明:name=&quot;username&quot;: 区分不同的输入框用于提交value=&quot;大前端&quot;:(默认值) 提交到服务器，是传到服务器的值maxlength: 限制输入的最大长度readonly=&quot;readonly&quot;: 读写权限：只读权限（不能编辑）disabled=&quot;disabled&quot;: 未激活 用户名密&nbsp;码 28.1234//在这里，当将两个的name的值设置相同的时候，才能够实现单选效果。//checked=&quot;checked&quot;: 设置默认选中项&lt;input type=&quot;radio&quot; name=&quot;gender&quot; checked=&quot;checked&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女男女29.12345678910111213141516171819202122232425262728//下拉菜单//selected=&quot;selected&quot;: 设置默认选中项省(市): &lt;select&gt;&lt;option&gt;河北&lt;/option&gt;&lt;option&gt;山西&lt;/option&gt;&lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt;&lt;/select&gt;//mutiple=&quot;mutiple&quot;: 设置为可以多选&lt;select mutiple=&quot;mutiple&quot;&gt;&lt;option&gt;河北&lt;/option&gt;&lt;option&gt;山西&lt;/option&gt;&lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt;&lt;/select&gt;//分组的下拉菜单//label: 分组标签&lt;select&gt;&lt;optgroup label=&quot;成都市&quot;&gt;&lt;option&gt;锦江区&lt;/option&gt;&lt;option&gt;武侯区&lt;/option&gt;&lt;option&gt;青羊区&lt;/option&gt;&lt;/optgroup&gt;&lt;optgroup label=&quot;北京市&quot;&gt;&lt;option&gt;海淀区&lt;/option&gt;&lt;option&gt;朝阳区&lt;/option&gt;&lt;option&gt;昌平区&lt;/option&gt;&lt;/optgroup&gt;&lt;/select&gt;省(市): 河北山西北京河北山西北京锦江区武侯区青羊区海淀区朝阳区昌平区30.12345//多选框//checked=&quot;checked&quot; 设置为默认选中&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;喝酒&lt;input type=&quot;checkbox&quot;&gt;抽烟&lt;input type=&quot;checkbox&quot;&gt;烫头喝酒抽烟烫头31.12//重置按钮&lt;input type=&quot;reset&quot;&gt;32.1234567&lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt;&lt;!-- /网址控件 --&gt;&lt;input type=&quot;url&quot;&gt;&lt;!-- 日期控件 --&gt;&lt;input type=&quot;date&quot;&gt;&lt;input type=&quot;submit&quot;&gt; &lt;/form&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发中ReactiveCocoa的使用]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%BC%80%E5%8F%91%E4%B8%ADReactiveCocoa%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[RAC亮点:数据与视图的绑定，当数据变化的时候，视图不需要做额外的处理，便可正确地呈现最新的数据 ReactiveCocoa结合了几种编程风格： 函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。 响应式编程（Reactive Programming）：关注于数据流和变化传播。 所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[精妙的文本布局]]></title>
      <url>%2F2017%2F04%2F01%2F%E7%B2%BE%E5%A6%99%E7%9A%84%E6%96%87%E6%9C%AC%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[曾经需要用底层的Core Text才能做的高级布局现在可以直接用UIKit处理了。 理解富文本 字符与字形 NSString 是字符集合，每个字符用一个唯一的Unicode值表示。 任何的”我”出现在字符串中，其数值都是一样的。下面这张图，每个”我”的字符值都是一样的，但它们的形状却大不相同,这些形状被称为字形 字体主要是映射到字符的字形的集合，不过不是一对一的映射。很多情况下，一种字体可以有多种字形来表示给定的字符。 对于给定的字符串，字符数也可能和字形数不同。导致这种区别的常见原因是连子，也就是多个字符连成单个的字形。 有些连字和字体有关，是为提高可读性而设计的。英文中常见的是f-i连字。如图所示。注意i上面的点是如何消失的，这是字体有意为之的特性，两个字符绘制成单个的字形 理解字体字体是字形的集合，以及如何选择和放置字形的集合。字体是可扩展的，所以Baskerville 18pt和Baskerville 28pt只是同一字体的两种尺寸。不过Baskerville的斜体和粗体则是完全不同的字体。 这里的关键是当你需要”把字体加粗”的时候，其实需要的是当前字体的加粗字体。系统可能没有这样的字体，也可能有好几个字体。比如有些字体会有粗体、半粗体、特粗体等变体。所以加粗和斜体就是选择字体。 下划线和删除线则是装饰。装饰会修改现存字体，而添加下划线字体不会变，字形不会变。系统只是👉额外👈的画了一条线。 段落样式段落样式不会修改字体或者字形选择，而只是修改字形的位置。段落样式可能包含对齐、缩进和方向，这些信息表明字形是如何水平布局的。段落样式还可能包含行间距和段间距，表明字形如何垂直布局。 属性化字符串属性话字符串把字符和字符串中某个范围的元数据组合在一起。 属性化字符串的一种方法：123456789101112131415161718NSString *string = @&quot;Be Bold!And a little color wouldn&apos;t hurt either.&quot;;NSDictionary *attrs = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:36]&#125;;//NSString -&gt; AttributedString//字符串转为带属性的字符串//创建了一个可变的属性化字符串NSMutableAttributedString *as = [[NSMutableAttributedString alloc] initWithString:string attributes:attrs];//添加属性[as addAttribute:NSFontAttributeName value:[UIFont boldSystemFontOfSize:36] range:[string rangeOfString:@&quot;Bold!&quot;]];[as addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:[string rangeOfString:@&quot;little color&quot;]];[as addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:18] range:[string rangeOfString:@&quot;little&quot;]];[as addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;Papyrus&quot; size:36] range:[string rangeOfString:@&quot;color&quot;]];UILabel *lbl = [[UILabel alloc] init];lbl.attributedText = as;lbl.textColor = [UIColor redColor];[lbl sizeToFit];[self.view addSubview:lbl]; 用字体描述符选择字体寻找字体的主要工具是字体描述符。UIFontDescriptor提供了从系统中请求字体的多种方法，也是序列化字体信息的首选对象。👉字体描述符的常见用处是寻找👀相关字体👀。👈在下面的例子中，你会打开上节中创建的属性化字符串的斜体：1234567891011121314-(IBAction)toggleItalic:(id)sender&#123;NSMutableAttributedString *as = [self.label.attributedText mutableCopy];[as enumerateAttribute:NSFontAttributeName inRange:NSMakeRange(0, as.length) options:0 usingBlock:^(id _Nullable value, NSRange range, BOOL * _Nonnull stop) &#123;UIFont *font = value;UIFontDescriptor* descriptor = font.fontDescriptor;//symbolicTraits符号特征UIFontDescriptorSymbolicTraits traits = descriptor.symbolicTraits ^ UIFontDescriptorTraitItalic;UIFontDescriptor *toggledDescriptor = [descriptor fontDescriptorWithSymbolicTraits:traits];UIFont *italicFont = [UIFont fontWithDescriptor:toggledDescriptor size:0];[as addAttribute:NSFontAttributeName value:italicFont range:range];self.label.attributedText = as;&#125;];&#125; NSAttributedString的enumerateAttribute:inRange:usingBlock:是对被遍历字符串的连续文本做循环有用的方法。给定的属性一旦变化，块会被调用。在这个块中，我们从字体获取到字体描述符，然后打开”斜体”符号特征。接着为字体描述符找到新的字体并应用到范围中。效果图如下 也可以更改为加粗的字体 并非所有的字体都有所有的变体。比如说，Papyrus字体就没有斜体，当你用fontDescriptorWithSymbolicTraits:方法时，它会找到给定匹配的最佳描述。 设置段落样式段落样式包括外边距、对齐、连体符号、换行以及类似属性。在iOS中，👉段落用换行符分隔，而其起作用的段落样式则是对段落中第一个字符应用的样式，其他样式则会被忽略👈因为段落样式有特殊的作用域范围，所以会打包成一个单独的NSParagraphStyle对象，并作为一个单独的属性用NSParagraphStyleAttributeName键应用。以下会对两个段落设置外边距和对齐12345678910111213141516171819202122NSString *paragraphs = @&quot;Do any additional setup after loading the view, typically from a nib.Do any additional setup after loading the view, typically from a nib.Do any additional setup\n after loading the view, typically from a nib.Do any additional setup after loading the view, typically from a nib.Do any additional setup after loading the view, typically from a nib.&quot;;NSMutableParagraphStyle *wholeDocStyle = [NSMutableParagraphStyle new];[wholeDocStyle setParagraphSpacing:34.0];[wholeDocStyle setFirstLineHeadIndent:10.0];NSDictionary *attributes = @&#123;NSParagraphStyleAttributeName: wholeDocStyle&#125;;NSMutableAttributedString *pas = [[NSMutableAttributedString alloc] initWithString:paragraphs attributes:attributes];//通过寻找回车来找到第二段NSUInteger secondParapraphStart = NSMaxRange([pas.string rangeOfString:@&quot;\n&quot;]);//添加头尾缩进NSMutableParagraphStyle *secondParagraphStyle = [[pas attribute:NSParagraphStyleAttributeName atIndex:secondParapraphStart effectiveRange:NULL] mutableCopy];secondParagraphStyle.headIndent += 50.0;secondParagraphStyle.firstLineHeadIndent += 50.0;secondParagraphStyle.tailIndent -= 50.0;//对本段的第一个字运用样式[pas addAttribute:NSParagraphStyleAttributeName value:secondParagraphStyle range:NSMakeRange(secondParapraphStart, 1)];self.label.numberOfLines = 0;self.label.attributedText = pas;self.label.backgroundColor = [UIColor redColor]; iOS7 为NSMutableAttributedString新增了一个方法:fixAttributesInRange:。这个方法会清空多种常见的样式上的不一致，特别是它基于段落第一个字符的样式为整个段落应用段落样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发多平台应用]]></title>
      <url>%2F2017%2F04%2F01%2F%E5%BC%80%E5%8F%91%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[开发多平台应用 Base SDK和Deployment Targe Xcode 为你构建的目标平台，提供了两个可配置的设置： 第一个是Base SDK,第二个是Deployment Target. 1. 配置Base SDK设置 在Build Settings选项卡，Base SDK选项。可以将值改为&quot;Latest iOS SDK&quot;,或者是开发机器上安装的任意版本的SDK。Base SDK设置会引导编译器使用该版本的SDK编译和构建应用，它会控制应用使用哪些API。默认情况下，Xcode中创建的新工程，总是使用最新版本的SDK，而苹果会处理API的废弃。 2.配置Deployment Target设置 它控制着运行运用需要的最新操作系统版本。如果你将它设成了特定版本，比如6.0，App Store会自动阻止运行早期操作系统的用户下载或安装这个应用。 支持多个SDK时的注意事项：框架、类和方法在支持多个SDK时，需要处理三种情况：框架、类和方法 1.框架的可用性 有时新的SDK会增加一个完整的新框架，也就是说该框架在较早的操作系统上不可用。 例如iOS7中的GameController.framework，这个框架只对运行iOS7及以上的设备可用。这里需要检查给定框架在用户的操作系统上是否可用，并隐藏调用该框架的UI元素。 对于某个早期版本操作系统中不可用的框架，如果时候了其中定义的符号，那应用就无法加载。为了避免这种情况情况而选择性的加载框架，必须采用弱链接(weak-link).要弱链接某个框架，打开Build Phases选项卡，展开Link Binary With Libraries,你可以看到当前链接到目标的一系列框架。如果没有修改这里的设置，默认情况下所有的框架都会被设成Required.点击Required组合框，然后将它修改为Optional。这样就弱链接该框架了。 弱链接框架时，缺失的符号会自动变成空指针。可以通过检查这个空指针来启用或禁止UI元素。 在链接一个只有较新版本的SDK提供的框架时，如果你仍然将该应用的部署目标设置为较早版本的SDK，应用会无法启动，而且几乎会立即崩溃。 2.类的可用性 有时新的SDK可能在已有框架中新增了新类。这意味着即使该框架链接了，也并不是所有的符号都能在早期操作系统中可用。例如iOS7 里UIKit.framework中定义的NSLayoutManager类。该框架会被链接到每个iOS应用上，所以在使用该类的时候，需要使用NSClassFromString方法来实例化一个对象，借此检查该对象是否存在。 另一个检查可用性的方法是使用class方法，而不是NSClassFromString，如以下代码。 检查UIStepper控件的可用性 12345if([NSLayoutManager class])&#123; //使用基于TextKit的新布局&#125;else&#123; //使用基于Core Text的新布局&#125; 3.方法的可用性 检查某个类中是否存在某个方法的代码 1if([self.view respondsToSelector:@selector(setTintColor:)])&#123;&#125; 要检查制定类中是否存在某个方法，可以使用respondsToselecotr:方法。 如果你要检查的方式是C全局函数，那就在表达式中将它和NULL比较，如以下代码所示。 123if(CFunction != NULL)&#123; CFunction(a);&#125; 检测设备的功能看看如下的代码片段，它用来判断iPhone的功能。 检测麦克风🎤的错误方法123if(![[UIDevice currentDevice].model isEqualToString:@&quot;iPhone&quot;])&#123;///&#125; 这段代码的问题在于，这位开发者大胆地假设只有iPhone有麦克风。这段代码最开始表现良好。但在iOS2.2版中，苹果向iPod touch增加了外接麦克风功能，这段代码会阻止用户使用该应用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过安全服务巩固系统安全]]></title>
      <url>%2F2017%2F03%2F29%2F%E9%80%9A%E8%BF%87%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E5%B7%A9%E5%9B%BA%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%2F</url>
      <content type="text"><![CDATA[理解iOS沙盒 iOS 安全模型的精髓在于沙盒(sandbox).安装应用时，系统会在文件系统中创建一个自己的主目录。 沙盒中有四个重要的顶级目录： .app捆绑目录(.app bundle)、Documents、Library 和 tmp. 应用允许访问/System/Library/Frameworks. 为了更好的组织，可以在Library下创建子目录。 .app捆绑目录是Xcode最终构建出来并复制到设备上的包。其中所有的内容都经过了数字签名，所以无法修改。尤其是其中还包含开发者的Resource目录。👉要修改作为捆绑安装的文件，需要先将它们复制到其他地方，通常是Library当中。👈 Library/Caches目录很特殊，它不会被备份，但是会在升级过程中保留。 备份是非常重要的概念，用户可能会使用密码来加密iTunes备份。如果数据不应该以明文方式在桌面机器上存储，那就应该将其存储在钥匙串(keychain)中。 如果某些信息不想让用户看到，可以将它们存储在钥匙串中，或是Library/Caches目录下。但这只能起到微弱的保护，因为用户总能通过越狱来读取任何文件或钥匙串 保证网络通信的安全攻击者并不需要访问设备，只要能够访问设备所在的网络就行了。危险区域包括咖啡馆、机场以及其他公共Wi-Fi接入区。 最简单直接的解决办法是在网络通信中采用HTTPS，该协议能够避免很多简单的攻击。 证书工作原理非对称密码学基于以下数学事实：可以找到两个很大的相关数字(分别称为A和B)，其中一个数字加密的内容可以使用另外一个数字解密，反之亦然。秘钥A不能解密秘钥A加密的内容，秘钥B不能解密秘钥B加密的内容。各自只能解密对方加密的数据。这部分数据称之为密文。解密和加密使用的是不同的钥匙。采用公钥加密，私钥解密。如果要证明某个实体(个人或机器)拥有配对的私钥，可以生成一个随机数，将它用该实体的公钥加密，然后发送给它。该实体会用私钥解密数据，然后将它发回。开发人员还可以使用该属性对数据进行数字签名。给定一些数据，可以先用一些知名的散列算法将其散列化，然后再用私钥对其加密。生成的密文就是签名。要验证该签名，用同样的算法再次散列化该数据，用公钥解密收到的签名，然后比较这两个散列值。如果一致，说明该签名是由持有私钥的实体创建的。 存在的问题是： 能够访问该私钥的人都能够伪造签名。 其次，你怎么知道自己拿到的公钥就是跟你通信的实体关联的那个？ 证书是由公钥、证书相关的元数据，以及其他一系列证书的签名构成。证书都存在一个简单的链，每个都会对其后面跟着的进行签名。 数学上，可以判断出每个证书的控制者都会签名链中的下一个证书，但我们为什么信任它们？我们信任它们是因为苹果信任VeriSign的根证书，它会对中级证书签名，而中级证书又会对苹果证书进行签名。苹果会将VeriSign的根证书以及一百多个其他受信任根证书存放在每个iOS设备的受信任证书仓库中。👉受信任根证书仓库是一系列被认为值得信任的证书👈我们将明确受信任的证书成为锚，如果不信任苹果的受信任证书列表，开发者可以设置自己的锚。 处于密码学原因，每个证书都要包含一个来自自身的签名。只包含这个签名的证书被称为自签名证书。通常，人们在谈到自签名证书时，暗含“你不该信任这个证书”的意思。但VeriSign根证书就是一个自签名证书，而它是世界上最受信任的证书之一。从定义上来看，每个根证书就是一个自签名证书。决定安全性的其实并不是证书链中的证书。决定安全性的其实并不是证书链中的证书包含多少个签名，而是证书链中的私钥是否保护的足够安全，以及证书所有者的身份是否得到了认证。如果你生成了自己的自签名证书，并且将私钥保管得足够好，那它甚至比VerSign颁发给你的证书还要安全。这两者情况都需要自己保管私钥，而在后者中，还要考察VeriSign是否保管好了它的私钥。 这并不是说VeriSign、DigiTrust以及其他提供商颁发的商业证书不够好用，而是说你不能依赖商业证书来提供系统的安全性。获得商业证书只是为了省事，因为商业证书已经在根证书密钥仓库中了。结论令人吃惊😲：购买商业证书来加密应用和服务器之间的网络协议并不能提高安全性。 商业证书只对由浏览器或其他不可控软件访问的网络有用。👉自行生成证书并将公钥放到应用中👈甚至比使用商业证书还要安全。 检验证书的有效性如果证书没有损坏，它就一定有效吗？证书包含有关其所包含公钥的大量元数据,公钥只是一个很大的数字，自身并没有任何意义。正是元数据才赋予了这些数字实际意义。证书的有效性是指它所包含的元数据是一致的，并且适用于请求的用途。 元数据中最重要的部分是主题。对服务器来说，主题就是完全限定域名，比如ww.example.org.👉有效性测试的第一步是做名称匹配。👈如果你访问的域名是www.example.org,而网站证书上写的是www.badguy.com,那你应该拒绝该证书。但是事情往往没有这么简单。如果访问的是example.org,而它的证书上显示的是www.example.org呢？应该接受该证书吗？许多人以为example.org和www.example.org是指的同一台服务器(实际上可能是同一天，也可能不是)，但证书使用的是简单的字符串匹配。如果字符串不匹配，那么证书就是无效的。有些服务器带的是主题类似*.example的通配型证书，iOS会接受这些证书；但有时候它仍然有可能会因为名称不匹配而拒绝你所认为应该接受的证书。不幸的是，iOS处理起来并不容易，但好在还是能处理的。决定是否接受一个证书的主要工具是NSURLConnection的委托方法connection:willSendRequestForAuthenticationChanllenge.在该方法中，你要决定是否通过该服务器的认证，如果要通过，则需要提供凭据。下面代码能够连接到任何持有非损坏证书的任何服务器来进行认证，而不管证书是否有效或受信任123456-(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge&#123;SecTrustRef trust = challenge.protectionSpace.serverTrust;NSURLCredential *cred;cred = [NSURLCredential credentialForTrust:trust];[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];&#125; 这段代码先提取了trust对象，然后为其创建了一个Credential对象。HTTPS连接总会要求提供Credential对象，即便实际上并不需要将凭据传给服务器。 下面这个例子尝试链接IP地址为72.14.204.113的服务器。我们接收到的主题是*.google.com,跟实际的并不匹配。字符串72.14.204.113里面并不包含.google.com。你决定接受主题名称中包含google.com的所有受信任证书。要编译下面的例子，需要将Security.framework链接都你的工程中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//这个函数会从URL加载系统创建的原始trust对象处复制所有的证书并创建一个新的trust对象。新trust对象使用更简单的X.509策略，只检查证书自身的有效性和可信度，而不会像原来的SSL策略一样检查主机名。static OSStatus RNSecTrustEvaluateAsX509(SecTrustRef trust,SecTrustResultType *result)&#123;OSStatus status = errSecSuccess;SecPolicyRef policy = SecPolicyCreateBasicX509();SecTrustRef newTrust;CFIndex numberOfCerts = SecTrustGetCertificateCount(trust);NSMutableArray *certs = [NSMutableArray new];for (NSUInteger index = 0; index &lt; numberOfCerts; ++index) &#123;SecCertificateRef cert;cert = SecTrustGetCertificateAtIndex(trust, index);[certs addObject:(__bridge id)cert];&#125;status = SecTrustCreateWithCertificates((__bridge CFArrayRef)certs,policy,&amp;newTrust);if (status == errSecSuccess) &#123;status = SecTrustEvaluate(newTrust, result);&#125;CFRelease(policy);CFRelease(newTrust);return status;&#125;-(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge&#123;//接受challenge对象，提取trust对象。NSURLProtectionSpace *protSpace = challenge.protectionSpace;SecTrustRef trust = protSpace.serverTrust;SecTrustResultType result = kSecTrustResultFatalTrustFailure;//我们通过测试trust对象(SecTrustEvaluate)得到一个可恢复错误。通常可恢复错误就是名称不匹配之类的问题。OSStatus status = SecTrustEvaluate(trust, &amp;result);//Recoverable 可恢复if (status == errSecSuccess &amp;&amp; result == kSecTrustResultRecoverableTrustFailure) &#123;SecCertificateRef cert = SecTrustGetCertificateAtIndex(trust, 0);//我们拿到了证书的主题，然后判断他们是否是足够的接近（本例中，检查它是否包含.google.com）CFStringRef subject = SecCertificateCopySubjectSummary(cert);NSLog(@&quot;Trying to access %@. Got %@.&quot;,protSpace.host,subject);CFRange range = CFStringFind(subject, CFSTR(&quot;.google.com&quot;), kCFCompareAnchored|kCFCompareBackwards);if (range.location != kCFNotFound) &#123;//如果能接受传递过来的名称,就可以把它当做一个简单的X.509证书来重新测试，而不是作为SSL握手的一本分。通过自定义函数RNSecTrustEvaluateAsX509进行的。status = RNSecTrustEvaluateAsX509(trust, &amp;result);&#125;CFRelease(subject);&#125;if (status == errSecSuccess) &#123;switch (result) &#123;case kSecTrustResultInvalid:case kSecTrustResultDeny:case kSecTrustResultFatalTrustFailure:case kSecTrustResultOtherError:case kSecTrustResultRecoverableTrustFailure:NSLog(@&quot;Failing due to result: %u&quot;,result);[challenge.sender cancelAuthenticationChallenge:challenge];break;case kSecTrustResultProceed:case kSecTrustResultUnspecified:&#123;NSLog(@&quot;Successing with result: %u&quot;,result);NSURLCredential *cred;cred = [NSURLCredential credentialForTrust:trust];[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];&#125;default:NSAssert1(NO, @&quot;Unexpected result from trust evaluation:%u&quot;, result);break;&#125;&#125;else&#123;//证书有问题NSLog(@&quot;Complete failure with code: %d&quot;,(int)status);[challenge.sender cancelAuthenticationChallenge:challenge];&#125;&#125; 证书还有可能因为过期无效。不幸的是，虽然可以使用SecTrustSetVerifyDate制定任何的日期来重新测试该证书，但我们无法找到一个简单、公开的办法来检验证书的有效日期。下面的私有方法来检验有效期限：12CFAbsoluteTime SecCertificateNotValidBefore(SecCertificateRef certificate);CFAbsoluteTime SecCertificateNotValidAfter(SecCertificateRef certificate); 测试trust对象后，最终结果会是SecTrustResultType中的某一个。其中下面这些结果代表证书”正常”或“可能正常” kSecTrustResultProceed 证书有效，用户明确接受它 kSecTrustResultUnspecified 证书有效，而用户未明确接受或拒绝，通常开发人员接受就可以了 kSecTrustResultRecoverableTrustFailure 证书无效，但某种意义上开发人员可以接受它，比如名称不匹配、已过期或缺乏可信度(自签名证书) kSecTrustResultDeny 该证书有效，但用户明确拒绝了 kSecTrustResultInvalid 验证过程无法达成，很有可能是因为开发人员自身代码有问题 kSecTrustResultFatalTrustFailure 该证书有问题或者损坏 kSecTrustResultOtherError 这个错误但愿你能见到 判断证书的可信度你已经了解了如何来判断这个证书是否有效，但有效并不代表可以信任。如果应用接收到的是不明身份的认证机构签发的证书，那么就没有可信度。要想证书受信任，它必须由trust对象的锚证书列表中的某个证书签名，锚证书是指系统明确信任的证书。iOS带有一百多份锚证书，主要来自政府或企业。如果证书是自行生成的，你可以将公钥嵌入到应用中，并配置trust对象使其只接受该证书或由它签发的证书。这样你不仅能在安全性方面拥有较大的自主权，还能节省一些费用。 在下面的例子中，我们可以创建一个自签名的证书:(1)打开keychain Access.(2)选择keychain Access 菜单-&gt; Certificate Assistant -&gt; Create a Certificate.(3)输入你想要的名字。将Identity type 设为SelfSigned Root,将Certificate Type设置为SSL Client,然后创建该证书。它会警告⚠️你说这是一个自签名证书，点击continue。新创建的证书会警告说此证书尚未经过第三方验证，管他呢！(4)回到Keychain Access窗口，选择login keychain,然后选择category Certificates(5)找到刚刚创建的证书，然后将它拖到桌面上导出。该文件只包含公钥。默认情况下，钥匙串不会导出私钥的，将这个公钥文件拖到你的Xcode工程中。可以通过以下方式来测试收到的证书是由你的证书签名的： 123456789SecTrustRef trust = ...; //要验证的trust对象NSError *error;NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;MyCert&quot; ofType:@&quot;cer&quot;];NSData *certData =[NSData dataWithContentsOfFile:path options:0 error:&amp;error];SecCertificateRef certificate;certificate = SecCertificateCreateWithData(NULL,(__bridge CFDataRef)certData);NSArray *certs = @[(__bridge id)certificate];SecTrustSetAnchorCertificates(trust,(__bridge CFArrayRef) certs);CFRelease(certificate); 将证书从资源捆绑目录中加载到NSData中，转换成SecCertificate,然后将它设置为该trust对象的锚。这时该trust对象只接受传给SecTrustSetAnchorCertificates的证书，并忽略系统的锚。如果二者都接受，可以用SecTrustSetAnchorCertificatesOnly来重新配置该trus对象。 通过这种技术，就可以在connection:willSendRequestForAuthenticationChallenge:方法中正确相应所有的证书，并控制要拒绝或接受哪些证书了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用REST服务]]></title>
      <url>%2F2017%2F03%2F25%2F%E4%BD%BF%E7%94%A8REST%E6%9C%8D%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[1 REST简介 REST服务器总是无状态的。每次API调用都被视作新的请求，服务器并不会记录客户端上下文。客户端需要维护服务器的状态，包括但不限于缓存服务器响应和登录访问令牌。REST式服务器的资源定位是通过URL实现的。REST不使用资源ID作为参数，而是将它作为URL的一部分。例如，http://example.com/resource?id=1234在REST服务器中就变成了http://example.com/resources/1234.REST式服务器使用这种方式进行资源定位，而且也不维护客户端状态，这就使客户端可以根据URL缓存响应，就像浏览器缓存网页一样。2 假象的Web服务 每一次调用web服务时都要在请求中附带访问令牌。 转化为/loginwaiter和/logintable这两个服务端点。（顾客和服务员）这两个端点都需要返回一个访问令牌。iOS客户端中使用了键值编码(KVC)技术，只需要用非常少的代码就可以把JSON键映射到模型对象。在这些情况下，有一些iOS应用会显示一个浮动的平视显示器(通常称之为HUD)，用于防止用户在评论发表成功之前进行其他操作。从用户体验来说，这是非常糟糕的。 3 重要提醒编写应用时应当牢记这些要点： 绝对不要使用同步的网络请求(一旦发送同步请求，直至服务器返回数据完成，才可以进行下一步操作)。即使是在后台线程中，同步调用也不会报告进度。另外一个原因是，如果想取消后台线程的同步请求，只能结束这个线程。另外，也不能控制应用中的网络请求数量，而这对于应用的性能来说是非常关键的。 尽量不要直接使用NSThread或者基于GCD的线程进行网络请求。 使用基于NSOperationQueue的线程，使用NSOperationQueue可以非常好地控制队列长度和并发的网络请求数量。基于GCD的线程在块分派之后，就无法取消了。 4 RESTfulEngine架构(iHotelApp示例代码) 4.1 NSURLConnectiton与第三方框架MKNetworkKit 封装了很多常用的功能，比如基本认证/摘要认证，表单发布、上传/下载文件。另外一个重要功能就是它封装了NSOperationQueue,可以使用队列来管理网络请求。 取消请求 用户离开当前视图时，应该由当前视图控制器负责取消已经创建的网络请求。为了确保这一点，RESTfulEngine类中的所有方法都应该把操作对象返回给视图控制器。通过释放带宽，加快其他请求的速度。 6.请求相应 对JSON数据进行键值编码 setValuesForKeysWithDictionary: 用于匹配类中与字典的键同名的属性，并把字典中的值赋值给该属性。 setValue:forUndefinedKey:处理不兼容的键值编码。这个方法的默认实现会引发NSUndefinedKeyException异常。 我们可以在派生内中覆盖这个方法，并且设置相应的值123456789-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123;if([key isEqualToString:@&quot;ID&quot;])&#123; self.itemID = value;&#125;if([key isEqualToString:@&quot;description&quot;])&#123; self.itemDescription = value;&#125;....&#125; 列表界面的JSON对象与详细界面的JSON对象 一个JSON对象就是从服务器传送到客户端的负载。为了提升性能并且减少负载，服务器开发者通常会为同一个对象使用两种不同的负载。一种是大负载格式，包含了对象的全部信息。另一种是小负载格式，只包含了用于在列表中显示的必须信息。这种技术可以明显的提高iOS应用的性能。从实现的角度来说，iOS应用不需要做任何改动就可以同时映射这两种JSON。如果返回完全的JSON，对象就会被完全填充；如果返回不完全的JSON，对象就会被部分填充。 嵌套JSON对象 以递归的方式进行映射：可以通过setValue:forKey:方法进行处理12345678910-(void)setValue:(id)value forKey:(NSString *)key&#123;if([key isEqualToString:@&quot;reviews&quot;])&#123; for(NSMutableDictionary *reviewArrayDict in value)&#123; Review *thisReview = [[Review alloc] initWithDictionary:reviewArrayDict]; [self.reviews addObject:thisReview]; &#125;&#125;else&#123; [super setValue:value forKey:key];&#125;&#125; 错误处理 （在iOS客户端优雅的处理服务器端错误） 在某些情况下，可以使用一个特殊的键来传递错误信息，比如status。在另外一些情况下，服务器会使用一个名为error的键来传递更多的真实错误信息。如果API调用成功则没有这个error键。 可以用MKNetworkOperation子类处理自定义API错误，步骤如下：(1)创建一个名为RESTfulOperation的MKNetworkOperation子类。这个子类有一个属性用于保存服务器抛出的业务逻辑错误。(2)在子类中创建一个名为restError的NSError*属性(3)覆盖两个用于处理错误情况的方法。首先覆盖operationFailedWithError:方法12345678910111213141516171819-(void) operationFailedWithError:(NSError *)theError&#123;NSMutableDictionary *errorDict = [[self responseJSON] objectForKey:@&quot;error&quot;];if(errorDict == nil)&#123;self.restError = [[RESTError alloc] initWithDomain:kRequestErrorDomain code:[theError code]userInfo:[theError userInfo]];&#125;else&#123;self.restError = [[RESTError alloc] initWithDomain:kBusinessErrorDomain code:[[errorDict objectForKey:@&quot;code&quot;] intValue]userInfo:errorDict]; &#125;[super operationFailedWithError:theError];&#125; 并不是每一个业务逻辑错误都能被映射为等价的HTTP错误代码。为了能够处理这两种情况，还需要覆盖operationSucceeded:方法，如下所示：123456789101112131415161718- (void)operationSucceeded&#123; // even when request completes without a HTTP Status code, it might be a benign errorNSMutableDictionary *errorDict = [[self responseJSON] objectForKey:@&quot;error&quot;];if(errorDict)&#123;self.restError = [[RESTError alloc] initWithDomain:kBusinessErrorDomain code:[[errorDict objectForKey:@&quot;code&quot;] intValue]userInfo:errorDict];[super operationFailedWithError:self.restError];&#125;else &#123; [super operationSucceeded];&#125; &#125; 这些方法都使用子类请求对象的resetError属性保存业务逻辑错误。这样一来，客户端就既可以处理HTTP错误(使用RESTfulOperation父类的错误对象)又能处理业务层错误(使用局部属性restError) 由于这些是在子类中完成的，所以RESTfulEngine类不需要做任何额外的错误处理。不管是HTTP错误还是业务逻辑错误，RESTfulEngine得到的都是一个封装好的NSError对象。在视图控制器的实现中只需要检查err是否为nil就可以了。 本地化 在某些实现中需要用多种语言对错误信息进行本地化。对于服务器相关的错误，显示本地化错误的最好办法就是在发生错误时，返回双方一致同意的错误代码。iOS客户端根据错误代码查找本地化字符串文件，然后显示相应的错误信息。 RESTError.m1234567891011121314151617+ (void) initialize&#123;//不同的地方加载不同的文件。 Errors_en_US.plist Errors_zh_CN.plistNSString *fileName = [NSString stringWithFormat:@&quot;Errors_%@&quot;, [[NSLocale currentLocale] localeIdentifier]];NSString *filePath = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;plist&quot;];if(filePath != nil)&#123;errorCodes = [[NSMutableDictionary alloc] initWithContentsOfFile:filePath]; &#125;else&#123; // fall back to english for unsupported languagesNSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;Errors_en_US&quot; ofType:@&quot;plist&quot;];errorCodes = [[NSMutableDictionary alloc] initWithContentsOfFile:filePath]; &#125;&#125; 覆盖NSError的localizedDescription和localizedRecoverySuggestion方法，以提供易懂的处理处理方法。如果Web服务在返回错误代码的同时也返回了错误信息，使用这种方式处理和显示错误信息比使用userInfo字典显示服务器错误信息更好。 在iOS中提升性能的小技巧 与Web应用不同，iPhone应用的带宽非常有限。 大部分服务器都不允许同一个IP出现6个以上的并发HTTP请求？ 缓存 按需缓存：把从服务器获取的内容以某种格式存放在本地文件系统之后对于每次请求，检查缓存中是否存在这块数据，只有当数据不存在(或者过期)的情况下才从服务器获取。而预缓存是把内容放在本地以备将来访问。 实现预缓存可能需要一个后台线程访问数据并以有意义的格式保存，以便本地缓存无需重新连接服务器即可被编辑。编辑可能是”标记记录为已读”或”加入收藏”。这里有意义的格式是指可以用多种格式保存内容，不用和服务器通信就可以在本地作出上面提到的更改，并且一旦再次连上网就可以把变更发送回服务器。Core Data是实现这种储存的一种方式。 按需缓存可以通过在打开一个视图控制器时按需地缓存数据模型(创建一个数据模型缓存)来实现。也可以在一个URL请求返回成功应答时实现按需缓存（创建一个URL缓存）。 选择使用按需缓存还是预缓存的一个简便方法是判断是否需要在下载数据之后处理数据。后期处理数据可能是以用户产生编辑的形式，也可能是更新下载的数据，比如重写HTML页面里的图片链接以指向本地的缓存图片。如果一个应用需要做上面提到的任何后期处理，就必须实现预缓存。 13.1 存储缓存因为缓存数据不是用户产生的，所以它应该被保存在NSCacheDirectory,而不是NSDocumentsDirectory.为缓存数据创建独立目录是一项不错的实践。可以这样创建：123NSArray *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES);NSString* cachesDirectory = [path objectAtIndex:0];cachesDirectory = [cachesDirectory stringByAppendingPathComponent:@&quot;MyAppCache&quot;]; 把缓存存储在缓存文件夹下的原因是iCloud(和iTunes)的备份不包括此目录。 预缓存是高级数据库(比如原始的SQLite)或者对象序列化框架(比如Core Data)实现的。 数据模型缓存实现细节： 可以用NSKeyedArchiver类来实现数据模型的缓存。为了把模型对象用NSKeyedArchiver归档。模型类需要遵守NSCoding协议。 NSCoding协议方法：12- (void)encodeWithCoder:(NSCoder *)aCoder;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; 当模型遵守了NSCoding协议，归档对象就很简单，只要调用下列方法：12//制定的路径下创建归档文件[NSKeyedArchiver archiveRootObject: toFile:]; 使用NSKeyedUnarchiver用于从文件反归档模型。1[NSKeyedUnarchiver unarchiveObjectWithFile:]; 使用任何NSKeyedArchiver/NSkeyedUnarichiver的前提是模型实现了NSCoding协议。 预缓存： 预缓存需要用到更结构化的数据结构。Core Data：Core Data更像是一个对象序列化框架，而不仅仅是一个数据库API。要在Core data中保存数据，首先需要创建一个Core Data模型文件，并创建实体(Entity)和关系(Relationship); 然后写好保存和获取数据的方法。应用可以借助Core Data实现真正的离线访问功能。就像苹果内置的邮件和日历应用一样。实现预缓存时必须定期删除不再需要的(过时的)数据。👉同步本地变更是通过追踪变更集并发送给服务器实现的。 用Core Data实现按需缓存 原始SQLite可以通过链接libsqlite3的库来把SQLite嵌入应用，但是这么做有很大的缺陷。所有的sqlite3库和对象关系映射(ORM)机制总是比Core Data慢。此外，尽管sqlite3本身是线程安全的，但是iOS的二进制包则不是。所以除非是定制编译的sqlite3库(用线程安全的编译参数编译)，否则开发者就有责任确保从sqlite3读取数据或者往sqlite3写入数据是线程安全的。Core Data有这么多特性而且内置线程安全，建议在iOS中尽量避免使用sqlite。应该用那种缓存技术 在众多可以本地缓存数据的技术当中，有三种可以脱颖而出：URL缓存、数据模型缓存(利用NSKeyedArchiver)和Core Data。 假设你正在开发一个应用，需要缓存数据以改善应用表现出来的性能，你应该实现按需缓存(使用数据模型缓存或URL缓存)。另一方面，如果需要数据能够离线缓存，而且具有合理的存储方式以便离线编辑，那么就用高级序列化技术(如Core Data)数据模型缓存1234567891011121314151617181920212223242526272829- (void)encodeWithCoder:(NSCoder *)encoder &#123;[encoder encodeObject:self.itemId forKey:@&quot;itemId&quot;];[encoder encodeObject:self.image forKey:@&quot;image&quot;];[encoder encodeObject:self.name forKey:@&quot;name&quot;];[encoder encodeObject:self.spicyLevel forKey:@&quot;spicyLevel&quot;];[encoder encodeObject:self.rating forKey:@&quot;rating&quot;];[encoder encodeObject:self.itemDescription forKey:@&quot;itemDescription&quot;];[encoder encodeObject:self.waitingTime forKey:@&quot;waitingTime&quot;];[encoder encodeObject:self.reviewCount forKey:@&quot;reviewCount&quot;];[encoder encodeObject:self.reviews forKey:@&quot;reviews&quot;];&#125;- (id)initWithCoder:(NSCoder *)decoder &#123;self = [super init];if (self) &#123;self.itemId = [decoder decodeObjectForKey:@&quot;itemId&quot;];self.image = [decoder decodeObjectForKey:@&quot;image&quot;];self.name = [decoder decodeObjectForKey:@&quot;name&quot;];self.spicyLevel = [decoder decodeObjectForKey:@&quot;spicyLevel&quot;];self.rating = [decoder decodeObjectForKey:@&quot;rating&quot;];self.itemDescription = [decoder decodeObjectForKey:@&quot;itemDescription&quot;];self.waitingTime = [decoder decodeObjectForKey:@&quot;waitingTime&quot;];self.reviewCount = [decoder decodeObjectForKey:@&quot;reviewCount&quot;];self.reviews = [decoder decodeObjectForKey:@&quot;reviews&quot;];&#125;return self;&#125; 在viewWillApear：方法中实现实际的缓存逻辑 视图控制器的viewWillApear:方法中缓存恢复数据模型对象的代码片段12345678910111213141516NSArray *path = NSSearchPathForDirectoriesInDomians(NSCachesDirectory,NSUserDomianMask,YES);NSString *cachesDirectory = [path objectAtIndex:0];//拼接路径NSString *archivePath = [cachesDirectory stringByAppendingPathComponent:@&quot;AppCache/MenuItems.archive&quot;];//尝试反归档NSMutableArray *cachedItems = [NSKeyedUnarchiver unarchiveObjectWithFile:archivePath];if(cachedItems == nil) self.menuItems = [AppDelegate.engine localMenuItems];else self.menuItems = cachedItems;//在这里决定要不要更新NSTimeInterval stalenessLevel = [[[[NSFileManager defaultManager] attributesOfItemAtPath:archivePath error:nil] fileModificationDate] timeIntervalSinceNow];if(stalenessLevel &gt; THRESHOLD) self.menuItems = [AppDelegate.engine localMenuItems];[self updateUI]; 视图控制器的viewWillDisappear：方法中缓存数据模型的代码片段1234NSArray *paths = NSSearchPathForDirectoriesInDomains(NSChchesDirectory,NSUserDomainMask,YES);NSString *cachesDirectory = [paths objectAtIndex:0];NSString *archivePath = [cachesDirectory stringByAppendingPathComponent:@&quot;AppCache/MenuItems.archive&quot;];[NSKeyedArchiver archiveRootObject:self.menuItems toFile:archivePath]; 重构当有多个视图控制器的时候，这样的代码就显得冗杂。可以通过抽象公共类作为处理缓存的核心代码。 视图控制器viewWillApear:方法中用AppCache类缓存数据模型的重构代码片段：1234567891011121314-(void)viewWillApear:(BOOL)animated&#123;self.menItems = [AppCache getCachedMenuItems];[self.tableView reloadData];//如果超过了缓存期限或者根本就没有缓存if([AppCache isMenuItemsStale] || self.menuItems)&#123; //发送网络请求&#125;[super viewWillAppear:animated];&#125;-(void)viewWillDisappear:(BOOL)animated&#123;[AppCache cacheMenuItems:self.menuItems];[super viewWillDisappear:animated];&#125; 开发者可以通过为每个用户创建子目录即可轻松增强缓存数据的安全性。更改缓存目录为返回当前登录用户的子目录。这样，一个用户缓存的数据就不会被随后登录的用户看见了。 缓存版本控制 当你更新应用时，模型类可能会发生变化，这意味着之前归档的任何数据都将不能恢复到新的模型上。如何在版本升级时删除缓存目录？：使缓存失效AppCache 中缓存版本的初始化方法(AppCache.m)123456789101112131415+(void)initialize&#123; //获得拼接的路径 NSString *cacheDirectory = [AppCache cacheDirectory]; if(![[NSFileManager defaultManager] fileExistsAtPath:cacheDirectory])&#123; [[NSFileManager defaultManager] createDirectoryAtPath:cacheDirectory withIntermediateDirectories:YES attributes:nil error:nil]; &#125; double lastSavedCacheVersion = [[NSUserDefaults standardUserDefaults] doubleForKey:@&quot;CACHE_VERSION&quot;]; double currentAppVersion = [[AppCache appVersion] doubleValue];if(lastSavedCacheVersion == 0.0f || lastSavedCacheVersion &lt; lastSavedCacheVersion)&#123; [AppCache clearCache]; //把版本号存储在设备中 ... &#125; &#125; 也可以用下面这段代码从应用的Info.plist中读取版本号：12345+(NSString *)appVersion&#123;CFStringRef versStr = CFBundleGetValueForInfoDictionaryKey(CFBundleGetMainBundle(), kCFBundleVersionKey);NSString *version = [NSString stringWithUTF8String:CFStringGetCStringPtr(versStr, kCFStringEncodingMacRoman)];return version;&#125; clearCache方法具体实现123456+(void)clearCache&#123;NSArray *cachedItems = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:[AppCache cacheDirectory] error:nil];for (NSString *path in cachedItems) &#123;[[NSFileManager defaultManager] removeItemAtPath:path error:nil];&#125;&#125; 创建内存缓存： 需要避免过于频繁的读写闪存。为了避免这个问题，我们可以再引入一层缓存，利用设备的RAM而不是闪存(用NSMutableDictionry)要创建内存缓存需要的步骤：(1)添加变量来存放内存缓存(2)限制内存缓存大小，并且把最近最少使用的项写入文件，然后从内存缓存中删除。RAM是有限的，达到使用极限就会触发内存警告。要为内存缓存设置一个最大阈值。当内存满了以后再添加任何东西时，最近最少使用的对象应该被保存到文件(闪存中)(3)处理内存警告，并把内存缓存以文件形式写入闪存(4)当应用关闭、退出，或进入后台时，把内存缓存全部以文件形式写入闪存 14 为APPCache设置内存缓存 添加一个NSMutableDictionary来保存缓存数据。添加一个NSMutableArray来追踪最近使用的项(按照时间顺序排序)，最后添加一个整数来限制缓存的最大尺寸1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@interface ViewController ()@endstatic NSMutableDictionary *memoryCache;static NSMutableArray *recentlyAccessedKeys;static int kCacheMemoryLimit;@implementation ViewController+(void)cacheMenuItems:(NSMutableArray *)menuItems&#123;//这里将NSKeyedArchiver得到的NSData保存到缓存中，[self cacheData:[NSKeyedArchiver archivedDataWithRootObject:menuItems] toFile:@&quot;MenuItems.archive&quot;];&#125;+(NSMutableArray *)getCachedMenuItems&#123;return [NSKeyedUnarchiver unarchiveObjectWithData:[self dataForFile:@&quot;MenuItems.archive&quot;]];&#125;//这里将缓存方法封装，到底是如何实现缓存的外界不得而知。//这里将NSKeyedArchiver得到的NSData保存到缓存中+(void)cacheData:(NSData *)data toFile:(NSString *)fileName&#123;//这里使用键值对。以存储路径作为key[memoryCache setObject:data forKey:fileName];//首先确保数组中没有这个key。有就移除if ([recentlyAccessedKeys containsObject:fileName]) &#123;[recentlyAccessedKeys removeObject:fileName];&#125;//现在把这个key放在数组的最前面[recentlyAccessedKeys insertObject:fileName atIndex:0];//if ([recentlyAccessedKeys count] &gt; kCacheMemoryLimit) &#123;NSString *leastRecentlyUsedDataFilename = [recentlyAccessedKeys lastObject];//数组中最后的元素就是上次调用时间距离现在最久的元素//现在把这个元素写入到闪存中NSData *leastRecentlyUsedCacheData = [memoryCache objectForKey:leastRecentlyUsedDataFilename];NSString *archivePath = [[AppCache cacheDirectory] stringByAppendingPathComponent:fileName];[leastRecentlyUsedCacheData writeToFile:archivePath atomically:YES];[recentlyAccessedKeys removeLastObject];[memoryCache removeObjectForKey:leastRecentlyUsedDataFilename];&#125;&#125;//在内存中没有的时候才去访问文件+(NSData *)dataForFile:(NSString *)fileName&#123;NSData *data = [memoryCache objectForKey:fileName];if (data) &#123;return data;&#125;NSString *archivePath = [[AppCache cacheDirectory] stringByAppendingPathComponent:fileName];data = [NSData dataWithContentsOfFile:archivePath];if (data) &#123;[self cacheData:data toFile:fileName];&#125;return data;&#125; 处理内存警告通过这种将数据缓存在内存中，收到内存警告的可能性很大向UIApplicationDidReceiveMemoryWarningNotification添加一个通知观察者：1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(saveMemoryCacheToDisk:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; 然后写一个方法把内存缓存中的项保存到文件：1234567+(void)saveMemoryCacheToDisk:(NSNotification *)notification&#123;for (NSString *filename in [memoryCache allKeys]) &#123;NSString *archivePath = [[AppCache cacheDirectory] stringByAppendingPathComponent:filename];NSData *cacheData = [memoryCache objectForKey:filename];[cacheData writeToFile:archivePath atomically:YES];&#125;&#125; 处理结束和进入后台通知 我们还应当确保应用退出或进入后台时会保存内存中的缓存。监听应用的停止活跃或关闭通知。只要把UIApplicationDidEnterBackgroundNotification和UIApplicationWillTerminateNotification的观察者加入初始化方法即可。 创建URL缓存 可以通过为应用所做的每次URL请求缓存应答来实现URL缓存。URL缓存用URL作为键，应答的数据作为值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[幕后制作： 后台处理]]></title>
      <url>%2F2017%2F03%2F25%2F%E5%B9%95%E5%90%8E%E5%88%B6%E4%BD%9C%EF%BC%9A-%E5%90%8E%E5%8F%B0%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[应用应该让用户感觉它一直在运行，即使实际上不是这样。应用可能会在挂起状态下没有收到任何的警告就终止运行了，但再次运行时，它应该让用户感觉与上次退出时没有任何不用。一是不要在加载过程中显示启动图片，二是要在应用进入后台运行时把各种必要的状态保存下来。在applicationWillResignActive:方法中，可以把少量的数据保存到NSUserDefaults中。大一些的数据结构应该保存到文件中，这些文件通常位于~/Library/Caches目录下。 应用挂起后无法收到内存警告。如果内存占用比较大，那么系统很可能会在出现内存压力时终止应用，而你对此毫无办法。处理这个问题时，NSCache和NSPurgeableData能够大显身手。NSPurgeableData是一个NSData对象，可以将它标记为当前正在使用或者可清除。如果把它保存到NSChache对象中并使用endContentAccess将其标记为可清除，iOS会在遇到内存压力之前一直保存它。遇到内存压力时，iOS就会丢弃这些数据，即使这时应用处于挂起状态。 使用imageNamed:方法加载的图片数据会被自动丢弃，再次使用时会重新从磁盘加载。视图的后备存储(位图缓存)也会被自动丢弃。唤醒应用时应该调用drawRect:方法。这个规则有一个重大的例外：UIImageView不会丢弃数据，因而会占用大量的内存。如果UIImageView中有非常大的图片，通常应该在进入后台运行之前把它删除。然而，解压图片非常耗时，所以不要过于频繁地丢弃它们。这个问题没有唯一正确的答案，需要根据自己的应用进行权衡 。应用进入到后台后，可以使用Instruments中的VM Tracker检验应用占用的内存数量。首先，创建一个用于显示大型图片的应用。然后使用VM Traker运行应用。注意当前的内存占用量。按下Home键看看当前的内存占用量。这就是进入后台运行时会释放的内存。👉后台内存占用量高的话，唤醒应用的过程比较慢。👈内存占用量应该尽可能低。 在Instruments中可以看到两种内存，脏内存(dirty memory)和常驻内存(resident memory)。进入后台运行时，不能被iOS自动回收的内存就是脏内存。常驻内存就是当前使用的所有内存。减少脏内存的占有量可以降低应用在后台被终止的可能性。应优先减少脏内存的占有量。NSCache和NSPurgeableData可以用来减少脏内存占有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多任务]]></title>
      <url>%2F2017%2F03%2F23%2F%E5%A4%9A%E4%BB%BB%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[1.多任务和运行循环简介每个Cocoa应用程序都由一个处于阻塞状态的do/while循环驱动。当有事件发生时，就把事件分派给合适的监听器。 明白运行循环就是一个大的do/while循环。它运行在某个线程中，从各种事件队列中取得事件，然后把它分配给合适的监听器。 如果调用applicationWillResignAction:方法，那是因为某个事件触发了你实现的委托调用。这时运行循环会阻塞(对于其他的任何方法来说就是阻塞状态)，调用返回后才能继续运行。主线程运行这些代码时，滚动视图无法滚动，按钮无法高亮，定时器也无法触发。整个UI都会被挂起，直到事件处理完成。 这并不是说所有的东西都在主运行循环上，每个线程都有自己的运行循环。与大部分的网络请求一样，动画通常也在后台中运行。系统核心会运行一个共享的运行循环。虽然每个线程都有自己的运行循环，但这并不是说每个线程都会处理自己的运行循环。运行循环仅在需要对runUntilDate：等命令做出响应时，才会执行它们的do/while循环。调用main.m文件中的UIApplicationMain就会运行主运行循环。 NSTimer 基于运行循环进行消息分派。调度NSTime时，其实是要求当前运行循环在某个特定的时间分派某个选择器。运行循环每次迭代都会对时间进行检查并且触发所有过期的定时器。延迟执行的方法(比如performSelector:withObject:afterDelay:)也是通过调度定时器实现的。 2.以操作为中心的多任务开发 线程的创建和维护成本都很高。加锁的代价是昂贵的。可能导致大量的bug。很多操作一般会有顺序的依赖关系，所以最好创建某种队列，确保它们按你想要的顺序执行。这就是NSOperation的功能。这是你在优化多线程程序，从而尽可能减少锁时想到的方案。 👉操作支持优先级，依赖关系和取消。所以它们很适合调度某些实际上并不需要做的事情。比如，在一个滚动视图中更新图片，收藏当前屏幕上的图片，以及取消更新滚出屏幕以外的图片 下面的这个例子将创建一个UICollectionView，其中包含随机分形图。计算这些分形图非常消耗资源，所以要异步生成。为了提高显示性能，要计算各种分辨率下的分形图，快速显示一个低分辨率分形图，然后在用户停止滚动时显示高分辨率分形图。 Demo地址 3.用GCD实现多任务 NSOperationQueue是在GCD的基础上实现的。块添加到分派队列后就无法取消了。分派队列是严格的先进先出(FIFO)结构，所以无法在队列中使用优先级或者调整块次序。如果需要这类特性，一定要用NSOperationQueue，而不是用GCD重新发明轮子。可以用分派队列做很多操作办不到的事。比如，GCD提供的dispatch_after支持调度下一个操作的开始时间而不是直接进入睡眠。3.1 分派队列简介 分派队列就是队列，不是线程。不要认为队列是接受块的东西，队列是组织块的，调用dispatch_async不会让块运行，而只是把块添加到队列中。几乎所有的GCD方法都是这样的，就是把块添加到队列末尾。 队列目标和优先级 GCD中队列是有层级的。事实上只有全局系统队列会被调度运行，可以用dispatch_get_global_queue和下面这些优先级常量中的一个来访问这些队列。 DISPATCH_QUEUE_PRIORITY_HIGH DISPATCH_QUEUE_PRIORITY_DEFAULT DISPATCH_QUEUE_PRIORITY_LOW DISPATCH_QUEUE_PRIORITY_BACKGROUND 👉这些队列都是并行的👈。GCD会根据可用线程👉尽可能👈从高优先级队列调度块，等高优先级队列空了以后，会继续调用默认优先级队列，一次类推。系统会根据可用的核心数和负载创建和销毁线程。开发人员自己创建队列时，👉队列会附加到附加到某个全局队列。👈默认附加到默认优先级队列上。当块到达队列头部时，实际上会移动到目标队列末尾，当到达全局队列的头部时就会执行。用dispatch_set_target_queue可以改变目标队列。 dispatch_set_target_queue的用法及作用： dispatch_queue_create创建队列的优先级跟global dispatch queue的默认优先级一样。如果我们要设置队列的优先级，可以使用dispatch_set_target_queue方法： dispatch_set_target_queue的第一个参数为要设置优先级的queue，第二个参数为对应的优先级参照物1234dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.example.queue&quot;,NULL);dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);//serialQueue 现在的优先级和globalQueue的优先级一样dispatch_set_target_queue(serialQueue,globalQueue); 使用dispatch_set_target_queue修改用户队列的目标队列，使多个serial queue在目标queue上一次只有一个执行阐述： 当用dispatch_queue_create函数生成多个serial dispatch queue时，每个serial dispatch queue均获得一个线程，即多个serial dispatch queue可并发执行，同时处理多个serial dispatch queue中的任务，但要注意如果过多的使用多线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的相应性能。所以我们只是为了避免多个线程更新相同资源导致数据竞争时，使用dispatch_serial_queue. 第一种情况：使用dispatch_set_target_queue实现队列的动态调度管理1234567891011121314151617181920212223242526272829303132//1.创建一个目标队列dispatch_queue_t targetQueue = dispatch_queueu_create(&quot;test.target.queue&quot;,DISPATCH_QUEUE_SERIAL);//2.创建3个串行队列dispatch_queue_t queue1 = dispatch_queue_create(&quot;test.1&quot;,DISPATCH_QUEUE_SERIAL);dispatch_queue_t queue2 = dispatch_queue_create(&quot;test.2&quot;,DISPATCH_QUEUE_SERAIL);dispatch_queue_t queue3 = dispatch_queue_create(&quot;test.3&quot;,DISPATCH_QUEUE_SERAIL);//3.将3个穿行队列分别添加到目标队列dispatch_set_target_queue(queue1, targetQueue);dispatch_set_target_queue(queue2, targetQueue);dispatch_set_target_queue(queue3, targetQueue);dispatch_async(queue1, ^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]);NSLog(@&quot;1 in&quot;);[NSThread sleepForTimeInterval:3.f];NSLog(@&quot;1 out&quot;);&#125;);dispatch_async(queue2, ^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]);NSLog(@&quot;2 in&quot;);[NSThread sleepForTimeInterval:5.f];NSLog(@&quot;2 out&quot;);&#125;);dispatch_async(queue3, ^&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]);NSLog(@&quot;3 in&quot;);[NSThread sleepForTimeInterval:1.f];NSLog(@&quot;3 out&quot;);&#125;); 打印结果1234567892017-03-25 16:14:19.017 test[1361:83485] &lt;NSThread: 0x6080000754c0&gt;&#123;number = 4, name = (null)&#125;2017-03-25 16:14:19.019 test[1361:83485] 1 in2017-03-25 16:14:22.091 test[1361:83485] 1 out2017-03-25 16:14:22.092 test[1361:83485] &lt;NSThread: 0x6080000754c0&gt;&#123;number = 4, name = (null)&#125;2017-03-25 16:14:22.092 test[1361:83485] 2 in2017-03-25 16:14:27.165 test[1361:83485] 2 out2017-03-25 16:14:27.166 test[1361:83485] &lt;NSThread: 0x6080000754c0&gt;&#123;number = 4, name = (null)&#125;2017-03-25 16:14:27.166 test[1361:83485] 3 in2017-03-25 16:14:28.236 test[1361:83485] 3 out 使用之队列暂停dispatch_set_target_queue(Dispatch QueueA, Dispatch QueueB);那么dispatchA上还未运行的block会在dispatchB上运行。这时如果暂停dispatchA运行：dispatch_suspend(dispatchA);这时则只会暂停dispatchA上原来的block的执行，dispatchB的block则不受影响。而如果暂停dispatchB的运行，则会暂停dispatchA的运行。这里只简单举个例子，说明dispatch队列运行的灵活性，在实际应用中你会逐步发掘出它的潜力。dispatch队列不支持cancel（取消），没有实现dispatch_cancel()函数，不像NSOperationQueue，不得不说这是个小小的缺憾👉需要注意的是：dispatch_suspend 必须与dispatch_resume结合使用，必须具有对应关系。有多少dispatch_suspend就得有多少dispatch_resume 块被添加到队列后，就会按照添加的顺序执行，无法取消，也无法更改相对于队列中其他块的顺序。但是如果你想让高优先级块插队呢？如下代码所示，创建两个队列，一个高优先级和一个低优先级，使高优先级队列是低优先级队列的目标队列。12345678910dispatch_queue_t low = dispatch_queue_create(&quot;low&quot;,DISPATCH_QUEUE_SERIAL);dispatch_queue_t high = dipatch_queue_create(&quot;hight&quot;,DISPATCH_QUEUE_SERAIL);//设置high作为low的目标队列dispatch_set_target_queue(low,high);通常是分派到低优先级队列：dispatch_async(low,^&#123;/*低优先级块*/&#125;);//要分派到高优先级队列，暂停低优先级队列，并且在高优先级块结束后恢复低优先级队列：dispatch_suspend(low);dispatch_async(^high,^&#123;/*高优先级*/&#125;);dispatch_resume(low); 3.2 用分派屏障创建同步点分派屏障(dispatch barrier)可以在并发队列内部创建一个同步点,当它运行时，即使有并发的条件和空闲的处理器核心，队列中的其他块也不能运行。听起来像是一个互斥(写入)锁，的确如此，没有屏障的块可以看做共享（读取）锁。只要所有对资源的访问都是通过队列进行的，那么屏障就能以极低的代价提供同步。作为比较，可以用@synchronize 管理多线程访问，它会在参数上加一个互斥锁，如下所示12345678910-(id)objectAtIndex:(NSUInteger)index&#123;@synchronized (self) &#123;return [self.arr objectAtIndex:index];&#125;&#125;-(void)insertObject:(id)obj atIndex:(NSUInteger)index&#123;@synchronized (self) &#123;[self.arr insertObject:obj atIndex:index];&#125;&#125; @synchroneze很易用，但是当竞争资源很少时成本很高。有很多其他方法，速度快的复杂，简单的又很慢。GCD屏障提供了很好的平衡 GCD屏障提供了很好的平衡12345678910111213-(id)objectAtIndex:(NSUInteger)index&#123;__block id obj;dispatch_sync(self.concurrentQueue, ^&#123;obj = [self.arr objectAtIndex:index];&#125;);return obj;&#125;-(void)insertObject:(id)obj atIndex:(NSUInteger)index&#123;//用dispatch_barrier_async来确保写入时的互斥访问dispatch_barrier_async(self.concurrentQueue, ^&#123;[self.arr insertObject:obj atIndex:index];&#125;);&#125; 所需的只是一个concurrentQueue属性，用dispatch_queue_create 带上DISPATCH_QUEUE_CONCUREENT选项创建。在读取代码中，用dispatch_sync等待读取结束。在GCD中创建并分派块的开销很小，所以这种方法比互斥锁快很多。对于写入代码，用dispatch_barrier_async来确保写入时的互斥访问。通过异步调用，写入代码可以很快返回。 3.3 分派组分派组类似于NSOperation中的依赖关系，首先，创建一个组：dispatch_group_t group = dispatch_group_creat();注意： 组本身没有任何的配置选项，它们没有绑到任何队列上，只是一组块。一般通过dispatch_group_async把块添加到组，类似于dispatch_async: dispatch_group_async(group, queue, block); 然后用dispatch_group_notify注册一个块，即当组执行完毕后调用它：dispatch_group_notify(group,queue,block); 组中所有的块执行完毕时，block就会被调度到queue上。可以通过同一个组的多个通知，如果你愿意的话，也可以把这些通知块调度在不同的队列上。如果调用dispatch_group_notify时队列上没有任何的block，那么就会马上触发通知。可以在配置组时用dispatch_suspend 暂停队列来阻止这种情况，配置完成后，用dispatch_resume启动队列 A B C D 4个并发下载任务，怎样在第一时间知道任务全部完成？12345dispatch_group_t group = dispatch_groupo_create();//将某个任务放进group中dispatch_group_async(group, dispatch_get_global_queue(0,0),^&#123;//任务代码1&#125;);dispatch_group_async(group, dispatch_get_global_queue(0,0),^&#123;//任务代码2&#125;);dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;isover&quot;);&#125;); 首先进行异步执行，因为dispatch_group_wait是阻塞的，for里面安排了三个任务，这三个任务都是加载，在任务开始前 调用 enter，任务完成时调用leave，wait函数一直阻塞，直到它发现group里面的任务全部leave，它才放弃阻塞（任务全部完成）,然后我们在主线程更新UI告知用户.123456789101112131415dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;for (int i = 0; i &lt; 3; i ++)&#123;dispatch_group_enter(group);NSLog(@&quot;%d&quot;,i);dispatch_group_leave(group);&#125;&#125;);//dispatch_group_wait函数是阻塞的dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_async(dispatch_get_main_queue(), ^&#123;// 主线程处理NSLog(@&quot;over&quot;);&#125;);NSLog(@&quot;-----&quot;); 实际上，组并不像追踪任务那么追踪块，可以直接用dispatch_group_enter和dispatch_group_leave增加和减少任务数量。所以，dispatch_group_async的效果和下面的代码一样：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[截图方法]]></title>
      <url>%2F2017%2F03%2F21%2F%E6%88%AA%E5%9B%BE%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718@implementation UIImage (ShotView)+(UIImage *)shopOfView:(UIView *)view&#123;BOOL b = CGRectIsEmpty(view.bounds);NSLog(@&quot;%d&quot;,b);UIGraphicsBeginImageContextWithOptions(view.bounds.size, NO, 0);//这个方法drawViewHierarchyInRect:afterScreenUpdates:出现在iOS7，所以这里先判断是否实现了这个方法//优先使用这个方法，它比renderInContext:方法渲染速度上快15倍if ([view respondsToSelector:@selector(drawViewHierarchyInRect:afterScreenUpdates:)]) &#123;[view drawViewHierarchyInRect:view.bounds afterScreenUpdates:NO];&#125;else&#123;[view.layer renderInContext:UIGraphicsGetCurrentContext()];&#125;UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return image;&#125;@end 使用drawViewHierarchyInRect:afterScreenUpdates:可能出现的崩溃原因：(1)Frame为empty时会崩溃(iOS7)加入判断1if(CGRectIsEmpty(view.frame))&#123;return nil;&#125; (2)当视图快速切换时的崩溃这个崩溃是使用了while循环连续截屏100次webview发现的,崩溃为EXE_BAD_ACCESS原因是afterScreenUpdates设置为了YES.为什么会崩溃呢?因为设置为YES后,这些方法会等在view update结束在执行,如果在update结束前view被release了,会出现找不到view的问题.所以需要设置为NO.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Core Animation]]></title>
      <url>%2F2017%2F03%2F20%2FCore-Animation%2F</url>
      <content type="text"><![CDATA[两种主要的动画系统： 视图动画和Core Animation框架 你将了解到如何使用Core Animation图层进行绘制及以及如何在二维或三维中移动图层。 1.视图动画 改变背景颜色的动画在HUD式界面中尤为有用，可以在近乎透明与不透明的背景间切换。这比单纯改变alpha(透明度)的动画效果更好。 2.管理用户交互 很多时候不应该允许用户在上一个动画命令执行的时候发送新的命令。方法有两种：1.视图动画中自动停止响应用户交互。当它处于动画的过程当中，触摸它并不会生成任何的事件。所以只要保证动画的发起者和动画的执行者是同一对象就能够做到在动画过程中禁止交互。2.处在动画中忽略触摸事件，代码如下：123456789101112-(void)dropAnimate:(UIGestureRecognizer *)recognizer&#123;[UIView animateWithDuration:3 animations:^&#123;recognizer.enabled = NO;self.circleView.center = CGPointMake(100, 300);&#125; completion:^(BOOL finished) &#123;[UIView animateWithDuration:1 animations:^&#123;self.circleView.center = CGPointMake(250, 300);&#125; completion:^(BOOL finished) &#123;recognizer.enabled = YES;&#125;];&#125;];&#125; 不过你可能想要在动画进行时对视图禁用所有用户交互。这种情况下，你可以使用self.view.userInteractionEnabled替换recognizer.enabled. 3.绘制图层 视图动画有很多限制。动画的基本单元是UIView，它是非常重量级的对象，所以不能多用。 Core Animation中最基础也最重要的部分是CALayer。 CALayer在很多方面都与UIView非常相似。它拥有位置、大小、变形和内容。可以用Core Graphics来覆盖绘制方法以绘制定制内容。 UIView是一个相当重量级的对象，它管理着绘制与事件处理。CALayer完全关乎绘制。事实上，UIView依靠CALayer来管理绘制。 每个UIView都有一个CALayer用于绘制。 图层会在它的contents属性(即CGImage)中绘制任意东西。你需要负责进行设置，这里有多种方法可用。最简单的一种方法是直接分配，如以下代码123UIImage *image = ...;CALayer *layer = ...;layer.contents = (id)[image CGImage]; 如果你没有直接设置contents属性，Cora Animation会按照以下顺序通过CALayer和委托方法来创建它。(1)[CALayer setNeedsDisplay] : 你的代码需要直接调用它。它会将图层标记为需要重绘的，要求通过列表中的步骤来更新contents。除非调用了setNeedsDisplay方法，否则contents属性永远不会被更新。(2)[CALayer displayIfNeeded]: 绘制系统会在需要时自动调用它。如果图层被通过调用setNeedsDisplay标记为需要重绘的，绘制系统会接着执行后续步骤。(3)[CALayer display]: displayIfNeeded方法会在何时的时候调用它。开发者不应该自动调用它，如果实现了委托方法，默认实现会调用displayLayer:委托方法。否则，display方法会调用drawInContext:方法。可以在子类中覆盖display方法以直接设置contents属性。(4)[delegate displayLayer]: 默认的[CALayer display]会在方法实现这个方法时调用它。它的任务是设置contents。如果实现了这个方法(即使没有什么操作),后面就不会运行自定义的绘制代码。(5)[CALayer drawInContext:]:默认的display方法会创建一个视图图形上下文并将其传递给drawInContext：方法。它与[UIView drawRect:]方法相似，但不会自动设置UIKit上下文。为了使用UIKit来绘图，你需要调用UIGraphicsPushContext()方法制定接收到的上下文为当前上下文。否则，它只会使用Core Graphics在接收到的上下文中绘图。默认的display方法获取最终的上下文，创建一个CGImage并将其分配给contents。默认的[CALayer drawInContext:]会在方法已实现时调用[delegate drawLayer:inContext:].否则，就不执行任何操作。注意，你可以直接调用这个方法。(6)[delegate drawLayer:inContext:]:如果实现了这个方法，默认的drawInContext:会调用这个方法以更新上下文，从而使display方法可以创建CGImage。 可以看见，有多种方法可以设置图层的内容。可以直接调用setContents:方法，也可以通过实现display或displayLayer:方法做到，还可以实现drawInContext:或drawLayer:inContext:方法。 绘图系统几乎不会像UIView一样经常自动更新内容。比如说，UIView在屏幕上第一次出现时会对自身进行绘制，而CALayer则不会。使用setNeedsDisplay方法标记UIView为需要重绘的，这样就可以自动绘制所有子视图了。使用setNeedsDisplay方法标记CALayer为需要绘制的则并不会对子视图产生影响。需要记住的是：UIView默认会在它认为你需要的时候绘制，而CALayer默认只会在你明确要求时绘制。CALayer是很底层的对象，它经过了优化，除非开发者明确要求，否则它不会浪费时间执行任何操作。 3.1 直接设置内容123456UIImage *image = [UIImage imageNamed:@&quot;下载&quot;];//直接设置contents来设置内容的显示self.view.layer.contents = (id)[image CGImage];//类似于UIView中的contentModeself.view.layer.contentsGravity = kCAGravityCenter;self.view.layer.contentsScale = [UIScreen mainScreen].scale; 3.2 实现display方法display和displayLayer:方法的认识是把contents属性设置为合适的CGImage。你可以使用任何方法做到这一点。默认的实现是创建一个CGContext，并将其传递给drawInContext:方法，绘制结果在CGImage上，然后复制给contents。一般覆盖方法的原因是图层有多种状态并且都有各自的图片，按钮通常就是这样。通过文件束(bundle)加载、用Core Graphics绘制或其他方法都可以。到底是创建CALayer的子类还是使用委托完全取决于个人的喜好和是否方便。UIView包含了一个图层，而且它必须是该图层的委托。根据我的经验，最好不要将UIView作为任何子视图的委托。这样做会让UIView在执行某些复制子视图的操作(比如过渡)时出现无限死循环。因此，你可以在UIView中实现displayLayer:方法来管理它的图层。或者将其他对象作为子图层的委托。在我们看来，在UIView中实现displayLayer:方法意义不大。如果你的视图内容只是一些图片，一般建议使用UIImageView或一个UIButton，这种方式比使用手工加载图层内容的自定义UIView要好一些。UIImageView针对图片显示进行过高度优化UIButton擅长根据状态进行图片切换，并且拥有很多优秀的用户界面机制，而要重制这些机制是很麻烦的事。不要在Core Animation中彻底改造UIKit。UIKit的默认功能恐怖比你实现的要好。更有意义的可能是将UIViewController作为图层的委托，尤其是在没有创建UIView的子类的时候，如果你的需求是很简单的话，这样可以避免使用其他对象或子类。只是，不要让你的UIViewcontroller过于复杂。 3.3 自定义绘制 与UIView类似，也可以完全让CALayer实现自定义绘图。一般可以使用Core Graphics来绘制。不过使用UIGraphicsPushContext方法的话，也可以通过UIKit绘制。 使用drawInContext:方法是设置contents的另一种方法。它是通过display方法调用。而display方法只有当你通过setNeedsDisplay方法明确标记图层需要重绘时被调用。与直接设置contents的方法相比，这里的优势在于display会自动创建适用于图层的CGContext。特别是坐标系统的翻转。以下代码展示了如何实现委托方法drawLayer:inContext:，以便在图层顶端通过UIKit绘制字符串。因为Core Animation不会设置UIKit上下文内容，所以你需要在调用UIKit方法之前调用UIGraphicsPushContext方法，并在代码结束之前调用UIGraphicsPopContext方法。1234567891011121314151617181920212223242526272829303132333435363738394041@implementation DelegateView/*** 创建UIView的时候，完成对自身layer层的初始设置**/-(void)awakeFromNib&#123;[super awakeFromNib];[self initialization];&#125;-(instancetype)initWithFrame:(CGRect)frame&#123;self = [super initWithFrame:frame];if (self) &#123;[self initialization];&#125;return self;&#125;-(void)initialization&#123;//图层的绘制需要手动调用setNeedsDisplay,图层在屏幕上显示时不能自动重回自身。需要手动标记[self.layer setNeedsDisplay];[self.layer setContentsScale:[UIScreen mainScreen].scale];&#125;//由-drawInContext: defalut implementation调用-(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&#123;UIGraphicsPushContext(ctx);[[UIColor whiteColor] set];UIRectFill(layer.bounds);UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];UIColor *color = [UIColor blackColor];NSMutableParagraphStyle *style = [NSMutableParagraphStyle new];[style setAlignment:NSTextAlignmentCenter];NSDictionary *attribs = @&#123;NSFontAttributeName: font,NSForegroundColorAttributeName: color,NSParagraphStyleAttributeName: style&#125;;NSAttributedString *text = [[NSAttributedString alloc] initWithString:@&quot;Pushing The Limits&quot; attributes:attribs];[text drawInRect:CGRectInset([layer bounds], 10, 100)];UIGraphicsPopContext();&#125;@end 当使用drawLayer:inContext:进行自定义绘图时，大部分自动图层设置(比如backgroundColor和cornerRadius)会被忽略。如果你想要实现自定义绘图与圆角效果等图层效果，可以在子图层上进行自定义绘制并在父图层上使用圆角。3.4 在自己的上下文中绘图与[UIView drawRect:]不同，你完全可以调用[CALayer drawInContext:]方法。只需要生成一个上下文并将其传递进去，这样便于捕捉图层内容到位图或PDF，然而你就可以保存或打印它了。如果想要拼合图层，像这样调用drawInContext:会很有帮助，因为如果你想要的只是位图，直接使用contents就可以了。drawInContext:只在当前图层绘制(不包括其任何子图层)。要绘制图层及其子图层，可以使用renderInContext:方法，它可以捕捉当前动画的状态。 补充：1.drawInContext:的使用示例代码：1234567891011-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;//开启一个位图上下文UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);CGContextRef ctx = UIGraphicsGetCurrentContext();//这个方法的调用的默认实现会调用drawLayer:inContext:在这个方法中完成绘制。[self.layer drawInContext:ctx];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();NSData *imageData = UIImagePNGRepresentation(image);[imageData writeToFile:@&quot;/Users/xxx/Desktop/testImg.png&quot; atomically:YES];&#125; 2.renderInContext://iOS 7上UIView上提供了drawViewHierarchyInRect:afterScreenUpdates:来截图，速度比renderInContext:快15倍12345678UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);CGContextRef ctx = UIGraphicsGetCurrentContext();//这个方法的内部并不会调用到drawLayer:inContext:[self.layer renderInContext:ctx];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();NSData *imageData = UIImagePNGRepresentation(image);[imageData writeToFile:@&quot;/Users/xxx/Desktop/testImg.png&quot; atomically:YES]; 4.移动对象👉图层默认就是实现动画的👈事实上，我们需要通过少量的工作阻止动画执行.12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123;[super viewDidLoad];CALayer *squareLayer = [CALayer layer];squareLayer.backgroundColor = [[UIColor redColor] CGColor];squareLayer.frame = CGRectMake(100, 100, 20, 20);[self.view.layer addSublayer:squareLayer];UIView *squareView = [UIView new];squareView.backgroundColor = [UIColor blueColor];squareView.frame = CGRectMake(200, 100, 20, 20);[self.view addSubview:squareView];[self.view addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:selfaction:@selector(drop:)]];&#125;//需要注意的是是，这里在打开autoLayout的时候，不会产生任何的移动，当关闭autolayotu的时候，动画产生- (void)drop:(UIGestureRecognizer *)recognizer &#123;NSArray *layers = self.view.layer.sublayers;CALayer *layer = [layers objectAtIndex:0];CGPoint toPoint = CGPointMake(200, 250);[layer setPosition:toPoint];NSArray *views = self.view.subviews;UIView *view = [views objectAtIndex:0];[view setCenter:CGPointMake(100, 250)];&#125; 这段代码当点击视图时，它们都会移动。视图会立刻蹦到新的位置上。图层动画持续稍大于1/4秒。很快，不过不像视图那么迅速。CALayer隐式为所有支持动画的属性添加动画。(Animatable标记的属性)你可以禁止动画来阻止动画1[CATransaction setDisableActions:YES]; 4.1 隐式动画：可以看见，只需要设置图层属性，图层就会以默认方式执行动画。不过，可能你并不喜欢默认的设定，当需要更改动画的持续时间，需要理解事务(transaction).Core Animation把属性的更改绑定到了原子事务(CATransaction),当你首次在一个👉包含运行循环的线程👈中修改一个图层时,系统会为你创建一个隐式CATransaction。在运行循环中，所有的图层修改都会被收集起来，当运行结束的时候，所有的修改都会被提交到图层树。如果需要修改动画，需要对当前事务进行修改。比如更改当前事务的持续时间1[CATransaction setAnimationDuration:2.0]; 使用[CATransaction setCompletionBlock:]设置一个完成代码块，当当前事务完成动画后运行。可以使用这种方式👉链接多个动画👈虽然运行循环会自动创建一个事务，但你可以通过[CATransaction begin]和[CATransaction commit]创建自己的显示事务。 4.2 显式动画1234567CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];anim.fromValue = @1.0;anim.toValue = @0.0;anim.autoreverses = YES;anim.repeatCount = INFINITY;anim.duration = 2.0;[CALayer addAnimation:anim forKey:@&quot;anim&quot;]; 移除这个动画1[CALayer removeAnimationForKey:@&quot;anim&quot;]; 如果图层中有自定义属性，你可能会注意到它们在动画运行中没有被正确设置。这是因为图层被复制了。 4.3 模型与表示闪回再现：123456CABasicAnimation *fade;fade = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];fade.duration = 1.0;fade.fromValue = @1.0;fade.toValue = @0.0;[CALayer addAnimation:fade forKey:@&quot;fade&quot;]; 模型层是由真正的CALayer对象的属性定义的。CAAnimation创建了CALayer的副本并对其进行修改，使其变成表示层。 CAAnimation修改了表示层，表示层将被绘制到屏幕，绘制完成后，所有的更改都会丢失并由模型层决定新的状态。解决办法如下：123456789//这里的模型状态为0.当动画结束的时候，图层的状态将停留在模型状态。layer.opacity = 0;CABasicAnimation *fade;fade = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];//这里将显示出opacity从1到0的变化，并且动画结束的时候停留在0.fade.duration = 1.0;fade.fromValue = @1.0;fade.toValue = @0.0;[layer addAnimation:fade forkey:@&quot;opacity&quot;]; 有时它能正确工作，但是有时opacity:中的隐式动画会与animationWithKeyPath:的显示动画冲突。所以最好的解决办法是在执行显式动画时关闭隐式动画：123456789[CATransaction begin];//执行显式动画，关闭隐式动画[CATransaction setDisableActions:YES];layer.opacity = 0;CABasicAnimation *fade;fade = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];...[layer addAnimation:fade forKey:@&quot;fade&quot;];[CATransaction commit]; 4.4 关于定时：Core Animation中的时间是相对的。一秒时间并不一定是一秒钟，与坐标一样，时间是可以缩放的。 CAAnimaition 遵守CAMediaTiming协议，可以设置其speed属性来缩放它的时间跨度。因此若要执行图层之间的时间，需要对它进行转换，就像转换不同视图或图层中的点一样12localPoint = [self convertPoin:remotePoint fromLayer:otherLayer];localTime = [self convertTime:remotetime fromLayer:otherLayer]; 这种情况并不多见，但在协调动画时会出现。你可能会使用其他图层的特定动画，在动画要结束时便开始自己的动画。123CAAnimation *otherAnim = [layer animationForKey:@&quot;anim&quot;];CFTimeInterval finish = otherAnim.beginTime + otherAnim.duration;myAnim.beginTime = [self convertTime:finish fromeLayer: layer]; 如果想要引用当前时间，可以使用CACurrentMediaTime(). 12345678910111213141516CALayer *squareLayer = [CALayer layer];squareLayer.backgroundColor = [[UIColor redColor] CGColor];squareLayer.frame = CGRectMake(100, 100, 20, 20);[self.view.layer addSublayer:squareLayer];[CATransaction begin];CABasicAnimation *anim;anim = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];anim.fillMode = kCAFillModeBoth;anim.fromValue = @1.0;anim.toValue = @0.5;anim.duration = 5.0;anim.beginTime = CACurrentMediaTime() + 3.0;[squareLayer addAnimation:anim forKey:@&quot;fade&quot;];squareLayer.opacity = 0.5;[CATransaction commit]; 在图层中，可以通过添加视角来应用三维变形。这常称为2.5D。旋转图层基于一个锚点进行。三维动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@implementation ViewControllerconst CGFloat kSize = 100.;const CGFloat kPanScale = 1./100.;-(CALayer *)layerWithColor:(UIColor *)color transform:(CATransform3D)transform&#123;CALayer *layer = [CALayer layer];layer.backgroundColor = [color CGColor];layer.bounds = CGRectMake(0, 0, kSize, kSize);//设置positionlayer.position = self.view.center;layer.transform = transform;[self.view.layer addSublayer:layer];return layer;&#125;static CATransform3D MakePerspectiveTransform() &#123;CATransform3D perspective = CATransform3DIdentity;perspective.m34 = -1./2000.;return perspective;&#125;- (void)viewDidLoad &#123;[super viewDidLoad];CATransform3D transform;transform = CATransform3DMakeTranslation(0, -kSize/2, 0);transform = CATransform3DRotate(transform, M_PI_2, 1.0, 0, 0);self.topLayer = [self layerWithColor:[UIColor redColor]transform:transform];transform = CATransform3DMakeTranslation(0, kSize/2, 0);transform = CATransform3DRotate(transform, M_PI_2, 1.0, 0, 0);self.bottomLayer = [self layerWithColor:[UIColor greenColor]transform:transform];transform = CATransform3DMakeTranslation(kSize/2, 0, 0);transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);self.rightLayer = [self layerWithColor:[UIColor blueColor]transform:transform];transform = CATransform3DMakeTranslation(-kSize/2, 0, 0);transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);self.leftLayer = [self layerWithColor:[UIColor cyanColor]transform:transform];transform = CATransform3DMakeTranslation(0, 0, -kSize/2);transform = CATransform3DRotate(transform, 0, 0, 0, 0);self.backLayer = [self layerWithColor:[UIColor yellowColor]transform:transform];transform = CATransform3DMakeTranslation(0, 0, kSize/2);transform = CATransform3DRotate(transform, 0, 0, 0, 0);self.frontLayer = [self layerWithColor:[UIColor magentaColor]transform:transform];self.view.layer.sublayerTransform = MakePerspectiveTransform();UIGestureRecognizer *g = [[UIPanGestureRecognizer alloc]initWithTarget:selfaction:@selector(pan:)];[self.view addGestureRecognizer:g];&#125;- (void)pan:(UIPanGestureRecognizer *)recognizer &#123;CGPoint translation = [recognizer translationInView:self.view];CATransform3D transform = MakePerspectiveTransform();transform = CATransform3DRotate(transform,kPanScale * translation.x,0, 1, 0);transform = CATransform3DRotate(transform,-kPanScale * translation.y,1, 0, 0);//sublayerTransform 一个针对所有子视图层但对当前图层无效的变形 self.view.layer.sublayerTransform = transform;&#125;@end 在这里所有的图层拥有相同的position。，它们只是把方形经过平移和旋转的变形结果形状显示在屏幕上。3D变形矩阵的m34位置应该设置为-1/EYE_DISTANCE.大多数情况下，2000个单位就可以做到很好了。 6.美化土图层 12345678910-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;CALayer *layer = self.layer;[CATransaction begin];[CATransaction setAnimationDuration:2];layer.cornerRadius = 10;layer.borderWidth = 5;layer.shadowOpacity = 0.5;layer.shadowOffset = CGSizeMake(3.0, 3.0);[CATransaction commit];&#125; 7.用动作实现自动动画通过CATransaction关闭隐式动画，只对当前事务(通常就是当前的运行循环)有效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用CFAbsoluteTimeGetCurrent() 计算时间差]]></title>
      <url>%2F2017%2F03%2F19%2F%E5%88%A9%E7%94%A8CFAbsoluteTimeGetCurrent-%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE%2F</url>
      <content type="text"><![CDATA[开发中，遇到计算时间差的问题，利用CFAbsoluteTimeGetCurrent()可以方便的进行计算 场景：类似购物车中修改商品数量的功能，要求，修改完的数量，要同步到服务器。 分析：如果点击“+”或者“-”，立即进行服务器同步的话，代价貌似有些高，所以采用延时提交的方法：“连续”点击的时候，不提交到服务器，点击停止，进行同步。这个项目中，“连续”点击的判断，采用的是判断两次点击的时间差，如果时间差小于一定的数值（本例中，这个数值是2），那么即可判定是连续点击的操作。代码如下： 12345678910111213141516-(void)editCount&#123; double diff = 0; if(_startTime == 0)&#123; _startTime = CFAbsoluteTimeGetCurrent(); _endTime = _startTime; &#125;else&#123; _endTime = CFAbsoluteTimeGetCurrent(); diff = _endTime - _startTime; _startTime = _endTime; &#125; if(diff &lt; 2)&#123; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(willUpdateServerCartWithCount) object:nil]; &#125; [self performSelector:self withObject:@selector(willUpdateServerCartWithCount) afterDelay:2.0];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[inline 内联函数]]></title>
      <url>%2F2017%2F03%2F19%2Finline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[YYKit中对对内联函数的使用： 12345static inline void dispatch_async_on_main_queue(void (^block)())&#123; if(pthread_main_np())&#123; block(); &#125;else&#123; dispatch_async(dispatch_get_main_queue(),block); &#125;&#125; 使用这个函数1dispatch_async_on_main_queue(^&#123;&#125;); 比下面这个方式更加的简洁：1dispatch_async(dispatch_get_main_queue(),^&#123;&#125;); 又比如像这样的使用：123456789101112static inline CGFloat CGFloatFromePixel(CGFloat value)&#123; return value/YYScreenScale();&#125;CGFloat YYScreenScale()()&#123; static CGFloat scale; static dispatch_once_t onceToken; dispatch_once(&amp;oneceToken,^&#123; scale = [UIScreen mainScreen].scale; &#125;); return scale;&#125; 内联函数是指inline修饰的函数。内联函数不是在调用时发生转移，而是在编译时将函数体嵌入到每一个调用处。编译时，类似于宏替换，使用函数体替换调用处的函数名。C99中inline就是对编译器的一个提示。 它的出现，主要是用它来替代C中表达式形式的宏定义。 表达式形式的宏定义一例：1#define ExpressionName(Var1,Var2) (Var1+Var2)*(Var1-Var2) 使用这样的宏定义无法进行参数有效性的检验。它的返回值也不能被强制转换为可转换的合适的类型。 可以使用inline函数完全替代表达式形式的宏定义。 使用内联函数能够解决函数调用的效率问题： 函数之间调用，是内存地址之间的调用，当函数调用完毕之后还会返回原来函数执行的地址。函数调用有时间开销，内联函数就是为了解决这一问题。 inline内联函数的使用说明： * 内联函数只是我们向编译器提供的申请,编译器不一定采取inline形式调用函数. * 内联函数不能承载大量的代码.如果内联函数的函数体过大,编译器会自动放弃内联. * 内联函数内不允许使用循环语句或开关语句. * 内联函数的定义须在调用之前.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[更完善的自定义绘制]]></title>
      <url>%2F2017%2F03%2F18%2F%E6%9B%B4%E5%AE%8C%E5%96%84%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%98%E5%88%B6%2F</url>
      <content type="text"><![CDATA[1.UIKit和视图绘图周期： 如果要改变视图的大小或显示，画一条线，或者改变一个对象的颜色，这些改变不会立刻显示出来。有时，这会让编写如下不恰当代码的开发人员感动迷惑：123456&#123;progressView.hidden = NO; //这一行什么也不做//在这里做一些耗时的操作[self doSometingTimeConsuming];progressView.hidden = YES;&#125; 第一行（progressView.hidden = NO）实际上根本没有作用，理解这一点很重要。这行代码不会使进度视图在执行耗时操作的时候显示出来。无论这个方法运行多久，都不会看到视图显示出来 下图展示了绘图循环中实际会发生的步骤： 所有的绘制都发生在主线程，只要代码运行在主线程，就没有东西可以绘制。在主线程中执行长时间运行操作，会阻碍事件的处理，也会阻碍绘制更新。 如何开始和停止一个长时间运行操作的活动指示器？采用调度或执行队列来将耗时的任务放入后台，同时创建如下在主线程中进行UIKit调用的代码：12345678910111213141516-(IBAction)doSomething:(UIButton *)sender&#123;//避免执行任务期间反复点击[sender setEnabled:NO];[self.activity startAnimation];//把耗时的操作放在后台线程，让当前方法迅速执行完，而不是因为耗时操作而阻塞在这里，而阻碍绘制更新，阻碍触摸事件dispatch_queue_t bgQueue = dispatch_get_global_queue(0, 0);dispatch_async(bgQueue, ^&#123;//耗时操作[self doSomethingTimeConsuming];//回到主线程绘图dispatch_async(dispatch_get_main_queue(), ^&#123;[self.activity endAnimation];[sender setEnabled:YES];&#125;);&#125;);&#125; 2.视图绘制与视图布局 UIView将子视图的布局(重新排列)从绘图(显示)中独立出来。这对极大程度的优化性能很重要，因为布局的成本通常要比绘制低。布局的成本之所以低，是因为UIView的缓存通过GPU优化的位图进行绘图操作。使用GPU，可以使这些位图的移动，显示，隐藏，旋转，甚至变形和合并的成本非常低。 如果对一个视图调用setNeedsDisplay方法，它被标记为“需要刷新的”，并且会在下一次绘图周期中重新绘制。除非视图的内容真的会发生变化，否则请不要调用它。大部分UIKit视图会在其数据发生变化时自动管理重绘操作，因此除了自定义的视图，一般并不需要调用setNeedsDisplay。 旋转设备或滚动视图后，子视图需要重新排列，这时UIKit会调用setNeedsLayout，也就是对于发生变化的视图逐次调用layoutSubViews方法。覆盖layoutSubviews的话，就可以让应用在设备旋转或视图滚动时更加流畅。不必重绘就能重新排列子视图的位置，还可以根据设备方向显示隐藏视图。如果数据改变后只需要进行布局更新(而非绘制)，则可以调用setNeedsLayout方法。 3.自定义视图绘制 视图可以通过子视图、图层或实现drawRect：方法来表现内容。通常来说，如果实现了drawRect：方法，最好就不要再混用图层与子视图了。2D绘图并不能操作单独的像素，因为像素是依赖目标的。可以从位图上下文中读取它，但无法使用UIKit或Core Graphics函数来直接作用于它。 4.理解坐标系 坐标、点、像素之间的微妙转换也可能降低绘制性能，到执行线条和文字模糊。观察以下代码：123456789//绘制一：CGContextSetLineWidth(context,3.);CGContextMoveLineToPoint(context,10.,100.);CGContextAddLineToPoint(context,200.,100.);CGContextStrokePath(context);//绘制二：CGContextMoveToPoint(context,10.,105.5);CGContextAddLineToPoint(context,200.,105.5);CGContextStrokePath(context); 下图展示的是在非视网膜屏幕上的输出结果，当放大的时候可以看见，两条线条之间的区别：可以看到，绘制一的结果就要模糊很多。原因在于iOS对坐标系的解读方式。构造一个CGPath时，便是使用了几何坐标系，这与数学中使用的坐标系是一样的，以两条网格线的交点来表示零坐标点。你无法绘制出真正的几何点或几何线条，因为它们都是无限小和无限细的。iOS绘制中必须将这些几何对象转换成像素坐标。像素是设备能控制的最小显示区域单位。调用CGContextStrokePath，iOS会让线条沿路径居中。理想情况下，线宽有3像素宽，所以y=98.5到y=101.5，如下图所示：在屏幕上，线条看起来有些模糊。解决这个问题的办法就是将水平或垂直的线条移动到半个点的位置，这样当iOS将线条居中时，边缘刚好就是像素的边界。或者让线条更粗一些。使用非整型宽度的线条，或者坐标系不是整型和半整型时(这个问题也使用于retina屏)，也有可能遇到这个问题。让iOS绘制小数像素时就有可能导致模糊。 填充工具与画笔不一样。画笔的线条是中心对齐路径的，而填充颜色是基于路径的。如果填充从{10,100}到{200,103}的矩形，每个像素都会被正确填充，如图目前的讨论视点与像素相同。而对于retina屏幕，也依然会因为线宽或坐标系不是整数导致显示模糊的问题。 5.变形 iOS平台使用了可以快速进行矩形计算的优秀的GPU。如果将👉绘图运算转换成矩形计算机👈，就可以发挥GPU的能力并获取卓越的功能。变形就是一种矩形运算。iOS有两种变形：仿射与3D。UIView只能处理仿射变形。仿射变形可以用矩阵运算来表现旋转、缩放、剪切以及平移。 iOS拥有支持旋转、缩放以及平移的函数。 变形可以大大简化代码，并提升它的速度。 贴上下面这样一段代码123456789101112131415161718192021222324- (void)drawRect:(CGRect)rect &#123;// Drawing codeCGSize size = self.bounds.size;CGFloat margin = 10;CGFloat radius = rintf(MIN(size.width - margin, size.height - margin) / 4);CGFloat xOffset, yOffset;CGFloat offset = rintf((size.height - size.width)/2);if (offset &gt; 0) &#123;//rint(double x)： 不大于x的最大整数，该整数是双精度实数xOffset = rint(margin / 2);yOffset = offset;&#125;else&#123;xOffset = -offset;yOffset = rint(margin / 2);&#125;[[UIColor redColor] setFill];UIBezierPath *path = [UIBezierPath bezierPath];[path addArcWithCenter:CGPointMake(radius * 2 + xOffset, radius + yOffset) radius:radius startAngle:-M_PI endAngle:0 clockwise:YES];[path addArcWithCenter:CGPointMake(radius * 3 + xOffset, radius * 2 + yOffset) radius:radius startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:YES];[path addArcWithCenter:CGPointMake(radius * 2 + xOffset, radius * 3 + yOffset) radius:radius startAngle:0 endAngle:M_PI clockwise:YES];[path addArcWithCenter:CGPointMake(radius + xOffset, radius * 2 + yOffset) radius:radius startAngle:M_PI_2 endAngle:-M_PI_2 clockwise:YES];[path closePath];[path fill];&#125; 运行得到的效果：从这段代码可以看出，这里包括太多的输入与运算，很多时候，在坐标系空间中围绕原点进行绘制然后对绘制进行缩放、旋转、平移而更简单。如果把图形绘制在一个4x4的格子中会怎样？ 现在绘制的计算就变得非常简单：1234567891011121314151617181920212223- (void)drawRect:(CGRect)rect &#123;CGSize size = self.bounds.size;CGFloat margin = 10;[[UIColor redColor] set];UIBezierPath *path = [UIBezierPath bezierPath];[path addArcWithCenter:CGPointMake(0, -1) radius:1 startAngle:-M_PI endAngle:0 clockwise:YES];[path addArcWithCenter:CGPointMake(1, 0) radius:1 startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:YES];[path addArcWithCenter:CGPointMake(0, 1) radius:1 startAngle:0 endAngle:M_PI clockwise:YES];[path addArcWithCenter:CGPointMake(-1, 0) radius:1 startAngle:M_PI_2 endAngle:-M_PI_2 clockwise:YES];[path closePath];CGFloat scale = floorf((MIN(size.height, size.width) - margin) / 4);CGAffineTransform transform;transform = CGAffineTransformMake(scale, 0.0f, 0.f, scale, size.width/2, size.height/2);[path applyTransform:transform];[path fill];&#125; 这个技术可以用来以各种角度绘制复杂的形状。比如说，绘制一个指向右上角的箭头，一般先画一条指向右边的箭头再旋转它会更容易。可以选择使用applyTransform:对路径进行变形。 6.通过Core Graphics进行绘制绘制效果：绘制代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#import &quot;TCView.h&quot;@interface TCView()@property(nonatomic, readwrite, strong) NSMutableArray *values;@property(nonatomic,readwrite, strong) dispatch_source_t timer;@end@implementation TCViewconst CGFloat kXScale = 5.0;const CGFloat kYScale = 100.0;static inline CGAffineTransform CGAffineTransformMakeScaleTranslate(CGFloat sx,CGFloat sy, CGFloat dx, CGFloat dy)&#123;return CGAffineTransformMake(sx, 0.f, 0.f, sy, dx, dy);&#125;-(void)awakeFromNib&#123;[super awakeFromNib];[self setContentMode:UIViewContentModeRight];self.values = [NSMutableArray array];__weak typeof (self) weakSelf = self;double delayInseconds = 0.25;self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());//设置timerdispatch_source_set_timer(self.timer, dispatch_walltime(NULL, 0), (unsigned)(delayInseconds * NSEC_PER_SEC), 0);//给timer添加事件处理dispatch_source_set_event_handler(self.timer, ^&#123;[weakSelf updateValues];&#125;);//手动开始dispatch_resume(self.timer);&#125;-(void)updateValues&#123;//RAND_MAX rand()所能够获取到的最大的值//rand()返回的是int类型 random()返回的是long类型//((double)rand() / (double)RAND_MAX) 获得一个随机的0-1的double类型的数double nextValue = sin(CFAbsoluteTimeGetCurrent()) + ((double)rand() / (double)RAND_MAX);//[self.values addObject:[NSNumber numberWithDouble:nextValue]];CGSize size = self.bounds.size;//最大的尺寸//floor(x)返回的是小于或等于x的最大整数//floorl(x) 返回的类型是 long double//floorf(x) 返回类型是 floatCGFloat maxDimension = MAX(size.height, size.width);NSUInteger maxValues = (NSUInteger)floorl(maxDimension / kXScale);if ([self.values count] &gt; maxValues) &#123;[self.values removeObjectsInRange:NSMakeRange(0, [self.values count] - maxValues)];&#125;//绘制[self setNeedsDisplay];&#125;-(void)dealloc&#123;dispatch_source_cancel(_timer);&#125;- (void)drawRect:(CGRect)rect &#123;if ([self.values count] == 0) &#123;return;&#125;CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextSetStrokeColorWithColor(ctx, [[UIColor redColor] CGColor]);CGContextSetLineJoin(ctx, kCGLineJoinRound);CGContextSetLineWidth(ctx, 5);//包含所有线条的路径CGMutablePathRef path = CGPathCreateMutable();CGFloat yOffset = self.bounds.size.height / 2;//路径放大，平移路径()CGAffineTransform transform = CGAffineTransformMakeScaleTranslate(kXScale, kYScale, 0, yOffset);//CGFloat y = [[self.values objectAtIndex:0] floatValue];CGPathMoveToPoint(path, &amp;transform, 0, y);for (NSUInteger x = 1; x &lt; [self.values count]; ++x) &#123;y = [[self.values objectAtIndex:x] floatValue];CGPathAddLineToPoint(path, &amp;transform, x, y);&#125;CGContextAddPath(ctx, path);//create 的 就要releaseCGPathRelease(path);//绘制CGContextStrokePath(ctx);&#125;@end 7.混用UIKit与Core Graphics 在drawRect:方法之外你可能会发现使用Core Graphics绘制的东西会上下颠倒。UIKit遵守ULO（Upper-Left-Origin,左上角为原点）的坐标系统，而Core Graphics默认使用LLO(Lower-Left-Origin，左下角为原点)的坐标系统。只要使用在drawRect:方法中通过UIGraphicsGetCurrentContext返回的上下文，那么一切就正常了，因为这个上下文是已经反转的。不过使用CGBitmapContextCreate这样的函数创建自己的上下文，它会以左下角为原点。可以进行反向计算或者反转上下文：12CGContextTranslateCTM(ctx, 0, height);CGContextScaleCTM(ctx, 1.0f, -1.0f); 这段代码平移了上下文的高度并使用一个负数比例进行反转。如果想让UIKit使用Core graphics，变形则应该反过来：12CGContextScaleCTM(ctx,1.0f,-1.0f);CGContextTranslateCTM(ctx,1.0f,-1.0f); 先反转，再平移。 8.管理图形上下文 在调用drawRect:方法之前，绘图系统自动创建了一个图形上下文。上下文包括大量信息，比如画笔颜色、文字颜色、当前字体、变形等。有时你可能修改上下文并使其恢复原样。举个例子，你现在有一个使用特定颜色绘制特定形状的函数。由于系统只有一只笔，因此在更改颜色后，就会影响调用函数的结果。为了避免这个副作用，可以使用CGContextSaveGState和CGContextRestoreGState将上下文入栈和出栈。 CGContextSaveGState记录当前上下文的状态。UIGraphicsPushContext更改当前上下文。以下是CGContextSaveGState的示例：12345[[UIColor redColor] setFill];CGContextSaveGState(UIGraphicsGetCurrentContext());[[UIColor blackColor] setFill];CGContextRestoreGState(UIGraphicsGetCurrentContext());UIRectFill(CGRectMake(10 , 10 , 100, 100)); 在这里设置了画笔的颜色为红色，并且保存了上下文。之后将画笔颜色改为黑色并恢复上下文。这样当绘制的时候，画笔的颜色变成了红色。 使用UIGraphicsPushContext并不能保存上下文的当前状态(画笔颜色、线条宽度等)，而是完全切换上下文。假设你正在当前视图上下文中绘制什么东西，这是想要在位图上下文中绘制完全不同的东西。如果要使用UIKit来进行任意绘图，你会希望保存当前的UIKit上下文，包括所有已经绘制的内容，接着切换到一个全新的绘图上下文中。这就是UIGraphicsPushContext的功能。创建完位图后，再将你的旧上下文出栈。而这就是UIGra的功能。这种情况只会在要使用UIKit在新的位图上下文中绘图时才会发生。只要你使用的是Core Graphics函数，就不需要去执行上下文入栈和出栈，因为Core Graphics函数将上下文视作参数。 这是极其重要的常见操作。因为其常用性，苹果公司为其创建了一个叫做UIGraphicsBeginImageContext的快捷方式。它负责将旧的上下文出栈、为新的上下文分配内存、创建新的上下文，反转坐标系统，并将其作为当前的上下文使用。下面是创建一张图片并使用UIGraphicsBeginImageContext返回它的示例。12345678910111213141516-(UIImage *)reverseImageForText:(NSString *)text&#123;const size_t kImageWidth = 200;const size_t kImageHeight = 200;CGImageRef textImage = NULL;UIFont *font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];UIColor *color = [UIColor redColor];UIGraphicsBeginImageContext(CGSizeMake(kImageWidth, kImageHeight));[text drawInRect:CGRectMake(0, 0, kImageWidth, kImageHeight) withAttributes:@&#123;NSFontAttributeName: font, NSForegroundColorAttributeName: color&#125;];//UIImage -&gt; CGImagetextImage = UIGraphicsGetImageFromCurrentImageContext().CGImage;UIGraphicsEndImageContext();//orientation: 方向， UIImageOrientationDownMirrored图片水平反转return [UIImage imageWithCGImage:textImage scale:1.0 orientation:UIImageOrientationDownMirrored];&#125; 9.优化UIView绘制UIView极其子类是高度优化的，可以的话，请尽量使用它们，而不要使用自定义绘图。 避免绘图最快的绘图方式就是根本不绘制。👉iOS竭尽全力避免调用drawRect:方法👈。它😨缓存了视图的图像😨并可在开发者不介入的情况下移动、旋转并缩放它。使用一个合适的contentMode,系统在旋转或重新调整大小以调整视图时就不需要调用drawRect：方法。导致drawRect：方法运行的最常见的情况就是调用了setNeedsDisplay。请避免调用不必要的setNeedsDisplay。记住，setNeedsDisplay只是标记视图需要绘制。在单个循环事件中调用多次setNeedsDisplay,实际上并不会比调用一次的情况成本更高。 10.自定义绘图与预渲染管理复杂的绘图有两种主要方法： 利用CGPath和CGGreadient通过编码来绘制任意图像，或者使用ps这样的图形程序进行预渲染并作为图片展示出来。然而预渲染有大量缺点： 对各种分辨率的依赖。开发者可能需要管理各种版本的图片。苹果公司最初鼓励开发人员进行预渲染，因为早期的iPhone计算渐变的速度不够快。现在这个问题就没有那么明显了。目前，推荐开发者在代码量合适的情况下，尽量进行自定义绘图。这主要适用于像按钮这样的小元素。若使用了预渲染绘图，建议保持文件的“简洁”并在代码中进行加工。比如说，开发者可能会用一张图片作为按钮的背景，并在代码中处理它的圆角与阴影。这样的话，每当开发者需要作出细微的调整，就不需要重现渲染背景了。 像素对齐与模糊文本一个易引起微妙绘图问题的极常见的原因就是像素不对齐。如果要Core Graphics在某个没有对齐像素的点进行绘制，它将出现锯齿。除非对像素精度要求特别高，一般情况下要确保使用整型坐标。 通常，图形中心会影响像素对齐。因此，center属性会带来麻烦。如果将中心设置为一个整型坐标，原点就可能出现不对齐。尤其要注意文本不对齐的情况，特别是UILabel。解决的办法有两种，首先，字体大小为奇数（比如13而不是12）一般可以正确对齐。如果习惯使用奇数号字体通常可以避免这个问题。要确定避免了这个问题，需要确保通过setFrame：方法或像setAlignedCenter：这样的UIView分类设置图形为整型。1234-(void)setAlignedCenter:(CGPoint)center&#123; self.center = center; self.frame = CGRectIntegral(self.frame);&#125; 透明、不透明与隐藏 是否将视图标记为opaque并不会实际升高或降低它的透明度。绘图系统可以使用opaque进行优化。当视图标记为opaque，便是向绘图系统”许诺”即将绘制的每一个像素都要使用不透明的颜色。这便允许绘图系统忽略被覆盖在下面的视图，这样可以改善性能，尤其是在进行变形时。开发者应该尽量将视图标记为opaque，尤其是像UITableViewCell这样可以滚动的视图。不过，如果视图有特定的透明区域，或者并不绘制矩形的所有元素，设置opaque会导致不可预测的结果。 隐藏和透明视图并不接收触摸事件。不能通过设置非常低的alpha来创建”透明覆盖层”，从而捕捉触摸事件。可以创建一个透明视图并通过设置它的alpha值为1，opaque为NO，且backgroundColor为nil或[UIColor clearColor],来接收触摸事件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用运行时关联对象使用示例]]></title>
      <url>%2F2017%2F03%2F18%2F%E5%88%A9%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[使用场景模拟： 有多个按钮，当点击其中某个按钮的时候，会弹出警告框，当警告框关闭的时候，需要知道是点击了哪一个按钮。这个时候就可以使用关联引用。当点击警告框的时候，会调用代理方法，只有调用了代理方法而非按钮事件处理方法的时候，才表示用户点击了警告框，所以在代理方法中获取按钮才是正确的时候。通过关联引用可以实现这个业务：123456789101112131415161718192021222324252627#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;@implementation ViewControllerstatic const char kRepresentedObject;- (IBAction)doSomething:(id)sender &#123;UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;警告⚠️&quot; message:nildelegate:selfcancelButtonTitle:@&quot;OK&quot;otherButtonTitles:nil];objc_setAssociatedObject(alert, &amp;kRepresentedObject, sender,OBJC_ASSOCIATION_RETAIN_NONATOMIC);[alert show];&#125;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;UIButton *sender = objc_getAssociatedObject(alertView, &amp;kRepresentedObject);self.buttonLabel.text = [[sender titleLabel] text];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Core Data 学习]]></title>
      <url>%2F2017%2F03%2F17%2FCore-Data-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[通过Core Data 和 iCloud的协作实现跨设备的同步数据 Core Data 可以使用SQLite作为其后台数据存储。这为Core Data提供了一个高性能的查询引擎。相比较于平面数据文件或是plist文件进行搜索和排序，Core Data能提供更高的速度。 在任何时间只读取需要的文件， Core Data API能够节省内存。 使用NSPredicat过滤数据，使用NSSortDescriptor排序数据 Core Data 的关键组件是： 数据存储(data store)、 持久存储协调器(Persistent Store Coordinator)、 托管对象模型(Managed Object Model)、托管对象上下文(Managed Object Context) 数据存储： 保存数据的一个或一组文件。它是当保存数据消息发送到Core Data后实际写入到磁盘的文件。数据存储可以是一个二进制数据文件、一个SQLite数据文件或一个内存中的数据文件开发人员不会直接访问数据存储，持久存储协调器抽象了对数据文件的访问。 持久存储协调器：在托管对象上下文和数据存储之间扮演着中间人的角色。协调器从上下文中获得数据请求并将它们转发给合适的数据存储。协调器将数据存储和托管对象模型关联在一起。持久存储协调器是NSPersistentStoreCoordinator类的实例* NSPersistentStoreCoordinator类不是线程安全的，因此，如果计划跨多线程同步访问一个数据存储，则需要为每个线程创建一个协调器或手动锁定和解锁单个协调器 托管对象模型： NSManagedObjectModel。 模型由一组实体组成，它们定义了应用程序中的数据对象。 托管对象上下文: NSManagedObjectContext. 上下文用于保存所有托管数据对象。托管数据对象是NSManagedObject类的实例或子类。托管对象上下文管理所有的托管对象。可以将该上下文想象成保存所有应用程序数据的沙箱。 Core Data 可以将SQLite用作磁盘上的数据存储以持久化我们的数据。还可以使用一个专有的二进制文件作为数据存储。相对于使用SQLite格式时按需加载部分对象图，二进制格式需要将整个对象图加载到内存中。 iCloud提供三种类型的存储方案： 键-值存储、文档存储、Core Data存储。键-值存储用于存储独立的键-值对，可用于存储少量的数据，如用户首选项、游戏分数和应用程序设置。文档存储用于存储基于文档的内容，如电子表格、文本文档和绘图文件。Core Data存储允许跨多个设备同步Core Data 应用程序。 苹果提供了一个数据保护API用于安全地加密应用程序数据。通常当需要保护数据文件时可通过使用NSFileManager对象的setAttributes：ofItemAtPath:error:方法设置文件的一个特性来进行配置。该API允许将文件保护键设置为不同的值，从而提供一些关于被保护的数据何时处于加密或解密状态的选项。 NSFileProtectinNone: 文件没有加密。应用程序可以在任何时候读写此文件 NSFileProtetionComplete: 在设备锁定或启动时文件处于加密状态。 NSFileProtetionCompleteUnlessOpen: 文件在随着设备的解锁而打开前是加密的，一旦文件打开，应用程序可以在任何时候读写该文件，设置是在设备锁定的时候 NSFileProtetionCompleteUntilFirstUserAuthentication: 文件在设备启动时是加密的，并且一直保持锁定直到用户第一次解锁设备。在用户第一次解锁设备后，应用程序可以读写该文件。 当在Core Data中使用SQLite数据存储时，数据存储在设备上的SQLite数据库中。该数据存储的默认文件保护是NSFileProtectionCompleteUntilFirstUserAuthentication。然而，通过修改在App Delegate中创建数据库文件的代码在首次创建数据存储时可以指定数据保护级别。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQLite学习]]></title>
      <url>%2F2017%2F03%2F15%2FSQLite%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[1.CoreData 主要目的是持久化应用程序创建的对象。当预先加载具有大量数据的应用程序时，SQLite的表现更突出，而CoreData擅长管理在设备上创建的数据2.SQLite的大小小于300KB.在使用上，只需要将数据库文件拖放到设备上，然后在iOS项目中包含SQLite库，就完成了准备工作3.如果只需要持久化应用程序使用期间创建的对象，则应该考虑使用Core Data。4.用户界面和数据应该是完全解耦的，并且应该独立的规范化数据。 实体（表） -&gt; 实体的特性(字段)6.使用命令行的优点： 可以使用命令行和脚本接口创建和填充数据库。使用命令行接口导入文件数据到表中，执行和读取包含SQL的文件，以各种格式输出数据库中的数据7.通过在命令行提示符后输入sqlite3 catalog.db，启动命令行工具并创建新的数据库。执行ATTACH DATABASE命令或者附加现有数据库到SQLite工具，或者在制定文件不存在时创建新的数据库。8.可以附加多个数据库到一个命令行工具实例并以数据库名称.表名称的格式使用点符号在每个数据库中引用数据。可以使用这个强大的特性将数据从一个数据库迁移到另一个数据库9.在命令行中输入.help可以显示这些元命令。输入.databases可以看到哪些数据库附加到当前的工具实例。输入.exit或.quit可以退出命令行工具10.在SQLite命令提示符处输入CREATE TABLE语句：1CREATE TABLE &quot;main&quot;.&quot;Product&quot;(&quot;ID&quot; INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, &quot;Name&quot; TEXT, &quot;Manu&quot; INTEGER, &quot;Details&quot; TEXT, &quot;Price&quot; DOUBLE); 创建名为Product的表将ID字段制定为主键并且将其制定为一个AUTOINCREMENT（自动增长）字段。这意味着你不需要提供ID值，数据库引擎将自动产生它们。 11.外键约束允许数据库验证子表中用作外键的值被映射到了存储在父表中的值。12.可以使用下列INSERT语句插入一列到Product表中12INSERT INTO &quot;main&quot;.&quot;Product&quot; (&quot;Name&quot;,&quot;ManufacturerID&quot;,&quot;DETAILS&quot;,&quot;Price&quot;,&quot;QuantityOnHand&quot;,&quot;CountryOfOriginID&quot;,&quot;Image&quot;) VALUES (&apos;WIDGET A&apos;,&apos;1&apos;,&apos;Details of Widget A&apos;,&apos;1.29&apos;,&apos;5&apos;,&apos;1&apos;,&apos;Canvas_1&apos;);sqlite&gt; 13.使用命令行工具可以把文本文件导入到数据库。当从另外一个数据库转存数据时就会被派上用场，另外的那个数据库可以是微软电子表格，或只是一个文本文件。可以为每一个数据库表创建一个文本文件并使用导入功能将数据导入到数据库。14.输入命令.separator “\t”,制定使用制表符\t作为数据文件中字段的分隔符。15.输入.import “products.txt” Product 导入products.txt文件到Product表中16.查询表中的所有内容：1select * from Product; 17.按顺序显示查询：1select name,price from Product order by price; 18.连接表的显示：1select name,country from Product,Country where Product.CountryOfOriginID=Country.CountryID; 19.使用WHERE子句过滤数据：1select name,country from Product,Country where Product.CountryOfOriginID=Country.CountryID and Country.Country=&quot;China&quot;; 20.抽象对数据库的访问是一个好主意，编写一个通用类来执行常用数据库功能。如果想要以后使用不同的数据库引擎，这样做能够提供灵活性。创建一个数据库访问类来和数据库交互。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 使用]]></title>
      <url>%2F2017%2F03%2F14%2FGit-%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[创建版本库版本库又名仓库，英文名repository.你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：12$ mkdir learngit$ cd learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库：1$ git init 现在我们编写一个readme.txt文件，内容如下：12Git is a version control system.Git is free software. 一定要放到learngit目录下（子目录也行)把一个文件放在Git仓库只需要两步:第一步，用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库：12345$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) adedc1b] worte a readme fone1 file changed, 2 insertions(+)create mode 100644 readme.txt git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 时光机穿梭我们已经成功地添加并提交了一个readme.txt文件，现在修改readme.txt文件，改成如下内容：12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果：1$ git status git status命令可以让我们时刻掌握仓库当前的状态虽然Git告诉我们readme.txt被修改了,但是无法看到具体的修改内容,使用git diff来查看1$ git diff 提交修改和提交新文件是一样的两步，第一步是git add：1$ git add readme.txt 在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：1$ git status 提交:1$ git commit -m &quot;add distributed&quot; 版本回退修改readme.txt文件如下：12Git is a distributed version control system.Git is free software distributed under the GPL. 然后提交:12$ git add readme.txt$ git commit -m &quot;append GPL&quot; 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：版本1：wrote a readme file12Git is a version control system.Git is free software. 版本2：add distributed12Git is a distributed version control system.Git is free software. 版本3：append GPL12Git is a distributed version control system.Git is free software distributed under the GPL. 版本控制系统用git log命令查看记录：12345678910111213141516171819$ git logcommit db2a1634505edec7c64ec489729ce25b35d2973bAuthor: Date: Tue Mar 14 21:25:09 2017 +0800append GPLcommit 83a96591227393b5f362df2daed351307b7e87d1Author: Date: Tue Mar 14 21:24:06 2017 +0800add distributedcommit adedc1b15172e80ce54f5997889536b71e89f64dAuthor: Date: Tue Mar 14 20:52:43 2017 +0800worte a readme fone git log命令显示从最近到最远的提交日志如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：12345$ git log --pretty=onelinedb2a1634505edec7c64ec489729ce25b35d2973b append GPL83a96591227393b5f362df2daed351307b7e87d1 add distributedadedc1b15172e80ce54f5997889536b71e89f64d worte a readme fone 准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交的，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：1$ git reset --hard HEAD^ 看看readme.txt的内容是不是版本add distributed：123$ cat readme.txtGit is a distributed version control system.Git is free software OK!这个时候git log一下,123git log --pretty=oneline83a96591227393b5f362df2daed351307b7e87d1 add distributedadedc1b15172e80ce54f5997889536b71e89f64d worte a readme fone 最新的那个版本append GPL已经看不到了，找到那个append GPL的commit id，于是就可以指定回到未来的某个版本：12$ git reset --hard 3628164HEAD is now at db2a1634 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。现在看一下readme.txt的内容123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：改为指向add distributed:然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：1234567$ git reflog83a9659 HEAD@&#123;0&#125;: reset: moving to 83a96591227393bdb2a163 HEAD@&#123;1&#125;: reset: moving to db2a163483a9659 HEAD@&#123;2&#125;: reset: moving to HEAD^db2a163 HEAD@&#123;3&#125;: commit: append GPL83a9659 HEAD@&#123;4&#125;: commit: add distributedadedc1b HEAD@&#123;5&#125;: commit (initial): worte a readme fone 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。工作区和暂存区工作区:就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区：版本库:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库.Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。先用git status查看一下状态：123456789101112131415$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtUntracked files:(use &quot;git add file...&quot; to include in what will be committed)LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：1234567$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)new file: LICENSEmodified: readme.txt 现在，暂存区的状态就变成这样了：所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。12345$ git commit -m &quot;understand how stage works&quot;[master cf3e3ef] understand how stage works2 files changed, 2 insertions(+)create mode 100644 LICENSE 现在版本库变成了这样，暂存区就没有任何内容了： 管理修改为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加：1234567$ git add readme.txt$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)modified: readme.txt 然后，再修改readme.txt：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交：123$ git commit -m &quot;git tracks changes&quot;[master 208dcc4] git tracks changes1 file changed, 1 insertion(+) 提交后，再看看状态：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：123456789101112$ git diff HEAD -- readme.txtdiff --git a/readme.txt b/readme.txtindex db28b2c..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.-Git tracks changes.\ No newline at end of file+Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：1$ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。现在，看看readme.txt的文件内容：12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：123456$ git statusOn branch masterChanges to be committed:(use &quot;git reset HEAD file...&quot; to unstage)modified: readme.txt Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 还记得如何丢弃工作区的修改吗？1234$ git checkout -- readme.txtjingtingchaodeMacBook-Pro:learngit jingtingchao$ git statusOn branch masternothing to commit, working tree clean 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：12345$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master 94cdc44] add test.txt1 file changed, 1 insertion(+)create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：1$ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：123456789$ git statusOn branch masterChanges not staged for commit:(use &quot;git add/rm file...&quot; to update what will be committed)(use &quot;git checkout -- file...&quot; to discard changes in working directory)deleted: test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：123456$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d17efd8] remove test.txt1 file changed, 1 deletion(-)delete mode 100644 test.txt 现在，文件就从版本库中被删除了。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：点“Add Key”，你就应该看到已经添加的Key：为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：1$ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。下一步，就可以把本地库的所有内容推送到远程库上：12345678910$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 8 threads.Compressing objects: 100% (13/13), done.Writing objects: 100% (19/19), 1.54 KiB | 0 bytes/s, done.Total 19 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), done.To https://github.com/TCJing/learngit.git* [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：从现在起，只要本地作了提交，就可以通过命令：1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：12345$ git clone https://github.com/TCJing/gitskills.gitCloning into &apos;gitskills&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done. 分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支.截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支.HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：真是太神奇了，你看得出来有些提交是通过分支完成的吗？下面开始实战。首先，我们创建dev分支，然后切换到dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支：123$ git branch* devmaster git branch命令会列出所有分支，当前分支前面会标一个*号。然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：1Creating a new branch is quick. 然后提交：1234$ git add readme.txt$ git commit -m &quot;branch test&quot;[dev fec145a] branch test1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支：12$ git checkout masterSwitched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：现在，我们把dev分支的工作成果合并到master分支上：12345$ git merge devUpdating 14402cd..ddd16d5Fast-forwardREADME.md | 3 ++-1 file changed, 2 insertions(+), 1 deletion(-) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。合并完成后，就可以放心地删除dev分支了：12$ git branch -d devDeleted branch dev (was ddd16d5). 删除后，查看branch，就只剩下master分支了：12$ git branch* master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。小结Git鼓励大量使用分支：查看分支：git branch 创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout -b name合并某分支到当前分支：git merge name删除分支：git branch -d name 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。准备新的feature1分支，继续我们的新分支开发：12$ git checkout -b feature1Switched to a new branch &apos;feature1&apos; 修改readme.txt最后一行，改为：1Creating a new branch is quick AND simple. 在feature1分支上提交：1234$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;AND simple&quot;[feature1 f9128e8] AND simple1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支：1234$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 1 commit.(use &quot;git push&quot; to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。在master分支上把readme.txt文件的最后一行改为：1Creating a new branch is quick &amp; simple. 提交:12345$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$jingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;&amp; simple&quot;[master 20986f2] &amp; simple1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样：这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：1234567891011121314$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 2 commits.(use &quot;git push&quot; to publish your local commits)You have unmerged paths.(fix conflicts and run &quot;git commit&quot;)(use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:(use &quot;git add file...&quot; to mark resolution)both modified: README.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容：1234567$ cat README.md# gitskills&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：1Creating a new branch is quick and simple. 再提交:123$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;conflict fixed&quot;[master 7e86ad6] conflict fixed 现在，master分支和feature1分支变成了下图所示：用带参数的git log也可以看到分支的合并情况：12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 最后，删除feature1分支：12$ git branch -d feature1Deleted branch feature1 (was f9128e8). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。下面我们实战一下–no-ff方式的git merge：首先，仍然创建并切换dev分支：12$ git checkout -b devSwitched to a new branch &apos;dev&apos; 修改readme.txt文件，并提交一个新的commit：1234$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;add merge&quot;[dev 0a5e364] add merge1 file changed, 1 insertion(+), 1 deletion(-) 现在，我们切换回master：12$ git checkout masterSwitched to branch &apos;master&apos; 准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy.readme.txt | 1 +1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史：1234567$ git log --graph --pretty=oneline --abbrev-commit* 7825a50 merge with no-ff|\| * 6224937 add merge|/* 59bc1cb conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：小结Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：12345678910111213$ git status# On branch dev# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add file...&quot; to update what will be committed)# (use &quot;git checkout -- file...&quot; to discard changes in working directory)## modified: readme.txt# 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos; 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：1234$ git add readme.txt$ git commit -m &quot;fix bug 101&quot;[issue-101 cc17032] fix bug 1011 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：123456789$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy.readme.txt | 2 +-1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！12345$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：1234567891011121314$ git stash pop# On branch dev# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add file...&quot; to update what will be committed)# (use &quot;git checkout -- file...&quot; to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了：1$ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。于是准备开发：12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 5分钟后，开发完毕：123456789101112$ git add vulcan.py$ git status# On branch feature-vulcan# Changes to be committed:# (use &quot;git reset HEAD file...&quot; to unstage)## new file: vulcan.py#$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 756d4af] add feature vulcan1 file changed, 2 insertions(+)create mode 100644 vulcan.py 切回dev，准备合并：1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁：123$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。现在我们强行删除：12$ git branch -D feature-vulcanDeleted branch feature-vulcan (was 756d4af). 终于删除成功！小结开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D name强行删除。 误删分支恢复方法首先用以下步骤创建一个新分支，修改一些文件后删除，以便进行恢复。1.创建分支 abc1$ git branch myDev 2.切换到abc分支，随便修改一下东西后 commit123456789101112$ git checkout myDevSwitched to branch &apos;myDev&apos;$ git add README.mdjingtingchaodeMacBook-Pro:gitskills jingtingchao$ git commit -m &quot;修改README.md&quot;[myDev 38e7342] 修改README.md1 file changed, 1 insertion(+)$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 30 commits.(use &quot;git push&quot; to publish your local commits) 3.删除分支abc12$ git branch -D myDevDeleted branch myDev (was 38e7342). 4.查看分支列表，abc分支已不存在123$ git branchdev* master 5.使用git log -g 找回之前提交的commit123456789$ git log -g//这里就是commit_idcommit 38e7342e7ec64624e1c2ea69c228ace103ddea10Reflog: HEAD@&#123;1&#125; (xx@163.com)Reflog message: commit: 修改README.mdAuthor: jtc xx@163.comDate: Wed Mar 15 19:47:41 2017 +0800修改README.md 6.使用git branch [新分支] commit_id命令用这个commit创建一个分支12345678$ git branch myDev 38e7342e7ec646//查看分支$ git branchdev* mastermyDev$ git checkout myDevSwitched to branch &apos;recover_branch_myDev&apos; over! 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote：12$ git remoteorigin 或者，用git remote -v显示更详细的信息：123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：1$ git push origin master 如果要推送其他分支，比如dev，就改成：1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：1234567891011$ git commit -m &quot;add /usr/bin/env&quot;[dev 291bea8] add /usr/bin/env1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.gitfc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：123456789101112$ git add hello.py$ git commit -m &quot;add coding: utf-8&quot;[dev bd6ae48] add coding: utf-81 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)hint: before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngitfc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for detailsgit pull remote branchIf you wish to set tracking information for this branch you can do so with:git branch --set-upstream dev origin/branch git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：12$ git branch --set-upstream-to=origin/dev devBranch dev set up to track remote branch dev from origin. 再pull：1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：12345678910$ git commit -m &quot;merge &amp; fix hello.py&quot;[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样：1.首先，可以试图用git push origin branch-name推送自己的修改；2.如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3.如果合并有冲突，则解决冲突，并在本地提交；4.没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to=origin/branch-name branch-name这就是多人协作的工作模式，一旦熟悉了，就非常简单。小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream-to=origin/branch-name branch-name 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？“请把上周一的那个版本打包发布，commit号是6a5819e…”“一串乱七八糟的数字不好找！”如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”“好的，按照tag v1.2查找commit就行！”所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上：12345$ git branch* devmaster$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag name就可以打一个新标签：1$ git tag v1.0 可以用命令git tag查看所有标签：12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？方法是找到历史提交的commit id，然后打上就可以了：1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：1$ git tag v0.9 6224937 再用命令git tag查看标签：123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show tagname查看标签信息：1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author:Date: Thu Aug 22 11:22:08 2013 +0800add merge... 可以看到，v0.9确实打在add merge这次提交上。还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用命令git show tagname可以看到说明文字：123456789101112$ git show v0.1tag v0.1Tagger:Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author:Date: Tue Aug 20 15:11:49 2013 +0800append GPL 操作标签如果标签打错了，也可以删除：12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin tagname：1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git* [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签：1234567$ git push origin --tagsCounting objects: 1, done.Writing objects: 100% (1/1), 554 bytes, done.Total 1 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git* [new tag] v0.2 -&gt; v0.2* [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下：123$ git push origin :refs/tags/v0.9To git@github.com:michaelliao/learngit.git- [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin tagname可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d tagname可以删除一个本地标签； 命令git push origin :refs/tags/tagname可以删除一个远程标签。 原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView+FDTemplateLayoutCell理解笔记]]></title>
      <url>%2F2017%2F03%2F14%2FUITableView-FDTemplateLayoutCell%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UITableView+FDTemplateLayoutCell Demo部分： storyboard部分：①：这里是通过storyboard来添加tableHeadView。 添加的方式就是直接通过在cell的上面直接拖入一个UIView，这个UIView就可以作为tableHeadView。然后可以在这个tableHeadView中添加一个控件和约束。②： 这里是自定义了一个动态cell。 在添加约束的时候，需要注意的是：这里的图片是无法确定高度的，这里约束了图片的宽度&lt;=某个值，保证图片不会超过屏幕，图片的高度根据图片的宽度来确定。所以，在做约束的时候，不能将Username Label的垂直位置相对于图片来设置，username Label的底部相对于contentView来设置，UIImageView的底部相对于username Label来设置。③： 在storyboard当中添加了一个refresh control，通过storyboard来添加refresh control的方式为： 监听refresh control的事件的方式是通过对value change的监听;通过拖线的方式添加事件处理： 我们只需要在请求到数据后调用refresh control的endRefreshing方法并且刷新表格 代码部分：1.枚举的使用：12345typedef NS_ENUM(NSInteger, FDSimulatedCacheMode) &#123;FDSimulatedCacheModeNone = 0,FDSimulatedCacheModeCacheByIndexPath,FDSimulatedCacheModeCacheByKey&#125;; 这里将UISegment Control的index与枚举建立关联：直接将index值赋值给枚举变量。这样的好处是： 1.免去了if else的判断。2.相比较if(0) else if(1)这样的代码if(FDSimulatedCacheModeNone) else if (FDSimulatedCacheModeCacheByIndexPath)..具有更高的可读性 2.开启打印：1self.tableView.fd_debugLogEnabled = YES; 3.block的使用：1234567891011121314151617181920212223242526272829303132333435363738//这里的代码内容主要包括了1.将json转为模型数组，将模型数组作为元素添加到可变数组当中- (void)viewDidLoad &#123;[super viewDidLoad];//这里采用block回调的方式的好处是： 对代码进行了封装，因为这里两个数组之间本身就存在依赖关系，feedEntitySections依赖于prototypeEntitiesFromJSON，所以通过block的方式，避免被调换顺序，而导致错误。block回调就完成了封装。通过当模型数组创建完毕的时候回调的方式来创建feedEntitySections数组[self buildTestDataThen:^&#123;self.feedEntitySections = @[].mutableCopy;[self.feedEntitySections addObject:self.prototypeEntitiesFromJSON.mutableCopy];[self.tableView reloadData];&#125;];&#125;//这里加载文件数据以及json转模型，放在了子线程来执行，避免对主线程可能造成的卡顿和不流畅//相对于使用for in使用enumerateObjectsUsingBlock，效率更高//最后需要回到主线程调用block，而非在子线程直接调用- (void)buildTestDataThen:(void (^)(void))then &#123;// Simulate an async requestdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// Data from `data.json`NSString *dataFilePath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;json&quot;];NSData *data = [NSData dataWithContentsOfFile:dataFilePath];NSDictionary *rootDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil];NSArray *feedDicts = rootDict[@&quot;feed&quot;];// Convert to `FDFeedEntity`NSMutableArray *entities = @[].mutableCopy;[feedDicts enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;[entities addObject:[[FDFeedEntity alloc] initWithDictionary:obj]];&#125;];self.prototypeEntitiesFromJSON = entities;// Callbackdispatch_async(dispatch_get_main_queue(), ^&#123;!then ?: then();&#125;);&#125;);&#125; IMP12345678910111213//根据buttonIndex来调用不同的方法。通过对IMP的使用，免去了if else的使用。- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex &#123;SEL selectors[] = &#123;@selector(insertRow),@selector(insertSection),@selector(deleteSection)&#125;;if (buttonIndex &lt; sizeof(selectors) / sizeof(SEL)) &#123;void(*imp)(id, SEL) = (typeof(imp))[self methodForSelector:selectors[buttonIndex]];imp(self, selectors[buttonIndex]);&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runloop]]></title>
      <url>%2F2017%2F03%2F13%2Frunloop%2F</url>
      <content type="text"><![CDATA[利用RunLoop空闲时间执行任务 空闲RunLoopMode: 当用户正在滑动 UIScrollView 时，RunLoop 将切换到 UITrackingRunLoopMode,接受滑动手势和处理滑动事件（包括减速和弹簧效果）,此时，其他 Mode （除 NSRunLoopCommonModes 这个组合 Mode）下的事件将全部暂停执行，来保证滑动事件的优先处理，这也是 iOS 滑动顺畅的重要原因。 当 UI 没在滑动时，默认的 Mode 是 NSDefaultRunLoopMode（同 CF 中的 kCFRunLoopDefaultMode），同时也是 CF 中定义的 “空闲状态 Mode”。当用户啥也不点，此时也没有什么网络 IO 时，就是在这个 Mode 下。 用RunLoopObserver找准时机: 注册 RunLoopObserver 可以观测当前 RunLoop 的运行状态，并在状态机切换时收到通知：1.RunLoop开始2.RunLoop即将处理Timer3.RunLoop即将处理Source4.RunLoop即将进入休眠状态5.RunLoop即将从休眠状态被事件唤醒6.RunLoop退出 空闲时间执行任何应当满足：RunLoop 处于“空闲”状态 Mode当这一次 RunLoop 迭代处理完成了所有事件，马上要休眠时1234567CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;// TODO here&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode); 在其中的 TODO 位置，就可以开始任务的收集和分发了，当然，不能忘记适时的移除这个 observer 分解成多个RunLoop Source任务： 假设列表有 20 个 cell，加载后展示了前 5 个，那么开启估算后 table view 只计算了这 5 个的高度，此时剩下 15 个就是“预缓存”的任务，而我们并不希望这 15 个计算任务在同一个 RunLoop 迭代中同步执行，这样会卡顿 UI，所以应该把它们分别分解到 15 个 RunLoop 迭代中执行，这时就需要手动向 RunLoop 中添加 Source 任务（由应用发起和处理的是 Source 0 任务） Foundation 层没对 RunLoopSource 提供直接构建的 API，但是提供了一个间接的、既熟悉又陌生的 API： 12345- (void)performSelector:(SEL)aSelectoronThread:(NSThread *)thrwithObject:(id)argwaitUntilDone:(BOOL)waitmodes:(NSArray *)array; 这个方法将创建一个 Source 0 任务，分发到指定线程的 RunLoop 中，在给定的 Mode 下执行，若指定的 RunLoop 处于休眠状态，则唤醒它处理事件 1234567891011121314151617181920static int i = 100000;- (void)viewDidLoad &#123;//获得当前的runloopCFRunLoopRef runLoop = CFRunLoopGetCurrent();CFStringRef runLoopMode = kCFRunLoopDefaultMode;//创建一个observer监听这个状态kCFRunLoopBeforeWaitingCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity _) &#123;if (i == 0) &#123;CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);CFRelease(observer);return ;&#125;i = i - 1;[self performSelector:@selector(downLoad) onThread:[NSThread mainThread] withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];&#125;);CFRunLoopAddObserver(runLoop, observer, runLoopMode);&#125;-(void)downLoad&#123;NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS小技巧积累]]></title>
      <url>%2F2017%2F03%2F12%2FiOS%E5%B0%8F%E6%8A%80%E5%B7%A7%E7%A7%AF%E7%B4%AF%2F</url>
      <content type="text"><![CDATA[1.禁止第三方键盘在要填密码的地方， 为了安全考虑！要么禁用第三方键盘，要么自定义键盘！1234//禁止第三方键盘的使用- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(NSString *)extensionPointIdentifier&#123;return NO;&#125; 2.禁止系统的面板手机默认的输入框右键或者选中文字右键会弹出菜单，但是有时候我们在做对文本严格要求的时候 (比如说不能使文字啊)，就要关闭这个功能， 只需要在自定义的UITextfield或UITextview里面添加下面这一句话：123-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123;return NO;&#125; 3.点击部分文字响应有时候你需要在一行文本中点击某几个特殊的文字，来实现跳转网页或者打电话的功能。比如点击电话号码，拨打电话：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &quot;TCTextView.h&quot;@implementation TCTextView- (instancetype)initWithCoder:(NSCoder *)coder&#123;self = [super initWithCoder:coder];if (self) &#123;&#125;return self;&#125;- (void)setText:(NSString *)text&#123;[super setText:text];//目标文字是你已知的文字，或者取服务器字段知道的NSRange range = [self.text rangeOfString:@&quot;110&quot;];//text -&gt; attributedStringNSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc]initWithString:text];NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc]init];//[paragraphStyle setLineSpacing:10];// 行间距[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, text.length)];//改变电话号码的背景色[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:range];// 下划线[attributedString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:range];[attributedString addAttribute:NSFontAttributeName value:[UIFont fontWithName:@&quot;HelveticaNeue-Light&quot; size:16] range:NSMakeRange(0, text.length)];self.attributedText = attributedString;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;NSSet *allTouches = [event allTouches]; //返回与当前接收者有关的所有的触摸对象UITouch *touch = [allTouches anyObject]; //视图中的所有对象CGPoint point = [touch locationInView:[touch view]];NSRange range = [self.text rangeOfString:@&quot;110&quot;];// self.selectedRange = range;// 不能设置是因为 selectedable[self setSelectedRange:range];//The current selection range of the receiver.NSArray * arr = [self selectionRectsForRange:self.selectedTextRange];//取消选中状态self.selectedRange = NSMakeRange(0, 0);for(UITextSelectionRect * textrect in arr)&#123;if(CGRectContainsPoint(textrect.rect, point))&#123;// 这里就是响应的地方NSLog(@&quot;是我&quot;);&#125;&#125;&#125;@end 4、获取网络图片的尺寸 1234567891011121314151617181920212223242526NSArray * urlArr = @[@&quot;http://upload-images.jianshu.io/upload_images/31282-390513513494ede8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/1931381-12109e9d6666bb0e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/3375207-6adc6a22441681ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/3375207-6adc6a22441681ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;,@&quot;http://upload-images.jianshu.io/upload_images/1336788-2ac84707ce22e970.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot;];dispatch_group_t grounp = dispatch_group_create();for(NSString * str in urlArr)&#123;// 将当前的下载操作添加到组中dispatch_group_enter(grounp);// 缓存图片[[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:str] options:SDWebImageDownloaderUseNSURLCache progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;&#125; completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;// 把缓存到本地的img添加到数据， 也可以通过image.size取到宽高比例[_arr addObject:image];//完成单张图片下载离开当前组dispatch_group_leave(grounp);&#125;];&#125;dispatch_group_notify(grounp, dispatch_get_main_queue(), ^&#123;// 来到这里所有图片都下载完成// 更新UI, 就好了&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读JZTableViewRowAction理解笔记]]></title>
      <url>%2F2017%2F03%2F12%2F%E8%AF%BBJZTableViewRowAction%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[要点： 1.需要获得系统提供的cell侧滑功能，我们需要实现:1- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath 或者实现：1- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath 当两者都没有实现的时候，就不能获得系统提供的侧滑功能 效果图： 侧滑删除是iOS非常容易实现的一个效果，只需要为你的UITableViewDataSource重新这个方法，系统就会自动添加这种操作： 123//只要实现了这个方法，就能够获得系统提供的侧滑删除功能，当点击删除按钮的时候，就会回调这个方法，可以在这个方法当中完成删除cell以及在模型当中删除对应行的数据完成刷新tableView//- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath 从iOS8开始，苹果开放了这样一个API：1- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath 方法分析： 这个方法的返回值类型为：nullable NSArray *，也就是一个模型数组，只要我们实现了这个方法，并且提供了这个模型数组，系统就会自动的根据数组中模型的个数以及内容完成对应个数的侧滑按钮的创建，不需要我们来创建按钮，只要我们提供了模型就OK。通过这个方法，就能够提供更多的按钮与用户交互。效果图： 所以，对于iOS8以上的系统来说，获得这样的拥有单个或多个的侧滑按钮的侧滑功能是非常容易的。这篇文章的主要内容就是对iOS8以下的系统提供这样的一个侧滑功能。 在数据源当中1234567891011121314151617181920212223242526272829303132//需要主要的是，当我们需要多按钮侧滑功能时，并且需要适配到iOS7或更低版本，那么就一定要实现这个方法。//因为： 在iOS8及以上版本，当我们实现了tableView:editActionsForRowAtIndexPath:，(tableView:commitEditingStyle:forRowAtIndexPath:)实现了也不会调用，所以不实现也没有什么影响。但是，iOS7没有tableView:editActionsForRowAtIndexPath:,如果不实现(tableView:commitEditingStyle:forRowAtIndexPath:),那么就不会有侧滑的功能。所以实现了这个方法保证了iOS7版本下开启侧滑功能- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123;// [self setEditing:NO animated:true];&#125;//这个方法返回的类型是NSString类型，返回的是删除按钮的显示文字，在只有一个删除按钮的时候，可以实现这个方法来自定义删除按钮的内容显示。这里实现的多按钮的侧滑，所以，不需要实现这个功能//-(NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath&#123;//return @&quot;abc&quot;;//&#125;//这个方法的返回值是模型，提供这个模型数组，就能够根据模型内容完成按钮的创建。这个方法出现在iOS8。在这里，我们让更低版本也调用这个方法，实现了版本的适配的同时，也简化了版本的适配，这样在使用的时候，就像是它本身就不存在适配问题一样。其实这里我们将适配问题在其他文件当中进行了实现//需要注意的是这个方法是iOS8才有的方法，而且UITableViewRowAction这个类也是iOS8才有的。现在，我们在像iOS7这样的更低的系统上使用这个UITableViewRowAction，那么，它就一定是我们运用runtime来动态添加的一个类。当我们使用objc_getClass(&quot;UITableViewRowAction&quot;)能够获得这个类的时候，就表示它有，那就不需要做任何事情，如果没有获取到这个类，就需要来动态创建这个类。。。。。- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath &#123;void(^rowActionHandler)(UITableViewRowAction *, NSIndexPath *) = ^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123;NSLog(@&quot;%@&quot;, action);[self setEditing:false animated:true];&#125;;//创建Disclosure类型的button//通过这个按钮能够获得按钮当中的图片UIButton *buttonForImage = [UIButton buttonWithType:UIButtonTypeDetailDisclosure];//这里调用的方法是UITableViewRowAction分类当中提供的方法，增加了一个传入图片的功能UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault image:[buttonForImage imageForState:UIControlStateNormal] handler:rowActionHandler];UITableViewRowAction *action2 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;disenable&quot; handler:rowActionHandler];//并且把第二个按钮的enabled设置为falseaction2.enabled = false;UITableViewRowAction *action3 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;emjoy👍&quot; handler:rowActionHandler];return @[action1,action2,action3];&#125; 现在来看看UITableViewRowAction分类：123456789101112131415161718192021222324252627282930313233//这个类是一个模型类，就是来提供数据的，所以无论是提供的方法还是属性，都只是为了数据的录入和输出。#import &quot;UITableViewRowAction+JZExtension.h&quot;#import &lt;objc/runtime.h&gt;@implementation UITableViewRowAction (JZExtension)//这里新添加了一个创建方法 这个方法帮助我们在原来的只能够在按钮上显示文字的基础上，还能够显示图片 + (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(UIImage *)image handler:(void (^)(UITableViewRowAction * _Nullable, NSIndexPath * _Nullable))handler &#123;//首先调用这个基本构造方法UITableViewRowAction *rowAction = [self rowActionWithStyle:style title:@&quot;holder&quot; handler:handler];//因为这个一个模型对象，所以这里只需要将这个图片存储起来，因为在分类当中无法提供属性，所以采用运行时关联对象的方式保留图片rowAction.image = image;return rowAction;&#125;- (void)setImage:(UIImage *)image &#123;objc_setAssociatedObject(self, @selector(image), image, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (void)setEnabled:(BOOL)enabled &#123;objc_setAssociatedObject(self, @selector(enabled), @(enabled), OBJC_ASSOCIATION_ASSIGN);&#125;- (UIImage *)image &#123;return objc_getAssociatedObject(self, _cmd);&#125;- (BOOL)enabled &#123;id enabled = objc_getAssociatedObject(self, _cmd);//如果没有设置enabled的值，就提供一个默认值：truereturn enabled ? [enabled boolValue] : true;&#125;@end 现在来看看UITableViewRowAction.m 文件：这个文件就是给iOS8以下的系统来使用的。因为iOS8以下的系统没有这样的一个类，于是我们动态来创建这个类。如何更容易的来创建一个跟系统提供的UITableViewRowAction差不多的类呢？注册一个名字相同的类，让这个类继承我们的JZTableViewRowAction，JZTableViewRowAction类当中的属性方法都是直接copy于系统的UITableViewRowAction类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UITableView.h&gt;#import &lt;objc/runtime.h&gt;@interface JZTableViewRowAction : NSObject&lt;NSCopying&gt;&#123;UITableViewRowActionStyle _style;&#125;@property (nonatomic, readonly) UITableViewRowActionStyle style;@property (nonatomic, copy, nullable) NSString *title;@property (nonatomic, copy, nullable) UIColor *backgroundColor; // default background color is dependent on style@property (nonatomic, copy, nullable) UIVisualEffect* backgroundEffect;@property (nonatomic, copy, nullable) void (^handler)(UITableViewRowAction *, NSIndexPath *);@property (nonatomic, strong, nullable) UIImage *image;@property (nonatomic, strong, nonnull) NSIndexPath *indexPath;@property (nonatomic, assign) BOOL enabled;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(nullable NSString *)title handler:(void (^)(UITableViewRowAction *action, NSIndexPath *indexPath))handler;+ (nonnull instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(nullable UIImage *)image handler:(nullable void (^)(UITableViewRowAction * _Nullable action, NSIndexPath * _Nullable indexPath))handler;@end@implementation JZTableViewRowAction+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style title:(NSString *)title handler:(void (^)(UITableViewRowAction *, NSIndexPath *))handler &#123;JZTableViewRowAction *rowAction = [[JZTableViewRowAction alloc] init];rowAction.title = title;rowAction.handler = handler;rowAction-&gt;_style = style;rowAction.enabled = true;return rowAction;&#125;+ (instancetype)rowActionWithStyle:(UITableViewRowActionStyle)style image:(UIImage *)image handler:(void (^)(UITableViewRowAction * _Nullable, NSIndexPath * _Nullable))handler &#123;JZTableViewRowAction *rowAction = [self rowActionWithStyle:style title:@&quot;holder&quot; handler:handler];rowAction.image = image;return rowAction;&#125;- (id)copyWithZone:(NSZone *)zone &#123;return [self copy];&#125;//事件触发的时候- (void)actionTriggered:(id)sender &#123;!self.handler ?: self.handler((__kindof UITableViewRowAction *)self, self.indexPath);&#125;@end/*** 动态创建一个类UITableViewRowAction*/__asm(&quot;.section __DATA,__objc_classrefs,regular,no_dead_strip\n&quot;#if TARGET_RT_64_BIT&quot;.align 3\n&quot;&quot;L_OBJC_CLASS_UITableViewRowAction:\n&quot;&quot;.quad _OBJC_CLASS_$_UITableViewRowAction\n&quot;#else&quot;.align 2\n&quot;&quot;_OBJC_CLASS_UITableViewRowAction:\n&quot;&quot;.long _OBJC_CLASS_$_UITableViewRowAction\n&quot;#endif&quot;.weak_reference _OBJC_CLASS_$_UITableViewRowAction\n&quot;);__attribute__((constructor)) static void JZTableViewRowActionPatchEntry(void) &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;@autoreleasepool &#123;if (objc_getClass(&quot;UITableViewRowAction&quot;)) &#123;return;&#125;Class *tableViewRowActionClassLocation = NULL;#if TARGET_CPU_ARM__asm(&quot;movw %0, :lower16:(_OBJC_CLASS_UITableViewRowAction-(LPC0+4))\n&quot;&quot;movt %0, :upper16:(_OBJC_CLASS_UITableViewRowAction-(LPC0+4))\n&quot;&quot;LPC0: add %0, pc&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_ARM64__asm(&quot;adrp %0, L_OBJC_CLASS_UITableViewRowAction@PAGE\n&quot;&quot;add %0, %0, L_OBJC_CLASS_UITableViewRowAction@PAGEOFF&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_X86_64__asm(&quot;leaq L_OBJC_CLASS_UITableViewRowAction(%%rip), %0&quot; : &quot;=r&quot;(tableViewRowActionClassLocation));#elif TARGET_CPU_X86void *pc = NULL;__asm(&quot;calll L0\n&quot;&quot;L0: popl %0\n&quot;&quot;leal _OBJC_CLASS_UITableViewRowAction-L0(%0), %1&quot; : &quot;=r&quot;(pc), &quot;=r&quot;(tableViewRowActionClassLocation));#else#error Unsupported CPU#endifif (tableViewRowActionClassLocation &amp;&amp; !*tableViewRowActionClassLocation) &#123;Class class = objc_allocateClassPair(JZTableViewRowAction.class, &quot;UITableViewRowAction&quot;, 0);if (class) &#123;objc_registerClassPair(class);*tableViewRowActionClassLocation = class;&#125;&#125;&#125;&#125;);&#125; 在来看看UITableViewCell+JZExtension.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#import &lt;UIKit/UIKit.h&gt;#import &lt;objc/runtime.h&gt;#import &quot;UITableViewRowAction+JZExtension.h&quot;@implementation UITableViewCell (JZExtension)+ (void)load &#123;[super load];static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;//交换了willTransitionToState：和 __willTransitionToState的方法实现//willTransitionToState:当用户在某一行刚开始进行侧滑并且侧滑的Button还没有展现出来时调用//与之对应的还有一个方法：- (void)didTransitionToState:(UITableViewCellStateMask)state。 这个方法调用的时候，按钮就已经展示给用户了。而调用willTransitionToState的时候，因为cell的侧滑view是懒加载，还没有创建出来。Method willTransitionToState = class_getInstanceMethod(self, @selector(willTransitionToState:));Method __willTransitionToState = class_getInstanceMethod(self, @selector(__willTransitionToState:));method_exchangeImplementations(willTransitionToState, __willTransitionToState);Method titleForDeleteConfirmationButton = class_getInstanceMethod([UITableView class], NSSelectorFromString(@&quot;_titleForDeleteConfirmationButtonForRowAtIndexPath:&quot;));Method _titleForDeleteConfirmationButton = class_getInstanceMethod([UITableView class], NSSelectorFromString(@&quot;titleForDeleteConfirmationButtonForRowAtIndexPath:&quot;));method_exchangeImplementations(titleForDeleteConfirmationButton, _titleForDeleteConfirmationButton);&#125;);&#125;/*** 开始进行侧滑，并且button还没有出现的时候* 这个方法调用的时候，按钮还没有创建** @param state &lt;#state description#&gt;*///在发生侧滑的时候，这个方法先调用，然后再调用获取模型的方法//当用户在某一行刚开始进行侧滑并且侧滑的Button还没有展现出来时，state的值就为 UITableViewCellStateShowingDeleteConfirmationMask//这个方法无论是实现了tableView:editActionsForRowAtIndexPath:方法，还是实现了tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath，都会被调用，只有在两个方法都没有实现的情况下，才不会被调用- (void)__willTransitionToState:(UITableViewCellStateMask)state &#123;//首先让系统完成自己的事情[self __willTransitionToState:state];if (state == UITableViewCellStateShowingDeleteConfirmationMask) &#123;//在cell当中，通过kvc的方法来获得tableViewUITableView *tableView = [self valueForKey:@&quot;_tableView&quot;];// //为什么要做判断？： 因为单独的删除按钮是也会进入到这个方法的，而对于单独的删除按钮我们不需要再做额外的操作，要排除这种情况。if (![tableView.delegate respondsToSelector:@selector(tableView:editActionsForRowAtIndexPath:)]) &#123;return;&#125;//以下代码针对iOS7的// dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.001 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;//通过kvc获取到创建的_swipeToDeleteConfirmationView，这个是按钮的容器view//通过断点调试，可以发现，这个方法属于懒加载，在调用willTransitionToState： 的方法的时候还没有创建。这里采用了延迟执行代码块的方式，来获取这个containerViewUIView *swipeToDeleteConfirmationView = [self valueForKey:@&quot;_swipeToDeleteConfirmationView&quot;];//当系统版本大于等于8.0的时候if ([[[UIDevice currentDevice] systemVersion] compare:@&quot;8.0&quot; options:NSNumericSearch] != NSOrderedAscending) &#123;//获取容器view当中所有的subViewsfor (UIButton *deleteButton in swipeToDeleteConfirmationView.subviews) &#123;//用kvc，获取到按钮当中UITableViewRowAction模型UITableViewRowAction *rowAction = [deleteButton valueForKey:@&quot;_action&quot;];if (rowAction.backgroundColor) &#123;deleteButton.backgroundColor = rowAction.backgroundColor;&#125;//deleteButton.enabled = rowAction.enabled;//if (rowAction.image) &#123;NSTextAttachment *imageAtt = [[NSTextAttachment alloc] init];imageAtt.image = rowAction.image;//设置富文本title[deleteButton setAttributedTitle:[NSAttributedString attributedStringWithAttachment:imageAtt] forState:UIControlStateNormal];&#125;&#125;return;&#125;//systemVersion &lt; 8.0//在cell当中获得tableView 调用indexPathForCell来获取到NSIndexPathNSIndexPath *indexPath = [tableView indexPathForCell:self];//手动来调用这个方法NSArray *rowActions = [tableView.delegate tableView:tableView editActionsForRowAtIndexPath:indexPath];//利用关联对象进行存储self.rowActions = rowActions;//获取到第一个子控件UIButton *deleteConfirmButton = swipeToDeleteConfirmationView.subviews.firstObject;//背景颜色等于文字颜色deleteConfirmButton.titleLabel.textColor = deleteConfirmButton.backgroundColor;//CGFloat buttonWidth = deleteConfirmButton.bounds.size.width / rowActions.count;//CGFloat buttonHeight = deleteConfirmButton.bounds.size.height;for (NSInteger index = 0; index &lt; rowActions.count; index++) &#123;UITableViewRowAction *rowAction = rowActions[index];[rowAction setValue:indexPath forKey:@&quot;indexPath&quot;];//创建按钮UIButton *rowActionButton = [UIButton buttonWithType:UIButtonTypeCustom];//if (rowAction.backgroundColor) &#123;rowActionButton.backgroundColor = rowAction.backgroundColor;&#125; else &#123;//style==UITableViewRowActionStyleDestructive?//YES: 按钮的背景颜色等于deleteConfirmButton按钮的背景颜色//NO:rowActionButton.backgroundColor = rowAction.style == UITableViewRowActionStyleDestructive ? deleteConfirmButton.backgroundColor : [UIColor colorWithRed:187.0/255.0 green:187.0/255.0 blue:193.0/255.0 alpha:1.0];&#125;//if (rowAction.enabled) &#123;//调用模型，当中的方法[rowActionButton addTarget:rowAction action:NSSelectorFromString(@&quot;actionTriggered:&quot;) forControlEvents:UIControlEventTouchUpInside];&#125;rowActionButton.frame = CGRectMake((rowActions.count - 1 - index) * buttonWidth, 0, buttonWidth, buttonHeight);//rowAction.image ? [rowActionButton setImage:rowAction.image forState:UIControlStateNormal]: [rowActionButton setTitle:rowAction.title forState:UIControlStateNormal];//将子控件添加到deleteConfirmButton上[deleteConfirmButton addSubview:rowActionButton];&#125;// &#125;);&#125;&#125;#pragma mark -set and get/*** 方法当中的key用的SEL作为key，因为key需要是唯一的，所以呢，因为setRowActions使用的是_cmd ,那么setRowActions就不能使用cmd了，否则就不唯一了，就需要通过@selector()来获取setRowActions的_cmd* 分类当中内部使用的属性（关联对象）* UITableViewRowAction 在iOS8的时候才有的* @param rowActions &lt;#rowActions description#&gt; &amp;key*/- (void)setRowActions:(NSArray *)rowActions &#123;objc_setAssociatedObject(self, @selector(rowActions), rowActions, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (NSArray *)rowActions &#123;return objc_getAssociatedObject(self, _cmd);&#125;@end@implementation UITableView (JZExtension)//这个方法只会在iOS以上，并且没有实现tableView:editActionsForRowAtIndexPath:的时候才会调用//而对于iOS7及其以下会被调用/*** 这个方法的目的是设么？获取显示的字符串，通过字符串来计算按钮的宽度，所以，只要返回一个恰当的字符串，就能够由系统提供给我们一个恰当宽度的按钮。然后在这个按钮上添加子控件** @param indexPath &lt;#indexPath description#&gt;** @return &lt;#return value description#&gt;*/- (id)titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath &#123;// 如果代理没有实现tableView:editActionsForRowAtIndexPath:这个方法，就表示没有多按钮侧滑功能，那就只需要执行系统原有的方法实现，然后直接返回if (![self.delegate respondsToSelector:@selector(tableView:editActionsForRowAtIndexPath:)]) &#123;return [self titleForDeleteConfirmationButtonForRowAtIndexPath:indexPath];&#125;//所以这里这个方法是针对iOS7以下的并且实现了tableView:editActionsForRowAtIndexPath:// System version above iOS7 will not go on.//获取到rowActionsNSArray *rowActions = [self.delegate tableView:self editActionsForRowAtIndexPath:indexPath];NSMutableString *placeholder = [NSMutableString string];//NSString *longestString = @&quot; &quot;; //A placeholder string for the default width.&#123;CGFloat fontSize = 12;for (UITableViewRowAction *action in rowActions) &#123;//CGFloat actionTitleWidth = [action.title sizeWithFont:[UIFont systemFontOfSize:fontSize]].width;//CGFloat currentLongestStringWidth = [longestString sizeWithFont:[UIFont systemFontOfSize:fontSize]].width;//如果action中的标题宽度大于@“ ”//默认值 @“ ”； 宽度&gt;= @&quot; &quot;if (actionTitleWidth &gt; currentLongestStringWidth) &#123;longestString = action.title;&#125;&#125;&#125;for (int index = 0; index &lt; rowActions.count; index++) &#123;[placeholder appendString:longestString];&#125;return placeholder;&#125;@end https://github.com/JazysYu/JZTableViewRowAction原文地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IMP指针]]></title>
      <url>%2F2017%2F03%2F11%2FIMP%E6%8C%87%E9%92%88%2F</url>
      <content type="text"><![CDATA[Method Swizzling 利用运行时，在程序运行期间，可以动态的给两个方法互换实现，可以利用这个函数实现：1void method_exchangeImplementations(Method m1, Method m2) 使用场景： 当我们理解一个新的项目的时候，通常通过在类创建的时候，把自己的名字打印出来，从而了解程序的调用顺序。那么，就需要我们在每个类的viewDidLoad方法当中，添加一个log方法？显然这样做是非常麻烦的。也许会想到，让所有的类都继承一个基础类，在基础类当中添加log方法，这样就OK啦。如此做法就需要我们更改很多类的继承关系，所以也不是完美的解决办法。 这个时候，交换方法实现的方法就闪亮登场了。只需要给UIViewController添加一个分类，添加几行代码。1234567891011121314#import &quot;UIViewController+Log.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (Log)+(void)load&#123;Method m1 = class_getInstanceMethod([self class], @selector(viewDidLoad));Method m2 = class_getInstanceMethod([self class], @selector(viewDidLoaded));//交换viewDidLoad和viewDidLoaded方法的实现，这样当调用viewDidLoad方法的时候，就相当于被拦截了一样，调用到viewDidLoaded方法，在viewDidLoaded实现中，对自己的调用，被转移到对viewDidLoad方法的调用，然后再添加Log方法method_exchangeImplementations(m1, m2);&#125;-(void)viewDidLoaded&#123;[self viewDidLoaded];NSLog(@&quot;%@&quot;,[self class]);&#125;@end IMP指针IMP： Implementation的缩写。 IMP指针：指向方法实现的指针。 如何调用IMP：1IMP(target,SEL,params...); //与普通C函数的调用方式是相同的 不过如果你的项目没有做其他配置的话这样调用编译器是不会通过的，我们来看一下先它的定义：1234567if !OBJC_OLD_DISPATCH_PROTOTYPES//IMP ： 无参无返回值typedef void (*IMP)(void /* id, SEL, ... */ ); else//有参有返回值typedef id (*IMP)(id, SEL, ...); endif 对IMP指针的使用，需要更改配置文件：除了通过更改配置文件的方式外，还有一种方式就是自己来定义一个和有参的IMP指针相同类型的指针类型123456789101112131415161718192021#import &quot;UIViewController+Log.h&quot;#import &lt;objc/runtime.h&gt;typedef id (*_IMP) (id, SEL, ...);@implementation UIViewController (Log)+(void)load&#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;//获得原始方法Method viewDidLoad = class_getInstanceMethod(self, @selector(viewDidLoad));//获得方法实现IMP viewDIdLoadIMP = method_getImplementation(viewDidLoad);//重现设置方法实现method_setImplementation(viewDidLoad, imp_implementationWithBlock(^(id target, SEL action)&#123;viewDIdLoadIMP(target, @selector(viewDidLoad));NSLog(@&quot;%@ did load&quot;,target);&#125;));&#125;);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Runtime更改pop手势范围]]></title>
      <url>%2F2017%2F03%2F11%2F%E5%88%A9%E7%94%A8Runtime%E6%9B%B4%E6%94%B9pop%E6%89%8B%E5%8A%BF%E8%8C%83%E5%9B%B4%2F</url>
      <content type="text"><![CDATA[思路： 1.导航控制器提供了interactivePopGestureRecognizer属性，这个属性就是控制pop控制器滑动的手势。而系统提供的滑动操作只能是屏幕边缘触发滑动，而有的时候，我们需要提供全屏滑动的效果。所以，开始寻求办法： 2.这个interactivePopGestureRecognizer手势，一定会触发方法来完成转场动画，以及控制转场进度。无论是通过边缘滑动，还是通过全屏幕滑动触发方法的调用，其触发的方法的内部实现原理和产生效果都是一样的，不同的是其手势的作用范围。那么，系统已经提供了手势触发后所调用的方法，我们就可以直接来使用这个方法，我们只是自定义一个手势，来调用这个现成的方法即可。 1.试图寻求在手势对象的内部有没有成员属性类似于target和action。 通过运行时来打印出手势所有的成语属性和属性类型：1234567891011unsigned int count;Ivar *ivars = class_copyIvarList([UIGestureRecognizer class], &amp;count);for (int i = 0; i &lt; count; i ++) &#123;Ivar ivar = ivars[i];const char *nameChar = ivar_getName(ivar);const char *typeChar =ivar_getTypeEncoding(ivar);NSString *typeStr = [NSString stringWithUTF8String:typeChar];NSString *nameStr = [NSString stringWithUTF8String:nameChar];NSLog(@&quot;%@&quot;,nameStr);NSLog(@&quot;%@&quot;,typeStr);&#125; 从打印结果来看，可能有用的就是图中这个：因为这是一个数组，推测一下来看，可能其中的元素就是拥有target和action属性的对象，尝试来打印这个元素获取信息： 因为这个_target是私有属性，所以利用kvc来获取它：123NSMutableArray *targets = [gesture valueForKey:@&quot;_targets&quot;];NSLog(@&quot;%@&quot;,targets);NSLog(@&quot;%@&quot;,targets[0]); 从打印结果来看，我们并没有获取到这个对象，那么应该是系统重新了description方法，使得我们无法直接来获取到这个私有的对象。倒是看见了它的属性_UINavigationInteractiveTransition（action）和handleNavigationTransition(action),而这个属性需要我们通过对象来获取，那么，又尝试通过打断点的方法来查看： 可以看到这个对象就是UIGestureRecognizerTarget现在就能够获取到target和action的值了：12id target = [gestureRecognizerTarget valueForKey:@&quot;_target&quot;];SEL action = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;); 那么，我们把自己创建的手势添加到interactivePopGestureRecognizer的view上，并且调用手势addTarget:action:方法，这里的参数target和action就是我们之前所获取到的 完整的代码：1234567891011121314151617181920212223242526272829UIGestureRecognizer *gesture = self.interactivePopGestureRecognizer;gesture.enabled = NO;//获取到手势作用的viewUIView *gestureView = gesture.view;//创建一个pan手势UIPanGestureRecognizer *popRecognizer = [[UIPanGestureRecognizer alloc] init];//self成为手势的代理popRecognizer.delegate = self;popRecognizer.maximumNumberOfTouches = 1;//重新添加一个手势[gestureView addGestureRecognizer:popRecognizer];/*** 获取系统手势的target数组*/NSMutableArray *_targets = [gesture valueForKey:@&quot;_targets&quot;];/*** 获取它的唯一对象，我们知道它是一个叫UIGestureRecognizerTarget的私有类，它有一个属性叫_target*/id gestureRecognizerTarget = [_targets firstObject];id target = [gestureRecognizerTarget valueForKey:@&quot;_target&quot;];SEL action = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;);/*** 创建一个与系统一模一样的手势，我们只把它的类改为UIPanGestureRecognizer*/[popRecognizer addTarget:target action:action];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC消息转发]]></title>
      <url>%2F2017%2F03%2F10%2FOC%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
      <content type="text"><![CDATA[在调用方法的时候，系统会首先来查找有没有对应的方法的实现，在没有对应的实现的时候，系统会随后调用一些补救方法，当这些方法也没有实现的时候，才会crash，这是一个方法调用的完整过程。当没有方法的实现的时候，补救方法的调用顺序依次为：（一个是类方法的调用所对应的方法，一个是对象方法）+(BOOL)resolveInstanceMethod:(SEL)sel 或者 +(BOOL)resolveClassMethod:(SEL)sel 当这个方法依然无法提供方法的实现的时候，那么，系统会调用下面的方法： -(id)forwardingTargetForSelector:(SEL)aSelector 而当这个方法也无法提供调用方法的实现，那么，最后一次补救机会就是下面方法： -(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector -(void)forwardInvocation:(NSInvocation *)anInvocation 当这三次补救机会都未能提供方法实现的情况下，那么，就crash 这就是整个的调用顺序。 以下通过代码的来补充说明： 首先是在没有提供调用方法的实现，并且没有采取任何的补救措施的情况下的调用情况： 这个时候调用就直接报错： 方法找不到 方法一： 在Man.m当中，重写+(BOOL)resolveInstanceMethod:(SEL)sel方法 1234567891011121314151617#import &quot;Man.h&quot;#import &lt;objc/runtime.h&gt;@implementation Man+(BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == @selector(cook)) &#123;//把这个方法实现动态的添加进去(现在是在调用到这个方法的时候才添加)//当这个方法的实现被添加进去了之后，下次再调用cook方法就不会再进入到这个方法当中，因为现在已经添加了cook方法的时候，而resolveInstanceMethod只会在没有cook方法的实现的时候，才会被调用class_addMethod([self class], sel, (IMP)cook, &quot;v@:&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125;void cook (id self, SEL _cmd)&#123;NSLog(@&quot;man 做饭呢&quot;);&#125;@end 方法二： (没有重新方法一，或者方法一没有解决问题的情况下，就会采取方法二)1.首先是创建一个新的类woman类，这个类有cook方法的实现 12345@implementation Woman-(void)cook&#123;NSLog(@&quot;woman cook&quot;);&#125;@end 在调用man的cook方法的时候，进入到下面方法：12345678-(id)forwardingTargetForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;//这个地方就相当于自己实现不了 ，那么就交给别的对象来提供实现，就是转移return [[Woman alloc] init];&#125;return [super forwardingTargetForSelector:aSelector];&#125; 方法三： 当以上两个方法都无法解决的情况下，那么以下方法就成为了最后的一次补救机会：123456789101112131415-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;NSString *aSelectorStr = NSStringFromSelector(aSelector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];&#125;return [super methodSignatureForSelector:aSelector];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;SEL selector = anInvocation.selector;NSString *aSelectorStr = NSStringFromSelector(selector);if ([aSelectorStr isEqualToString:@&quot;cook&quot;]) &#123;[anInvocation invokeWithTarget:[[Woman alloc] init]];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用 Runtime 为 UIStackView 添加分割线]]></title>
      <url>%2F2017%2F03%2F10%2F%E7%94%A8-Runtime-%E4%B8%BA-UIStackView-%E6%B7%BB%E5%8A%A0%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[用 Runtime 为 UIStackView 添加分割线 使用方法：导入分类： #import &quot;UIStackView+Separator.h&quot; 使用方式 - (void)viewDidLoad { [super viewDidLoad]; //给UIStackView添加方法，并且不采用继承的方式 self.stackView.separatorColor = [UIColor grayColor]; self.stackView.separatorThickness = 1; self.stackView.separatorLength = 50; } UIStackView+Separator.h： #import &lt;UIKit/UIKit.h&gt; @interface UIStackView (Separator) @property UIColor *separatorColor; @property CGFloat separatorLength; @property CGFloat separatorThickness; @end UIStackView+Separator.m： #import &quot;UIStackView+Separator.h&quot; #import &lt;objc/runtime.h&gt; @interface UIStackViewSeparatorHelper : NSObject @property (nonatomic, strong) UIColor *separatorColor; @property (nonatomic, assign) CGFloat separatorLength; @property (nonatomic, assign) CGFloat separatorThickness; @property (nonatomic, weak) UIStackView *stackView; @property (strong, nonatomic) NSMutableArray&lt;UIView *&gt; *separatorViews; -(void)makeSeparators; @end @implementation UIStackViewSeparatorHelper -(instancetype)init{ if (self = [super init]) { self.separatorThickness = 1; self.separatorViews = [NSMutableArray array]; } return self; } -(void)makeSeparators{ UIStackView * __strong strongStackView = self.stackView; // if (!strongStackView || !self.separatorColor || (self.separatorLength &lt;= 0)) { return; } //从Superview当中移除 [self.separatorViews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { [obj removeFromSuperview]; }]; //移除所有的元素 [self.separatorViews removeAllObjects]; // [strongStackView.arrangedSubviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if (idx == 0) { return; } //idx == 1 取出第0个 遍历出当前的一个的时候，取出上一个 UIView *previousView = strongStackView.arrangedSubviews[idx - 1]; //创建了一个分割线 UIView *separatorView = [[UIView alloc] init]; //设置背景颜色 separatorView.backgroundColor = self.separatorColor; // CGFloat center; //如果排布的方式是水平的时候 if (strongStackView.axis == UILayoutConstraintAxisHorizontal) { // center = (CGRectGetMaxX(previousView.frame) + CGRectGetMinX(obj.frame)) / 2.0; separatorView.frame = CGRectMake(center, (CGRectGetHeight(strongStackView.frame) - self.separatorLength) / 2.0, self.separatorThickness, self.separatorLength); } else { center = (CGRectGetMaxY(previousView.frame) + CGRectGetMinY(obj.frame)) / 2.0; separatorView.frame = CGRectMake((CGRectGetWidth(strongStackView.frame) - self.separatorLength) / 2.0, center, self.separatorLength, self.separatorThickness); } //这里使用addSubview: 而不能使用arrangedSubviews，这样就能够避免系统的布局，而由自己来布局separater [strongStackView addSubview:separatorView]; //将separatorView添加到容器数组当中 [self.separatorViews addObject:separatorView]; }]; } @end @implementation UIStackView (Separator) static const char kHelperKey; +(void)load{ // Method m1 = class_getInstanceMethod([self class], @selector(layoutSubviews)); // Method m2 = class_getInstanceMethod([self class], @selector(tc_layoutSubviews)); // method_exchangeImplementations(m1, m2); // Class cls = [self class]; Method oriMethod = class_getInstanceMethod(cls, @selector(layoutSubviews)); Method newMethod = class_getInstanceMethod(cls, @selector(tc_layoutSubviews)); //v@: method_getTypeEncoding BOOL didAddMethod = class_addMethod([self class], @selector(layoutSubviews), method_getImplementation(newMethod), &quot;v@:&quot;); if (didAddMethod) { class_replaceMethod([self class], @selector(tc_layoutSubviews), method_getImplementation(oriMethod), &quot;v@:&quot;); }else{ method_exchangeImplementations(oriMethod, newMethod); } } #pragma mark --setter and getter /*-------这里的属性因为分类无法存储的缘故，所以采用了转移到其他类，我们只要拥有这个其他类，就能够获取到他的属性-------*/ /*------------当触发set方法的时候，不仅要触发出传入值得存储，同时要创建和布局分割线----------------*/ -(void)setSeparatorColor:(UIColor *)separatorColor{ [self stackViewSeparatorHelper].separatorColor = separatorColor; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorLength:(CGFloat)separatorLength{ [self stackViewSeparatorHelper].separatorLength = separatorLength; [[self stackViewSeparatorHelper] makeSeparators]; } -(void)setSeparatorThickness:(CGFloat)separatorThickness{ [self stackViewSeparatorHelper].separatorThickness = separatorThickness; [[self stackViewSeparatorHelper] makeSeparators]; } -(CGFloat)separatorThickness{ return [self stackViewSeparatorHelper].separatorThickness; } -(UIColor *)separatorColor{ return [self stackViewSeparatorHelper].separatorColor; } -(CGFloat)separatorLength{ return [self stackViewSeparatorHelper].separatorLength; } -(UIStackViewSeparatorHelper *)stackViewSeparatorHelper{ UIStackViewSeparatorHelper *stackViewSeparatorHelper = objc_getAssociatedObject(self, &amp;kHelperKey); //在这个get方法当中，如果没有get到，那么就触发set的操作 if (!stackViewSeparatorHelper) { UIStackViewSeparatorHelper * helper = [[UIStackViewSeparatorHelper alloc] init]; helper.stackView = self; objc_setAssociatedObject(self, &amp;kHelperKey, helper, OBJC_ASSOCIATION_RETAIN_NONATOMIC); stackViewSeparatorHelper = helper; } return stackViewSeparatorHelper; } /** *在布局stackView的时候，这个时候，就需要同时布局分割线，所以，必须要监听到layoutSubViews方法 * 比如说，UIStackView添加了子控件（通过arrangedSubviews添加），那么就会调用这个方法来布局 ，这个时候 ，就需要重新布局separator * UIStackView 只会负责 arrangedSubviews 的布局，也就是说我们利用这个特性来将分割线直接加到 stack view 上而不受其布局，只要我们不使用 addArrangedSubView 即可。 */ -(void)tc_layoutSubviews{ //先让UIStackView的arrangedSubviews完成布局 [self tc_layoutSubviews]; //布局separater [[self stackViewSeparatorHelper] makeSeparators]; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIVisualEffect 模糊动画]]></title>
      <url>%2F2017%2F03%2F09%2FUIVisualEffect-%E6%A8%A1%E7%B3%8A%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[UIVisualEffect 模糊动画Demo @interface ViewController () @property (weak, nonatomic) IBOutlet UIVisualEffectView visualEffect; @property (weak, nonatomic) IBOutlet UILabel label; @property (weak, nonatomic) IBOutlet NSLayoutConstraint *topLayoutConstraint; @end @implementation ViewController - (IBAction)visualEffectViewClick:(id)sender { if (self.label.hidden == YES) { self.label.hidden = NO; self.topLayoutConstraint.constant = 160; UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:(UIBlurEffectStyleDark)]; [UIView animateWithDuration:1 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(UIViewAnimationOptionCurveEaseInOut) animations:^{ self.visualEffect.effect = blurEffect; self.label.textColor = [UIColor colorWithWhite:1 alpha:1]; [self.view layoutIfNeeded]; } completion:nil]; }else{ self.topLayoutConstraint.constant = 0; [UIView animateWithDuration:0.2 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0 options:(0) animations:^{ self.label.textColor = [UIColor colorWithWhite:1 alpha:0.2]; [self.view layoutIfNeeded]; self.visualEffect.effect = nil; } completion:^(BOOL finished) { self.label.hidden = YES; self.topLayoutConstraint.constant = 360; }]; } } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[彩虹渐变的滚动列表]]></title>
      <url>%2F2017%2F03%2F09%2F%E5%BD%A9%E8%99%B9%E6%B8%90%E5%8F%98%E7%9A%84%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[彩虹渐变的滚动列表原文链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#import &quot;ViewController.h&quot;@interface ViewController()&lt;UITableViewDelegate,UITableViewDataSource&gt;//数组用来存储起始颜色和终点颜色&#123;NSArray *_color;&#125;@property(nonatomic,strong) UITableView *tableView;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];//存储颜色变化的起始值和终值self-&gt;_color = @[[UIColor colorWithRed:0.85 green:0 blue:0.09 alpha:1],[UIColor colorWithRed:0.9 green:0.56 blue:0.11 alpha:1]];self.view.backgroundColor = [UIColor blackColor];self.tableView = [[UITableView alloc] initWithFrame:self.view.bounds];self.tableView.separatorStyle = UITableViewCellSelectionStyleNone;self.tableView.contentInset = UIEdgeInsetsMake(20, 0, 0, 0);self.tableView.delegate =self;self.tableView.dataSource = self;UIVisualEffectView *veView = [[UIVisualEffectView alloc] initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]];veView.frame = CGRectMake(0, 0, self.view.bounds.size.width, 20);[self.view addSubview:self.tableView];[self.view addSubview:veView];&#125;//创建的UIColor对象无法再获取到其中的颜色组件，将这里的颜色数组作为参数传入，这样通过这个方法可获得在任何颜色设定基础上的对应颜色-(UIColor *)calculateColorWithProgress:(float)progress usingColors:(NSArray&lt;UIColor *&gt;*)colors&#123;UIColor *color1 = [colors firstObject];UIColor *color2 = [colors lastObject];// UIColor -&gt; CGColorconst CGFloat *color1Components = CGColorGetComponents(color1.CGColor);const CGFloat *color2Components = CGColorGetComponents(color2.CGColor);// 这里从终点值到初始值的差值 * progress = 【0 - 差值】float red = color1Components[0] + (color2Components[0] - color1Components[0]) * progress;float green = color1Components[1] + (color2Components[1] - color1Components[1]) * progress;float blue = color1Components[2] + (color2Components[2] - color1Components[2]) * progress;return [UIColor colorWithRed:red green:green blue:blue alpha:1];&#125;-(float)calculateProgressWithView:(UIView *)view&#123;//converRect: toView: 转换坐标系//从相对于tableView的坐标系 转换到view上去CGRect convertedRect = [view convertRect:view.bounds toView:self.view];CGFloat convertedY = convertedRect.origin.y;//[0 - 1]return convertedY / (self.view.bounds.size.height - 60);&#125;-(UITableViewCell *)makeTableViewCell&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;];cell.selectionStyle = UITableViewCellSeparatorStyleNone;cell.textLabel.font = [UIFont boldSystemFontOfSize:16];cell.textLabel.textColor = [UIColor whiteColor];//设置文字的阴影cell.textLabel.shadowColor = [UIColor colorWithWhite:0 alpha:0.4];cell.textLabel.shadowOffset = CGSizeMake(0, 1);//下面的两个 CAShapeLayer 主要是为了实现高光阴影的效果，也就是这个 cell 的上边有一条亮边，下边有层阴影CAShapeLayer *topHighlightLayer = [CAShapeLayer layer];topHighlightLayer.path = CGPathCreateWithRect(CGRectMake(0, 0, self.view.bounds.size.width, 1), nil);topHighlightLayer.fillColor = [UIColor whiteColor].CGColor;topHighlightLayer.opacity = 0.1;[cell.layer addSublayer:topHighlightLayer];CAShapeLayer *bottomShadowLayer = [CAShapeLayer layer];bottomShadowLayer.path = CGPathCreateWithRect(CGRectMake(0, 59, self.view.bounds.size.width, 1), nil);bottomShadowLayer.fillColor = [UIColor blackColor].CGColor;bottomShadowLayer.opacity = 0.2;[cell.layer addSublayer:bottomShadowLayer];return cell;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 30;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *CellIdentifiter = @&quot;Cell&quot;;UITableViewCell *cell = [self.tableView dequeueReusableCellWithIdentifier:CellIdentifiter];if (!cell) &#123; cell = [self makeTableViewCell];&#125;cell.textLabel.text = [NSString stringWithFormat:@&quot;This is test item %ld&quot;,indexPath.row];cell.detailTextLabel.text = @&quot;1&quot;;return cell;&#125;//需要注意的是，cell 刚创建完毕后滚动的代理方法是不会触发的//所以我们需要用到tableView:willDisplayCell:forRowAtIndexPath:这个代理方法来对每个新建的 cell 作相应设置。-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;//设置cell的背景色cell.backgroundColor = [self calculateColorWithProgress:[self calculateProgressWithView:cell] usingColors:self -&gt; _color];&#125;-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;return 60;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;if ([scrollView isEqual:self.tableView]) &#123; //获取所有可见的cell [self.tableView.visibleCells enumerateObjectsUsingBlock:^(__kindof UITableViewCell * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; float progress = [self calculateProgressWithView:obj]; UIColor *color = [self calculateColorWithProgress:progress usingColors:self -&gt; _color]; obj.backgroundColor = color; &#125;];&#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[巧妙运用对象关联设计alertview]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%B7%A7%E5%A6%99%E8%BF%90%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E8%AE%BE%E8%AE%A1alertview%2F</url>
      <content type="text"><![CDATA[UIAlertView事件处理方式一：通过这种方式，存在的缺陷有：控件的创建和事件的处理是分布的，这样的阅读性是较差的，同时，在事件处理方法当中，当面对多个UIAlertView的时候，需要进行if else的判断，代码选得特别冗余 // button1 点击执行的方法 - (IBAction)alertClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 1000; [alertView show]; } // button2 点击执行的方法 - (IBAction)alertClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:self cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;ok&quot;, nil]; alertView.tag = 2000; [alertView show]; } // alertview 点击执行的delegate方法,前提 需要self实现UIAlertViewDelegate协议 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { if (alertView.tag == 1000) { NSLog(@&quot;alertView1 执行逻辑操作&quot;); } else if (alertView.tag == 2000) { NSLog(@&quot;alertView2 执行逻辑操作&quot;); } else if (alertView.tag == 3000) { NSLog(@&quot;alertView3 执行逻辑操作&quot;); } // ...等等很多alertview } UIAlertView事件处理方式二： 在UIAlertView的分类当中UIAlertView+tc.h @interface UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void(^)()) block; @end UIAlertView+tc.m typedef void(^block)(); static char const *TCAlertViewKey = “TCAlertViewKey”; #import &quot;UIAlertView+tc.h&quot; #import &lt;objc/message.h&gt; @interface UIAlertView()&lt;UIAlertViewDelegate&gt; @end @implementation UIAlertView (tc) -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ objc_setAssociatedObject(self, TCAlertViewKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC); self.delegate = self; } #pragma mark -UIAlertViewDelegate -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex: (NSInteger)buttonIndex{ block block = objc_getAssociatedObject(self, TCAlertViewKey); block(alertView, buttonIndex); } @end 调用的部分： - (IBAction)buttonClick:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@---- %zd&quot;,alertView, index); }]; } - (IBAction)buttonClick2:(id)sender { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;a&quot; message:@&quot;b&quot; delegate:nil cancelButtonTitle:@&quot;c&quot; otherButtonTitles:@&quot;d&quot;, nil]; [alertView show]; [alertView tc_clickButtonAtIndexWithBlock:^(UIAlertView *alertView, NSInteger index){ NSLog(@&quot;%@ +++++ %zd&quot;,alertView, index); }]; } UIAlertView事件处理方式三： typedef void(^block)(); #import &lt;objc/message.h&gt; #import &quot;UIAlertView+tc.h&quot; static char const *TCAlertViewKey = &quot;TCAlertViewKey&quot;; /** * 一个专门的类，用来处理代理事件，包括block的存储以及事件的处理 */ @interface TCAlertViewDelegate : NSObject&lt;UIAlertViewDelegate&gt; { block _block; } -(instancetype)initWithBlock:(block) block; @end @implementation TCAlertViewDelegate -(instancetype)initWithBlock:(block)block{ if (self = [super init]) { objc_setAssociatedObject(self, TCAlertViewKey, self, OBJC_ASSOCIATION_COPY_NONATOMIC); _block = block; } return self; } -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex{ if (_block) { _block(alertView, buttonIndex); } } @end @implementation UIAlertView (tc) //delegate -&gt; weak ，如果直接让TCAlertViewDelegate对象成为代理，会马上 挂掉 -(void)tc_clickButtonAtIndexWithBlock:(void (^)())block{ //添加了一个关联对象，因为这个对象的存储方式是copy，所以这个对象就不会被释放 id delegate = objc_getAssociatedObject( [[TCAlertViewDelegate alloc] initWithBlock:block],TCAlertViewKey); //让这个专门的类成为代理 self.delegate = delegate; } @end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[runtime]]></title>
      <url>%2F2017%2F03%2F07%2Fruntime%2F</url>
      <content type="text"><![CDATA[runtime作用 1.发送消息 2.交换方法 3.动态添加方法 4 给分类添加属性 5.字典转模型 一、runtime简介 对于C语言，函数的调用在编译的时候，就决定调用哪个函数。 对于OC的函数，属于动态调用过程，在编译的时候，并不能真正的决定调用哪个函数，只有在真正的运行的时候才会根据函数的名称找到对应的函数来调用 事实证明： 在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错 在编译阶段，C语言调用未实现的函数就会报错 二、runtime作用 1.发送消息 方法调用的本质，就是让对象发送消息 objc_megSend,只有对象才能发送消息，因此以objc开头 使用消息机制前提，必须导入#import clang -rewrite-objc main.m 查看最终生成代码 123@autoreleasepool &#123;Person *person = [[Person alloc] init];&#125; 123456int main(int argc, const char * argv[]) &#123;/* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));&#125;return 0;&#125; 或者12Person *person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));person = ((Person *(*)(id, SEL))(void *)objc_msgSend)((id)person, sel_registerName(&quot;init&quot;)); 创建person对象12345678910111213Person *p = [[Person alloc] init];// 调用对象方法[p eat];// 本质：让对象发送消息objc_msgSend(p, @selector(eat));// 调用类方法的方式：两种// 第一种通过类名调用[Person eat];// 第二种通过类对象调用[[Person class] eat];// 用类名调用类方法，底层会自动把类名转换成类对象调用// 本质：让类对象发送消息objc_msgSend([Person class], @selector(eat)); 示例12345Person.h@interface Person : NSObject- (void)run:(NSInteger)metre;- (void)eat;@end Person.m123456789101112131415161718192021222324#import &quot;Person.h&quot;@implementation Person- (void)eat&#123;NSLog(@&quot;吃&quot;);&#125;- (void)run:(NSInteger)metre&#123;NSLog(@&quot;跑了%ld&quot;,metre);&#125;@end消息的发送（方法的调用底层实现是对消息的发送）Person *p = objc_msgSend([Person class], @selector(alloc));//Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));p = objc_msgSend(p, @selector(&quot;init&quot;));//调用eat方法[p eat];//或者//msgSend(p, @selector(&quot;eat&quot;));//msgSend(p, sel_registerName(&quot;eat&quot;));//调用run：方法[p run:20];//msgSend(p , @selector(run:), 20);//msgSend(p, sel_register(&quot;run:&quot;), 20); 2.交换方法 开发场景： 系统自动的方法功能不够用，给系统自带的方法扩展一些功能，并且保持原有的功能，使用runtime交换方法需求：在项目当中，我们一直以来通过imageNamed：方法来加载图片，但是我们无法得知图片是否加载成功，现在，提出这样的需求，需要我们在调用这个方法的时候，同时得知图片是否加载成功。分析： 使用继承： 需要我们在所有使用到imageNamd:方法的地方都导入继承类的头文件，并且更改方法的调用者，而且需要告知其他的开发人员，需要调用这个继承的类，所以，使用起来很不方便使用分类：这样会覆盖系统的实现， 就是完全的重新实现这个方法所以，对于这样的开发需求，更好的实现方法是通过runtime的交换方法来实现 通过继承的方式来实现需求：123456789101112#import &quot;TCImage.h&quot;@implementation TCImage+(UIImage *)imageNamed:(NSString *)name&#123;UIImage *image = [super imageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，就会麻烦一些：首先需要导入头文件 #import “TCImage.h”在调用方法的时候，就需要通过一个新的类来调用UIImage *image = [UIImage imageNamed:@””];而运用runtime，通过交换方法的实现：123456789101112131415161718#import &quot;UIImage+Image.h&quot;#import &lt;objc/message.h&gt;@implementation UIImage (Image)+(void)load&#123;Method m1 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(imageNamed:));Method m2 = class_getClassMethod(objc_getClass(&quot;UIImage&quot;), @selector(tcimageNamed:));method_exchangeImplementations(m1, m2);&#125;+(instancetype)tcimageNamed:(NSString *)name&#123;UIImage *image = [self tcimageNamed:name];if (!image) &#123;NSLog(@&quot;加载图片失败&quot;);&#125;else&#123;NSLog(@&quot;加载图片成功&quot;);&#125;return image;&#125;@end 在调用的时候，没有任何的改变，但已经在系统实现的基础上，多了获取是否加载成功的功能 3.动态添加方法开发使用场景： 如果一个类方法非常多，加载到内存的时候也比较耗资源，需要给每个方法生成映射表，可以通过动态给某个类添加方法比如：很多应用都分了会员和非会员，很多方法，在非会员的时候，完全都不会使用到，这个时候把方法加载到内存是比较费资源的，没有必要生成这些不会用到的方法的映射表 这个时候，就可以通过动态添加方法来解决这一问题，当用到这个方法的时候再去添加实现调用一个并没有添加实现的方法，需要用到performSelector12Person *p = [[Person alloc] init];[p performSelector:@selector(run:) withObject:@10]; 在Person.m文件中1234567891011121314void aaa(id self, SEL _cmd, NSNumber *meter) &#123;NSLog(@&quot;跑了%@&quot;, meter);&#125;// 任何方法默认都有两个隐式参数,self,_cmd// 什么时候调用:只要一个对象调用了一个未实现的方法就会调用这个方法,进行处理// 作用:动态添加方法,处理未实现+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;if (sel == NSSelectorFromString(@&quot;run:&quot;)) &#123;class_addMethod(self, sel, (IMP)aaa, &quot;v@:@&quot;);return YES;&#125;return [super resolveInstanceMethod:sel];&#125; 4 给分类添加属性分析： 给一个类声明属性，本质就是给这个类添加关联对象，而不是直接把这个值的内存添加到类内存当中应用场景： 给一个系统的类添加一个关联对象（新增属性）给系统类NSObject添加一个那么属性 1234@interface NSObject (Property)//在分类当中，这里只会生成get和set方法的声明，并不会生成方法的实现，所以，也就没有必要说明存储机制@property NSString *name;@end .m文件12345678910#import &quot;NSObject+Property.h&quot;#import &lt;objc/message.h&gt;@implementation NSObject (Property)-(NSString *)name&#123;return objc_getAssociatedObject(self, &quot;name&quot;);&#125;-(void)setName:(NSString *)name&#123;objc_setAssociatedObject(self, &quot;name&quot;, name,OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;@end 5.字典转模型 设计模型：字典转模型的第一步 模型属性，通常需要跟字典中的key一一对应 问题： 一个一个的添加模型属性是一件乏味没有技术含量耗时的操作 需求：能不能自动根据字典，生成对应的属性 解决： 提供一个分类，专门根据字典生成对应的属性字符串 1234567891011121314151617181920212223242526272829303132@implementation NSObject (Log)// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123;// 拼接属性字符串代码NSMutableString *strM = [NSMutableString string];// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码[dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;// 类型经常变，抽出来NSString *type;if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFString&quot;)]) &#123;type = @&quot;NSString&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFArray&quot;)])&#123;type = @&quot;NSArray&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFNumber&quot;)])&#123;type = @&quot;int&quot;;&#125;else if ([obj isKindOfClass:NSClassFromString(@&quot;__NSCFDictionary&quot;)])&#123;type = @&quot;NSDictionary&quot;;&#125;// 属性字符串NSString *str;if ([type containsString:@&quot;NS&quot;]) &#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, strong) %@ *%@;&quot;,type,key];&#125;else&#123;str = [NSString stringWithFormat:@&quot;@property (nonatomic, assign) %@ %@;&quot;,type,key];&#125;// 每生成属性字符串，就自动换行。[strM appendFormat:@&quot;\n%@\n&quot;,str];&#125;];// 把拼接好的字符串打印出来，就好了。NSLog(@&quot;%@&quot;,strM);&#125;@end 字典转模型的方式一：KVC 12345678@implementation Status+ (instancetype)statusWithDict:(NSDictionary *)dict&#123;Status *status = [[self alloc] init];[status setValuesForKeysWithDictionary:dict];return status;&#125;@end 转模型弊端：必须保证，模型中的属性和字典中的key一一对应。 如果不一致，就会调用[ setValue:forUndefinedKey:] 报key找不到的错。 分析:模型中的属性和字典的key不一一对应，系统就会调用setValue:forUndefinedKey:报错。 解决:重写对象的setValue:forUndefinedKey:,把系统的方法覆盖， 就能继续使用KVC，字典转模型了。 //因为通过key没有找到对应的属性，所以调用setValue:forUndefinedKey:报错，那么，通过通过重新这个方法的实现就避免了报错123- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; &#125; 字典转模型的方式二：Runtime 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 解析Plist文件NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;status.plist&quot; ofType:nil];NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];// 获取字典数组NSArray *dictArr = statusDict[@&quot;statuses&quot;];// 自动生成模型的属性字符串// [NSObject resolveDict:dictArr[0][@&quot;user&quot;]];_statuses = [NSMutableArray array];// 遍历字典数组for (NSDictionary *dict in dictArr) &#123;Status *status = [Status modelWithDict:dict];[_statuses addObject:status];&#125;// 测试数据NSLog(@&quot;%@ %@&quot;,_statuses,[_statuses[0] user]);&#125;@end@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123;// 思路：遍历模型中所有属性-》使用运行时// 0.创建对应的对象id objc = [[self alloc] init];// 1.利用runtime给对象中的成员属性赋值// class_copyIvarList:获取类中的所有成员属性// Ivar：成员属性的意思// 第一个参数：表示获取哪个类中的成员属性// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。/* 类似下面这种写法Ivar ivar;Ivar ivar1;Ivar ivar2;// 定义一个ivar的数组aIvar a[] = &#123;ivar,ivar1,ivar2&#125;;// 用一个Ivar *指针指向数组第一个元素Ivar *ivarList = a;// 根据指针访问数组第一个元素ivarList[0];*/unsigned int count;// 获取类中的所有成员属性Ivar *ivarList = class_copyIvarList(self, &amp;count);for (int i = 0; i &lt; count; i++) &#123;// 根据角标，从数组取出对应的成员属性Ivar ivar = ivarList[i];// 获取成员属性名NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];// 处理成员属性名-&gt;字典中的key// 从第一个角标开始截取NSString *key = [name substringFromIndex:1];// 根据成员属性名去字典中查找对应的valueid value = dict[key];// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型// 判断下value是否是字典if ([value isKindOfClass:[NSDictionary class]]) &#123;// 字典转模型// 获取模型的类对象，调用modelWithDict// 模型的类名已知，就是成员属性的类型// 获取成员属性类型NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];// 生成的是这种@&quot;@\&quot;User\&quot;&quot; 类型 -》 @&quot;User&quot; 在OC字符串中 \&quot; -&gt; &quot;，\是转义的意思，不占用字符// 裁剪类型字符串NSRange range = [type rangeOfString:@&quot;\&quot;&quot;];type = [type substringFromIndex:range.location + range.length];range = [type rangeOfString:@&quot;\&quot;&quot;];// 裁剪到哪个角标，不包括当前角标type = [type substringToIndex:range.location];// 根据字符串类名生成类对象Class modelClass = NSClassFromString(type);if (modelClass) &#123; // 有对应的模型才需要转// 把字典转模型value = [modelClass modelWithDict:value];&#125;&#125;// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.// 判断值是否是数组if ([value isKindOfClass:[NSArray class]]) &#123;// 判断对应类有没有实现字典数组转模型数组的协议if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;// 转换成id类型，就能调用任何对象的方法id idSelf = self;// 获取数组中字典对应的模型NSString *type = [idSelf arrayContainModelClass][key];// 生成模型Class classModel = NSClassFromString(type);NSMutableArray *arrM = [NSMutableArray array];// 遍历字典数组，生成模型数组for (NSDictionary *dict in value) &#123;// 字典转模型id model = [classModel modelWithDict:dict];[arrM addObject:model];&#125;// 把模型数组赋值给valuevalue = arrM;&#125;&#125;if (value) &#123; // 有值，才需要给模型的属性赋值// 利用KVC给模型中的属性赋值[objc setValue:value forKey:key];&#125;&#125;return objc;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITableView 顶部加入视差图片的效果]]></title>
      <url>%2F2017%2F03%2F07%2FUITableView-%E9%A1%B6%E9%83%A8%E5%8A%A0%E5%85%A5%E8%A7%86%E5%B7%AE%E5%9B%BE%E7%89%87%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[UITableView 顶部加入视差图片的效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#import &quot;ViewController.h&quot;@interface ViewController ()&lt;UITableViewDelegate,UITableViewDataSource&gt;@property(nonatomic,weak) UIImageView *imageView;@property(nonatomic,weak) UITableView *tableView;@end@implementation ViewController-(UITableView *)tableView&#123;if (_tableView == nil) &#123;UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];_tableView = tableView;_tableView.contentInset = UIEdgeInsetsMake(300, 0, 0, 0);_tableView.dataSource = self;_tableView.delegate = self;[self.view addSubview:tableView];&#125;return _tableView;&#125;-(UIImageView *)imageView&#123;if (_imageView == nil) &#123;UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, -150, self.view.bounds.size.width, 300)];imageView.layer.anchorPoint = CGPointMake(0.5, 0);_imageView = imageView;_imageView.image = [UIImage imageNamed:@&quot;IMG_0084&quot;];[self.view addSubview:_imageView];&#125;return _imageView;&#125;-(void)viewWillAppear:(BOOL)animated&#123;[super viewWillAppear:animated];[self.tableView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];[UIView beginAnimations:nil context:nil];[self makeParallaxEffect];[UIView commitAnimations];&#125;-(void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];[self.tableView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];[UIView beginAnimations:nil context:nil];self.navigationController.navigationBar.alpha = 1.0;[UIView commitAnimations];&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;if (object == _tableView) &#123;[self makeParallaxEffect];&#125;&#125;-(void)makeParallaxEffect&#123;CGFloat y = [[self.tableView valueForKey:@&quot;contentOffset&quot;] CGPointValue].y;if (y &lt; - 300.0) &#123;CGFloat scale = fabs(y) / 300;_imageView.transform = CGAffineTransformMakeScale(scale, scale);&#125;else if(y &lt; 0)&#123;_imageView.transform = CGAffineTransformMakeTranslation(0, -(300 + y));//y=0 alp=1 y=-300 alp=0self.navigationController.navigationBar.alpha = (y + 300)/300.0;_imageView.alpha = (1 - self.navigationController.navigationBar.alpha);&#125;&#125;-(void)viewDidLoad&#123;//这里自己来计算contentInset，所以，将automaticallyAdjustsScrollViewInsets属性值设置为NOself.automaticallyAdjustsScrollViewInsets = NO;//需要注意的是，这里的_tableView要先于_imageView添加，才能保证_imageView能够显示出来self.tableView.backgroundColor = [UIColor whiteColor];self.imageView.backgroundColor = [UIColor whiteColor];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return 200;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];cell.textLabel.text = @&quot;test&quot;;return cell;&#125;-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;[self performSegueWithIdentifier:@&quot;tag&quot; sender:nil];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[innerHTML和creatTextCode区分]]></title>
      <url>%2F2017%2F03%2F05%2FinnerHTML%E5%92%8CcreatTextCode%E5%8C%BA%E5%88%86%2F</url>
      <content type="text"><![CDATA[innerHTML 与 createTextNodeinnerHTML在js是双向功能:获取对象的内容或向对象插入内容1234567891011121314&lt;p id=&quot;pid&quot;&gt;我将被替换&lt;/p&gt;&lt;button onclick=&quot;replaceContentFunction()&quot;&gt;点击替换标签&lt;/button&gt;&lt;p id=&quot;getInnerHTMLID&quot;&gt;我的内容将被获取&lt;/p&gt;&lt;button onclick=&quot;getInnerHTMLFuncation()&quot;&gt;点我获取内容&lt;/button&gt;&lt;script&gt;function replaceContentFunction() &#123;var node = document.getElementById(&quot;pid&quot;);node.innerHTML = &quot;我已经被替换啦😭&quot;;&#125;function getInnerHTMLFuncation() &#123;var node = document.getElementById(&quot;getInnerHTMLID&quot;);alert(node.innerHTML);&#125;&lt;/script&gt; 我将被替换 点击替换标签 我的内容将被获取 点我获取内容 function replaceContentFunction() { var node = document.getElementById("pid"); node.innerHTML = "我已经被替换啦😭"; } function getInnerHTMLFuncation() { var node = document.getElementById("getInnerHTMLID"); alert(node.innerHTML); } innerHTML与createTextNode区别:都可以把一段内容添加到一个节点中,区别在于:如果添加的内容当中有html标签,而这段标签在createTextNode方法中会被当做文本内容来处理,不会被浏览器解析,而在innerHTML中会被当做标签进行解析.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习之Location对象]]></title>
      <url>%2F2017%2F03%2F05%2FHTML%E5%AD%A6%E4%B9%A0%E4%B9%8BLocation%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[Location对象包含有关当前URL的信息,Location对象是window对象的一部分,可通过window.location来访问 Location对象方法 reload()定义和用法reload() 方法用于重新加载当前文档。如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。 如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift健的效果是完全一样。 实例1234&lt;script&gt;function btnClickFunc() &#123; window.location.reload()&#125;&lt;/script&gt;&lt;button onclick=&quot;btnClickFunc()&quot;&gt;点击刷新当前页面&lt;/button&gt; function btnClickFunc() { window.location.reload()} 点击刷新当前页面 assign()定义和用法assign() 方法可加载一个新的文档。语法1location.assign(URL) 实例1234&lt;script&gt;function reloadNewPageBtnClickFunc() &#123;window.location.assign(&quot;https:www.baidu.com&quot;)&#125;&lt;/script&gt;&lt;button onclick=&quot;reloadNewPageBtnClickFunc()&quot;&gt;点击加载一个新的url&lt;/button&gt; function reloadNewPageBtnClickFunc() {window.location.assign(“https:www.baidu.com”)} 点击加载一个新的url Location对象属性 属性描述hostname设置或返回当前 URL 的主机名。href设置或返回完整的 URL。pathname设置或返回当前 URL 的路径部分。protocol设置或返回当前 URL 的协议。search设置或返回从问号 (?) 开始的 URL（查询部分）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL Scheme]]></title>
      <url>%2F2017%2F03%2F04%2FURL-Scheme%2F</url>
      <content type="text"><![CDATA[URL Scheme经常使用的地方有:APP间跳转,服务器通知客户端的跳转以及H5与Naative跳转 scheme三方面的作用: 服务器下发跳转路径,客户端根据服务器发送的跳转路径进行跳转H5页面点击锚点根据锚点具体跳转路径APP端跳转具体的页面APP端收到服务器端下发的PUSH通知栏消息,根据消息的跳转路径,跳转相关页面 URL Scheme 概述客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如车辆详情页、订单详情页、消息通知页、促销广告页等等。也可以执行某些指定动作，如订单支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面。 URL scheme 的格式客户端自定义的 URL 作为从一个应用调用另一个的基础，遵循 RFC 1808 (Relative Uniform Resource Locators) 标准。这跟我们常见的网页内容 URL 格式一样。一个普通的 URL 分为几个部分，scheme、host、relativePath、query。我们用到的NSURL123NSURL *url = [NSURL URLWithString:@&quot;http://www.testurl.com:8080/subpath/subsubpath?uid=123&amp;gid=456&quot;];[url scheme]为http, [url host]为www.testurl.com，[url port]为8080，[url path]为/subpath/subsubpath，[url lastPathComponent]为subsubpath，[url query]为uid=123&amp;gid=456 一个应用中使用的 URL 例子（该 URL 会调起车辆详情页）：12zqprojectmobile://project/carDetail?car_id=123456scheme为zqprojectmobile,host为project,relativePath为/carDetail,query为car_id=123456 项目中定义了专门的类命名为JumpURLHandle，通过类方法parseURL:来处理参数中的url。本文以此为例讲解scheme的定义与解析。首先客户端应用向操作系统注册一个或者多个 URL scheme，例如项目中就定 义了多个分别scheme，分别为： 123zqprojectmobile: 对应普通APP间跳转schemezqprojectwxpay: 对应微信支付完成之后跳转回来的schemezqprojectalipay：对应支付宝支付完成之后跳转回来的scheme 对应的parseURL:方法里解析为：1234567891011121314151617181920212223//一个专门的类用于处理跳转,并且提供了一个方法解析url+ (BOOL)parseURL:(NSURL *)url&#123;//对获取到的url进行解析判断,确定跳转的性质// 支付宝客户端支付后的回调if ([[url scheme] isEqualToString:@&quot;zqprojectalipay&quot;]|| ([[[url scheme] lowercaseString] isEqualToString:kUuyongcheAlipayScheme]))&#123;return 支付宝支付完成后的回调处理方法;&#125;// 微信客户端支付后的回调 协议是zqprojectwxpay并且host是pay,则属于微信支付完成之后的回调else if ([url.scheme isEqualToString:@&quot;zqprojectwxpay&quot;] &amp;&amp; [url.host isEqualToString:@&quot;pay&quot;])&#123;return 微信支付完成后的回调处理方法;&#125;// 本应用 scheme 调用else if (([[url scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[url scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;return [[JumpURLHandle getInstance] parseAppUrl:url];&#125;return NO;&#125; 定义relativePath，并通过relativePath来判断是执行动作还是跳转页面，当执行动作时把relativePath定义为”/action”，在解析时如果url的relativePath是”/action”则跳转到执行动作的处理方法里，否则执行跳转页面的逻辑。例如：12345zqprojectmobile://project/action?name=back，relativePath为/action，执行动作（返回前页）zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，执行跳转页面的逻辑 代码：12345678910111213141516- (BOOL)parseAppUrl:(NSURL *)url&#123;NSString *relativePath = [url relativePath];// scheme 调起执行动作if ([relativePath isEqualToString:@&quot;/action&quot;])&#123;[self jumpActions:url];&#125;// scheme 调起跳转页面else&#123;[self jumpNativeViewControllers:url];&#125;return YES;&#125; 如果是执行动作的逻辑，获取query，字符串处理，获取键值对，获取名称为”name”的key对应的字符串，字符串对比判断执行相应的动作例如：12qprojectmobile://project/action?name=back，relativePath为/action，query为name=back，字符串处理后得到字典@&#123;name:back&#125;, 代码：1234567891011- (void)jumpActions:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *actionName = [dictionaryQuery objectForKey:@&quot;name&quot;];// 返回前面的页面if ([actionName isEqualToString:@&quot;back&quot;])&#123;//返回上一个页面的动作&#125; 如果是执行跳转页面的逻辑，可以直接将要跳转的页面设置为relativePath的值，然后获取relativePath字符串进行对比跳转相应的页面。如果页面跳转需要传值可以放到query里，获取url的query，字符串处理，获取键值对，一一赋值，例如：1234zqprojectmobile://project/order?order_id=42347645&amp;type=2relativePath为/order，跳转到订单详情页面query为order_id=42347645&amp;type=2，字符串处理获取字典@&#123;order_id:42347645,type:2&#125;,订单详情页面的订单id为order_id对应的值42347645，订单类型为2 代码：123456789101112131415161718- (void)jumpNativeViewControllers:(NSURL *)url&#123;NSString *relativePath = [url relativePath];if ([relativePath isEqualToString:@&quot;/order&quot;])&#123;[self jumpOrder:url];&#125;&#125;- (void)jumpOrder:(NSURL *)url&#123;//dictionaryFromQueryComponents为字符串处理方法，处理query得到字典NSDictionary *dictionaryQuery = [[url query] dictionaryFromQueryComponents];NSString *orderId = [dictionaryQuery objectForKey:@&quot;orderId&quot;];NSString *type = [dictionaryQuery objectForKey:@&quot;type&quot;];// 创建新的订单页面并且传值&#125; 通过以上几步就可以定义出一个完整的scheme协议并且在JumpURLHandle类里完成解析 需要用到JumpURLHandle解析scheme的地方APP端收到服务器端下发的PUSH通知栏消息和APP相互跳转时需要在AppDelegate里处理12345678910/ 废弃- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(id)annotation&#123;return [JumpURLHandle parseURL:url];&#125;或者- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options&#123;return [JumpURLHandle parseURL:url];&#125; 服务器下发跳转路径，客户端根据服务器下发跳转路径跳转相应的页面,在一个网络请求成功的回调方法或者block里拿到url，调用[JumpURLHandle parseURL:url]; H5页面点击锚点，根据锚点具体跳转路径APP端跳转具体的页面，在UIWebView的代理方法12- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType 中调用，该回调方法返回YES时webView才继续加载页面，当我们通过scheme解析处理事件时就不需要再继续加载页面返回NO.UIWebViewNavigationType的类型有：UIWebViewNavigationTypeLinkClicked，用户触击了一个链接。UIWebViewNavigationTypeFormSubmitted，用户提交了一个表单。UIWebViewNavigationTypeBackForward，用户触击前进或返回按钮。UIWebViewNavigationTypeReload，用户触击重新加载的按钮。UIWebViewNavigationTypeFormResubmitted，用户重复提交表单UIWebViewNavigationTypeOther，发生其它行为。并且不能所有在webView上发生的动作都靠scheme协议解析解决，只有在webView发生用户点击事件或者其他行为时我们才根据request.url进一步判断是否需要scheme解析，代码如下：12345678910111213141516-(BOOL)webView:(UIWebView *)webViewshouldStartLoadWithRequest:(NSURLRequest *)requestnavigationType:(UIWebViewNavigationType)navigationType&#123;if (navigationType == UIWebViewNavigationTypeLinkClicked|| navigationType == UIWebViewNavigationTypeOther)&#123;if (([[request.URL scheme] isEqualToString:@&quot;zqprojectmobile&quot;])|| ([[[request.URL scheme] lowercaseString] isEqualToString:@&quot;zqprojectmobile&quot;]))&#123;[JumpURLHandle parseURL:request.URL];return NO;&#125;&#125;return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWebView认识]]></title>
      <url>%2F2017%2F03%2F04%2FUIWebView%E8%AE%A4%E8%AF%86%2F</url>
      <content type="text"><![CDATA[Objective-C和JavaScript相互调用 通过非框架的方式完成相互的调用OC调用JavaScript语言,通过UIWebView的下面方法来实现1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 该方法向UIWebView传递一段需要执行的JavaScript文件,来获得执行的结果JavaScript调用OC语言,利用UIWebView的特性:在UIWebView内发起的所有网络请求都可以通过delegte函数在原生界面得到通知,我们在UIWebView中发起一个特殊的网络请求,请求加载的网址内容通常不是真实的地址,地址往往类似这样:gap://methodname?argument在delegate的函数中,我们只需要发现是gap://开头地址,就不进行加载转而执行相应的调用逻辑.123456789101112-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123;NSURL *url = [request url];if ([[url scheme] isEqualToString:@&quot;gap&quot;])&#123;//在这里做JavaScript调用oc的事情...//做完之后用以下方法调用JavaScript[webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;done&apos;)&quot;];return NO;&#125;return YES;&#125; 在UIWebView发起一个特殊的网络请求也有很多的办法,最合适的方式是一个临时的隐藏的iFrame,在iFrame中加载这个特殊的网络请求12345678910111213141516171819function loadURL(url)&#123;var iFrame;//创建一个临时的元素iframe = document.createElement(&quot;IFRAME&quot;);//设置临时元素的属性和属性值//添加属性,携带urliFrame.setAttribute(&quot;src&quot;,url);//设置style属性,并且隐藏元素iFrame.setAttribute(&quot;style&quot;,&quot;display: none;&quot;);iFrame.setAttribute(&quot;height&quot;,&quot;Opx&quot;);iFrame.setAttribute(&quot;width&quot;,&quot;Opx&quot;);//规定是否显示框架周围的边框。iFrame.setAttribute(&quot;frameborder&quot;,&quot;0&quot;);//添加属性到bodydocument.body.appendChild(iFrame);//发起请求后这个iFrame就没用了,所以需要把它从dom上移除掉iFrame.parentNode.removeChild(iFrame);iFrame = null;&#125; 当点击按钮的时候1&lt;button onclick=&quot;loadURL(&apos;abc&apos;)&quot;&gt;click&lt;/button&gt; ,通过调用这个function,就能够在1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 方法中截取到请求内容,从而判断来自于js的事件 WebViewJavascriptBridge的使用 iOS端如何使用1.开启日志12// 开启日志，方便调试[WebViewJavascriptBridge enableLogging]; 2.给ObjC与JS建立桥梁1234567给哪个webView建立js与objc的沟通桥梁self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];//代理的设置 这个地方,通过调用这个方法,将自己设置为代理,只是没有直接的通过.delegate来设置,而是通过调用WebViewJavascriptBridge的setWebViewDelegate:方法,都是将自己设为代理,不同的是,通过.delegate是直接将自己设置为代理,而通过调用WebViewJavascriptBridge的setWebViewDelegate,实现了在WebViewJavascriptBridge中将WebViewJavascriptBridge自身设置为真正的代理,完成对UIWebVieView的监听,而同时将代理的回调传递出去.这样就是同一对象的两个监听者[self.bridge setWebViewDelegate:self]; 3.注册HandleName，用于给JS端调用iOS端12345678910111213141516171819// JS主动调用OjbC的方法// 这是JS会调用getUserIdFromObjC方法，这是OC注册给JS调用的// JS需要回调，当然JS也可以传参数过来。data就是JS所传的参数，不一定需要传// OC端通过responseCallback回调JS端，JS就可以得到所需要的数据[self.bridge registerHandler:@&quot;getUserIdFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getUserIdFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;userId&quot;: @&quot;123456&quot;&#125;);&#125;&#125;];[self.bridge registerHandler:@&quot;getBlogNameFromObjC&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;js call getBlogNameFromObjC, data from js is %@&quot;, data);if (responseCallback) &#123;// 反馈给JSresponseCallback(@&#123;@&quot;blogName&quot;: @&quot;颠倒碎碎念&quot;&#125;);&#125;&#125;]; JS端如何使用1.将下面的代码放在JS中123456789101112/*这段代码是固定的，必须要放到js中*///这段代码是固定的书写内容,将这段代码copy and paste到js当中function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&apos;iframe&apos;);WVJBIframe.style.display = &apos;none&apos;;WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 2.在下面的方法当中写相关的js代码:1234setupWebViewJavascriptBridge(function(bridge) &#123;/* Initialize your app here */所有与iOS交互的JS代码放这里！&#125;) 3.JS调用iOS代码通过bridge.callHandler来调用：123456bridge.callHandler(&apos;getBlogNameFromObjC&apos;,&#123;&apos;blogURL&apos;: &apos;http://www.huangyibiao.com&apos;&#125;,function callback(response) &#123;log(&apos;JS got response&apos;, response)&#125;&#125;) 其中的各个参数说明,getBlogNameFromObjC是iOS端注册的handleName,在iOS端也通过这个hanleName完成注册后JS直接通过这个handleName与iOS交互.比如,当点击按钮的时候就执行上面的操作,这样一来,js就将参数传递给了iOS端,iOS收到传递的参数然后通过回调给js.callback:js函数名,在iOS端收到回调后拿到了参数,然后通过闭包回调反馈给js端. 如何传递参数参数传递最简单的方式是将参数作为URL的一部分放到iFrame的src中.UIWebView通过截取分析URL后面的内容即可获得参数.但是,如果参数是一个很复杂的对象,那么这个URL的编码就会很复杂.对此可采取的方案是: 将参数以JSON的形式传递,但是因为要附加在URL之后,所以我们需要将JSON进行Base64编码,以保证URL中不会出现一些非法字符线程阻塞问题当在Objective-C语言中调用stringByEvaluatingJavaScriptFromString:方法必须在主线程执行,而主线程的执行时间过长会阻塞UI的更新.所以我们应该尽量让stringByEvaluatingJavaScriptFromString:方法执行时间短.像云笔记这样的App在保存笔记的时候,需要调用JavaScript代码来获得笔记的完整HTML内容,这个时候,如果笔记内容很复杂,就会执行很长的一段时间,而因为这个操作必须是主线程执行,所以我们要显示”正在保存”的UIAlertView完全无法正常显示,整个UI界面就完全卡主了,所以,这个时候,就需要更新获取HTML内容的代码,来缩短这个执行时长.使用Safari进行调试苹果支持用Safari浏览器直接连接到模拟器或者真机来进行相关HTML页面,以及JavaScript逻辑的调试. 打开Safari的调试模式,选择 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 勾选 “在菜单栏中显示开发菜单”2.同时需要在iPhone模拟器或真机的设置上把调试模式打开, 设置 -&gt; Safari -&gt; 高级 -&gt; 打开Web检查器3.重启Safari,在Safari的”开发”菜单下,就多出了对应的菜单选项我们可以在Safari中直接修改HTML代码,css效果,以及调试JavaScript.所有的效果都可以立即在UIWebView上看到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5学习第二天]]></title>
      <url>%2F2017%2F03%2F03%2FHTML5%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[盒子模型 属性每个盒子模型都有四个属性 内容(content)填充(内边距,padding)边框(border)边界(margin,外边距)标准盒子模型图内容属性heightmax-heightmin-heightwidthmax-widthmin-width填充属性(内边距,padding)paddingpadding-bottompadding-leftpadding-rightpadding-top举例子:内边距1234padding: 10px 5px 15px 10px; 设置上,左,下,右内边距padding: 10px 5px 15px; 设置上,左右,下边距padding: 10px 5px; 设置上下,左右边距padding: 10px; 设置上下左右边距边框(border):设置4个边框的样式123p&#123;border: 5px solid red;&#125;border简写属性在一个声明设置所有的边框属性可以按顺序设置如下属性:border-widthborder-styleborder-color设置边框设置: border-radius边界(margin,外边距)marginmargin-topmargin-bottommargin-leftmargin-right1234margin: 10px 5px 15px 10px; 设置上,左,下,右外边距margin: 10px 5px 15px; 设置上,左右,外边距margin: 10px 5px; 设置上下,左右外边距margin: 10px; 设置上下左右外边距CSS3新增特性RGBA透明度1&lt;div style=&quot;width: 100px; background-color: rgba(255,0,0,1)&quot;&gt;看我的效果&lt;/div&gt;看我的效果块阴影值说明:h-shadow必需。水平阴影的位置。允许负值。v-shadow必需。垂直阴影的位置。允许负值。blur可选。模糊距离。spread可选。阴影的尺寸。color可选。阴影的颜色。请参阅 CSS 颜色值。inset可选。将外部阴影 (outset) 改为内部阴影。12//设置的顺序以此为: 水平阴影, 垂直阴影, 阴影的模糊距离,以及阴影的颜色&lt;div style=&quot;width: 100px; height: 25px; box-shadow: 5px 5px 10px black;&quot;&gt;我是盒子&lt;/div&gt;我是盒子文字阴影在设置参数上与块阴影是一样的1&lt;p style=&quot;font-size: 20px; color: aqua; text-shadow: 5px 5px 10px black&quot;&gt;我看着你呢&lt;/p&gt;我看着你呢圆角 borderradius我变成了圆圆的了CSS布局默认情况下,所有的网页的布局都在标准流布局中: 从上到下,从左到右脱离标准流的方法有float属性position属性和left right top bottom属性floatfloat 属性的常用取值有left: 脱离标准流,浮动到父标签的最左边right: 脱离标准流,浮动到父标签的最右边 具体有关float CSS浮动 可查看W3School的这篇文章 通过float修改首字母样式12345678910&lt;p&gt;&lt;span style=&quot;float: left; width: 0.7em; font-size: 400%; font-family:algerian,courier; line-height:80%;&quot;&gt;T&lt;/span&gt;his is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.&lt;/p&gt; This is some text.This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text.This is some text. This is some text. This is some text. position属性具体有关position 可查看W3School的这篇文章通常positon属性结合left top bottom right属性使用 值描述absolute生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit规定应该从父元素继承 position 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML学习第一天]]></title>
      <url>%2F2017%2F03%2F02%2FHTML%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[HTML5 基础介绍 2014年制定完HTML5标准 利用HTML5编写的UI能够运行在所有的浏览器的平台 手机APP的开发模式: 原生 纯HTML5 原生 + HTML5 自动更新 Web3.0 : HTML5 + CSS3 HTML5: Canvas HTML5音视频 Web存储 Geolocation Workers多线程处理 CSS3亮点: 设计动画 2D变形 一个完整的网页由三部分组成： HTML CSS JavaScript W3school HTML的常见使用 HTML： 超文本标记语言 浏览器负责将它解析成具体的网页内容，HTML语言是松散的 WebStorm的使用： 注释快捷键：command + / 线条： 1\&lt;hr&gt; 输入 1&lt;input placeholder=&quot;我是占位文字&quot;&gt; 1&lt;input value=&quot;我是默认的文字&quot;&gt; 1&lt;input type=&quot;date&quot;&gt; 1&lt;input type=&quot;file&quot;&gt; 1&lt;input type=&quot;color&quot;&gt; 1&lt;input type=&quot;radio&quot;&gt; 1&lt;input type=&quot;checkbox&quot;&gt; 图片标签 alt: 图片显示失败的时候，显示的文字提示 1&lt;img src=&quot;abc.jpg&quot; alt=&quot;这是一张图片&quot;&gt; 12&lt;!—相对路径--&gt;&lt;img src=&quot;image/IMG_0084.png&quot;&gt; 12&lt;!—绝对路径 固定了宽，高会按比例自动缩放—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;100&quot;&gt; 12&lt;!—绝对路径 设置宽与父元素的比例，这样能更好的适配，相对于设置固定的宽度—&gt;&lt;img src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png&quot; width=&quot;50%&quot;&gt; 换行标签 1&lt;br&gt; 列表标签 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 无序列表 无序列表 无序列表 无序列表 无序列表 无序列表 12345678&lt;ul&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt; &lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 有序列表 有序列表 有序列表 有序列表 有序列表 超链接 1&lt;a target=&quot;_self&quot; href=&quot;https://www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_blank&quot; href=&quot;https:www.baidu.com&quot;&gt;我是超链接&lt;/a&gt; 我是超链接 1&lt;a target=&quot;_top&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt; 回到顶部 1&lt;meter value=&quot;30&quot; max=&quot;100&quot; min=&quot;0&quot;&gt;30%&lt;/meter&gt; 30% 1&lt;progress value=&quot;40&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; 1&lt;audio src=&quot;../audio/music.m4a&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt; 视频图片1&lt;video src=&quot;http://player.youku.com/player.php/Type/Folder/Fid//Ob//sid/XMjU1MjMwMDAzNg==/v.swf&quot;&gt;&lt;/video&gt; CSS CSS的使用样式 行内样式 页内样式 外部样式 行内样式1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的行内样式&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;background-color: red;&quot;&gt;//style作为元素的一个属性，将所有样式的样式写在style属性当中 &lt;div style=&quot;color: blue; font-size: 18px; background-color: aqua;&quot;&gt;我是容器标签&lt;/div&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px double purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px solid purple;&quot;&gt;我是段落标签&lt;/p&gt; &lt;p style=&quot;color: red; font-size: 60px; border: 5px dashed purple;&quot;&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 页内样式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css的页内样式&lt;/title&gt; &lt;link href=&quot;css/index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- css规律: 就近原则 叠加原则 --&gt; //在head标签当中写标签样式，样式写在&lt;style&gt;&lt;/style&gt;当中 &lt;style&gt; div&#123; color: red; font-size: 30px; border: 4px solid yellow; &#125; p&#123; color: blue; font-size: 44px; background-color: yellowgreen; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外部样式1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css外部样式&lt;/title&gt; //链接外部css文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;div&gt;我是容器标签&lt;/div&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt; &lt;p&gt;我是段落标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; css中的内容1234567891011div&#123; color: olivedrab; font-size: 66px; background-color: green;&#125;p&#123; color: goldenrod; font-size: 2px; border: 2px solid red;&#125; CSS选择器 标签选择器 12345&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;div&#123; color: red; &#125; 类选择器12345678&lt;p class=&quot;high&quot;&gt;第一段文子&lt;/p&gt;&lt;p&gt;第二段文字&lt;/p&gt;&lt;div class=&quot;high&quot;&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;// . + 类名.high &#123; color: red; &#125; ID选择器123456css: #main &#123; color: gray&#125;html: &lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt; 并列选择器1234567css: 用逗号(,)隔开div , .test1 &#123; color: red;&#125;html: 以下两者都满足&lt;div&gt;我是div&lt;/div&gt;&lt;p class=&quot;test1&quot;&gt;我是段落&lt;/p&gt; 123456css: id值为main，或者class值为test1#main , .test1 &#123;&#125;html: 以下两者都满足&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 复活选择器12345css: div标签并且必须类值为test1div.test1&#123;&#125;html:&lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; 后代选择器123456css: div中的p标签（包括子类和孙子类）div p &#123;&#125;html: 以下两个都满足&lt;div&gt;&lt;p&gt;我满足条件&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;h2&gt;&lt;p&gt;我也满足&lt;/p&gt;&lt;/h2&gt;&lt;/div&gt; 直接后代选择器12345css: div &gt; a &#123;&#125;html:&lt;div&gt;&lt;a href=&quot;#&quot;&gt;我满足&lt;/a&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;我不满足😌&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 属性选择器123456css:div[name]&#123;&#125;html:&lt;div name=&quot;jack&quot;&gt;我满足&lt;/div&gt;&lt;div name=&quot;rose&quot;&gt;我也满足&lt;/div&gt;&lt;div age=&quot;23&quot;&gt;我不满足&lt;/div&gt; 特定属性值选择器12345css:div[name=&quot;jack&quot;]&#123;&#125;html:&lt;div name=&quot;rose&quot;&gt;我不😌&lt;/div&gt;&lt;div name=&quot;jack&quot;&gt;我满足😄&lt;/div&gt; 伪类1234567891011121314151617css: /*触发某些操作的时候更改一些样式*/input:focus &#123;/*去除外线条*/outline: none;height: 50px;font-size: 20px;&#125;/*当鼠标移动上来*/#main:hover&#123;width: 300px;height: 200px;background-color: aqua;&#125;html:&lt;div id=&quot;main&quot;&gt;我是div标签&lt;/div&gt;&lt;input placeholder=&quot;我是输入框&quot;&gt; 伪元素/伪元素 比如段落的第一个字母变大,可以通过伪元素实现/ 选择器优先级选择器的权值： 通配选择符(*) : 0 标签: 1 类: 10 属性：10 伪类： 10 伪元素: 10 id: 100 important: 1000 原则： 选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 优先级顺序： important &gt; 内联（行内style）&gt;id&gt;类|伪类|伪元素|属性|伪元素&gt;标签&gt;统配选择符 HTML标签的分类和修改 标签的分类 块级标签 独占一行，能够通过css修改高度(div、p、h1、h2、ul、li…) 行内标签（内联标签） 多个行内标签能同时显示在一行，并且无法修改其宽高 宽度和高度取决于内容的尺寸 (span、a、label….) 行内-块级标签 (内联-块级标签) 多个行类块级标签能够显示在一行 :具备了内联标签的特点 能够设置宽度和高度(input, button) : 具备了块级标签的特点修改标签的显示类型通过css中的display属性，能够修改显示的类型 none: 隐藏标签 block: 让标签变成块级标签 inline: 让标签变成内联标签 inline-block: 让标签变成内联-块级标签 其他属性介绍cursor： 🖱鼠标样式text-decoration:规定添加到文本的修饰123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;h1 &#123;text-decoration: overline&#125;h2 &#123;text-decoration: line-through&#125;h3 &#123;text-decoration: underline&#125;h4 &#123;text-decoration: blink&#125;a &#123;text-decoration: none&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是标题 1&lt;/h1&gt;&lt;h2&gt;这是标题 2&lt;/h2&gt;&lt;h3&gt;这是标题 3&lt;/h3&gt;&lt;h4&gt;这是标题 4&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3school.com.cn/index.html&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; line-through: 看我overline:看我underline:看我blink:看我 用text-decoration去掉超链接的下划线 这是一个超链接，但是没有下划线，因为我有值为none的text-decoration呀 text-indent将段落的第一行缩进 50 像素：1234css:p&#123; text-indent:50px;&#125; list-style:把图像设置为列表中的列表项目标记：1234css:ul&#123; list-style:square inside url(&apos;/i/arrow.gif&apos;); &#125; 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;ul &#123;list-style: square inside url(&apos;/i/eg_arrow.gif&apos;)&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;&lt;li&gt;咖啡&lt;/li&gt;&lt;li&gt;茶&lt;/li&gt;&lt;li&gt;可口可乐&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 可以按顺序设置如下属性： list-style-type list-style-position list-style-imag overflow: 在宽高固定的情况下，内容超出的时候的显示样式123456div &#123; width:150px; height:150px; overflow:scroll; &#125; 默认值： visible可能的值值 描述visible 默认值。内容不会被修剪，会呈现在元素框之外。 hidden 内容会被修剪，并且其余内容是不可见的。 scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit 规定应该从父元素继承 overflow 属性的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIWindow笔记]]></title>
      <url>%2F2017%2F03%2F02%2FUIWindow%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[UIWindow更多的时候只作为UIView的顶层容器存在 UIWindow的主要作用有： 作为UIView的最顶层容器，包含应用所需要的所有的UIView 传递触摸消息和键盘事件给UIView 为UIWindow增加UIView 因为其本身是UIView的子类，所以可以调用addSubView方法 通过设置其特有的rootViewController属性。 通过设置其属性添加view对应的UIViewController，UIWindow自动将其view添加到当前window中。同时负责维护ViewController和view的生命周期。 系统对UIWindow的使用 调用系统的控件时(UIAlertView)，iOS系统为了保证UIAlertView在所有的界面之上，它会临时创建一个新的UIWindow，通过将其UIWindow的UIWindowLevel设置得更高，让UIAlertView盖在所有的应用界面之上 WindowLevel UIWindow的UIWindowLevel属性，定义了UIWindow的层级 UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal; UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert; UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar 通过代码将这些值输出： NSLog(@&quot;UIWindowLevelAlert - %lf ,UIWindowLevelNormal %lf, UIWindowLevelStatusBar %lf&quot;,UIWindowLevelAlert,UIWindowLevelNormal,UIWindowLevelStatusBar); 输出的结果为： UIWindowLevelAlert - 2000.000000 ,UIWindowLevelNormal 0.000000, UIWindowLevelStatusBar 1000.000000 默认的UIWindow层级为UIWindowLevelNormal，当系统需要在其上面覆盖UIAlerView时，创建一个UIWindowLevelAlert层级的UIWindow 手工创建UIWindow 创建UIWindow和UIView不同的是，一旦被创建，它会自动的被添加到界面上。 @interface ViewController () { UIWindow *_uiwindow; } @end - (IBAction)click:(id)sender { _uiwindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; //设置其层级 _uiwindow.windowLevel = UIWindowLevelNormal; _uiwindow.backgroundColor = [UIColor redColor]; _uiwindow.hidden = NO; UIGestureRecognizer *gesture = [[UITapGestureRecognizer alloc] init]; [gesture addTarget:self action:@selector(hideWindow:)]; [_uiwindow addGestureRecognizer:gesture]; } -(void)hideWindow:(UIGestureRecognizer *)gesture{ _uiwindow.hidden = YES; //移除的方式就是清空 _uiwindow = nil; } 作者(唐巧)在做有道云笔记时，想做一个密码保护功能，当用户从应用的任何界面按Home键退出，过一段时间再从后台换回来时，显示一个密码输入界面。这个密码界面可能从任何应用界面弹出，并且需要盖在所有界面的最上层，它很适合用一个UIWindow来实现 #import &lt;UIKit/UIKit.h&gt; @interface PasswordInputWindow : UIWindow -(void)show; +(instancetype)sharedInstance; @end #import &quot;PasswordInputWindow.h&quot; @implementation PasswordInputWindow{ UITextField *_textField; } +(instancetype)sharedInstance{ //更改其生命周期 static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] initWithFrame:[UIScreen mainScreen].bounds]; }); return sharedInstance; } -(instancetype)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 50, 200, 20)]; label.text = @&quot;请输入密码&quot;; [self addSubview:label]; UITextField *textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 80, 200, 20)]; textField.backgroundColor = [UIColor whiteColor]; //密码输入时单个显示 textField.secureTextEntry = YES; [self addSubview:textField]; UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(10, 110, 200, 44)]; [button setBackgroundColor:[UIColor blueColor]]; button.titleLabel.textColor = [UIColor blackColor]; [button setTitle:@&quot;确定&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(completeButtonPressed) forControlEvents:UIControlEventTouchUpInside]; self.backgroundColor = [UIColor yellowColor]; [self addSubview:button]; _textField = textField; } return self; } -(void)show{ //使其成为主窗口，调用这个方法就让当前窗口成为主窗口 [self makeKeyWindow]; self.hidden = NO; } -(void)completeButtonPressed{ if ([_textField.text isEqualToString:@&quot;abcd&quot;]) { //关闭键盘 [_textField resignFirstResponder]; //辞去主窗口 [self resignKeyWindow]; self.hidden = YES; }else{ [self showErrorAlertView]; } } -(void)showErrorAlertView{ UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:nil message:@&quot;密码 错误，正确密码是abcd&quot; delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil]; [alertView show]; } @end 只需要在应用进入后台的回调函数中，将该UIWindow创建显示出来即可 - (void)applicationDidEnterBackground:(UIApplication *)application { [[PasswordInputWindow sharedInstance] show]; } 需要注意的是，如果我们创建的window需要处理键盘事件，那就需要合理的将其设置为keyWindow.keyWindow是被系统设计用来接收键盘和其他非触摸事件的UIWindow。通过makeKeyWindow和resignKeyWindow来将自己的window设置为keyWindow，以及辞去keyWindow，]]></content>
    </entry>

    
  
  
</search>
